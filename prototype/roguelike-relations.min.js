(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.BVG = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//
/** # BVG - Bindable Vector Graphics
  * **Real-time data-driven visualisation for the web.**
  *
  * ![Example](https://raw.githubusercontent.com/Spaxe/BVG.js/master/demo/index.gif)
  *
  * Live example: http://spaxe.github.io/BVG.js/
  *
  * *Bindable Vector Graphics* was born out of frustration for lack of a
  * middle level SVG library. [D3.js](http://d3js.org/) abstracts too much
  * logic, and [SVG.js](http://svgjs.com/) provides only low-level SVG drawing.
  * Bindable Vector Graphics offers SVG elements that change as the data change,
  * and gives you tools to control their look.
  */
'use strict';

/** The heart of this library is a trinity: **SVG + Data + Binding**. This
  * connects your data to the SVG element through the binding function, which
  * creates a living connection that can react to change. BVG uses
  * [`Object.observe()`](http://caniuse.com/#feat=object-observe) which is
  * available on Chrome 36+, Opera 27+ and Android Browser 37+.
  *
  * If you wish to use this for older browsers, you can polyfill with
  * [`MaxArt2501/Object.observe`](https://github.com/MaxArt2501/object-observe).
  *
  * ## Installation
  *
  * **Install using `npm`**:
  *
  *  1. Install Node.js: https://docs.npmjs.com/getting-started/installing-node
  *  2. In your working directory:
  *
  *     ```
  *     npm install bvg
  *     ```
  *
  * **Install via GitHub**:
  *
  *  1. Clone this repo:
  *
  *     ```
  *     git clone https://github.com/Spaxe/BVG.js.git
  *     ```
  *
  *  2. Copy `require.js` and `bvg.js` into your working directory.
  *
  * **To include `BVG.js` in your webpage**:
  *
  *  1. In your HTML `<head>`, include this script using `require.js`:
  *
  *     ```HTML
  *     <script src="path/to/require.js" data-main="your-script.js"></script>
  *     ```
  *
  *  2. In `your-script.js`, define your own code with
  *
  *     ```Javascript
  *     require(['path/to/bvg.js'], function (BVG) {
  *       // your code goes here ...
  *     });
  *     ```
  *
  * ## Quickstart
  *
  * ![Quickstart Example](https://raw.githubusercontent.com/Spaxe/BVG.js/master/demo/001-hello.gif)
  *
  * HTML:
  *
  * ```HTML
  * <div id="bvg-container"></div>
  * ```
  *
  * CSS (Make the container large enough):
  *
  * ```CSS
  * html, body, #bvg-container {
  *   height: 100%;
  *   margin: 0;
  * }
  * ```
  *
  * Javascript:
  *
  * ```Javascript
  * // Create a BVG container based on selected HTML element
  * var bvg = BVG.create('#bvg-container');
  * // Create a Bindable circle, colour it orange
  * var circle = bvg.ellipse(0, 0, 150, 150)
  *                 .fill(220, 64, 12);
  * // Change its size based on mouse movement
  * bvg.tag().addEventListener('mousemove', function (event) {
  *   circle.data({
  *     rx: event.clientX,
  *     ry: event.clientY
  *   });
  * });
  * ```
  */

/*- Deep Object.observe() */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BVG;
function observe(obj, callback) {

  // Include https://github.com/MaxArt2501/object-observe if you wish to work
  // with polyfill on browsers that don't support Object.observe()
  Object.observe(obj, function (changes) {
    changes.forEach(function (change) {

      // Bind child property if it is an object for deep observing
      if (obj[change.name] instanceof Object) {
        observe(obj[change.name], callback);
      }
    });

    // Trigger user callback
    callback.call(this, changes);
  });

  // Immediately fire observe to initiate deep observing
  Object.keys(obj).forEach(function (key) {
    if (obj[key] instanceof Object) {
      observe(obj[key], callback);
    }
  });
}

/*- `BVG(tag, data, binding)`
  * The trinity of this library: SVG + Data + Binding Function.
  *
  * Return the BVG object created.
  *
  *  - `tag`    : Either a `String` for the SVG `tagName` or any [`SVGElement`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element)
  *  - `data`   : Object with arbitrary data to your desire
  *  - `binding`: (optional) Binding function that sets the tag attributes
  */
function BVG(tag, data, binding) {
  var bvg = this;
  tag = tag instanceof SVGElement ? tag : document.createElementNS('http://www.w3.org/2000/svg', tag);
  data = data || {};
  binding = binding || function (tag, data) {
    for (var prop in data) {
      if (data.hasOwnProperty(prop)) {
        tag.setAttribute(prop, data[prop]);
      }
    }
  };

  // Observe data object and apply binding right away
  observe(data, function (changes) {
    binding(tag, data);
  });
  binding(tag, data);

  // ID function from https://gist.github.com/gordonbrander/2230317
  tag.setAttribute('id', 'BVG_' + tag.tagName + '_' + Math.random().toString(36).substr(2, 7));
  this._tag = tag;
  this._data = data;
  this._binding = binding;

  // Functional circular reference
  this._tag._getBVG = function () {
    return bvg;
  };

  if (['svg', 'g', 'a'].indexOf(tag.tagName) < 0) {
    if (!data.stroke) this.stroke(175);
    if (!data.strokeWidth) this.strokeWidth(0.5);
    if (!data.fill) this.noFill();
  }

  return this;
};

/** ## The BVG Container
  * The rest of the documentation will assume `bvg` as our BVG container
  * created by the example below.
  */

/** ### `BVG.create(htmlElement)`
  * Create a BVG container inside `htmlElement`.
  *
  * Return the BVG container object.
  *
  *  - `htmlElement`  : Either a [CSS Selector](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
  *                     or any [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
  *
  * ```Javascript
  * // Create a new BVG container and append it to an existing HTML element.
  * var bvg = BVG.create('#bvg-container');
  * ```
  */
var create = exports.create = BVG.create = function (htmlElement, xDimension, yDimension) {
  if (typeof htmlElement === 'string') htmlElement = document.querySelector(htmlElement);
  if (!(htmlElement instanceof HTMLElement)) throw new TypeError('htmlElement (' + htmlElement + ') was not found.');

  var data = {
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    version: 1.1,
    width: '100%',
    height: '100%'
  };
  yDimension = yDimension || xDimension;
  if (xDimension) {
    data.viewBox = [0, 0, xDimension, yDimension].join(' ');
  }

  var bvg = new BVG('svg', data);
  htmlElement.appendChild(bvg.tag());
  return bvg;
};

/** ## BVG Elements
  * All BVG objects, including the container, have access to drawing functions
  * and return reference to the new shape, which is also a BVG.
  *
  * ```Javascript
  * // Create a rectangle at (0, 0) with dimensions 100x100 px and add it to bvg
  * var rect = bvg.rect(0, 0, 100, 100);
  * ```
  *
  * The BVG module also has drawing functions, which return the BVG object:
  *
  * ```Javascript
  * // Create a rectangle at (0, 0) with dimensions 100x100 px
  * // Note it uses the BVG module directly to create the rectangle.
  * var rect = BVG.rect(0, 0, 100, 100);
  * // Add the rectangle to an existing BVG container
  * bvg.append(rect);
  * ```
  *
  * Drawing functions can be called in a number of ways. Take `bvg.rect(x, y, width, height)`
  * as an example below. Sometimes it is easier to use one over another style.
  *
  * ```Javascript
  * bvg.rect(0, 10, 30, 70);      // Arguments style
  * bvg.rect({                    // Object style
  *   x: 0,
  *   y: 10,                      // Name of the object properties must match
  *   width: 30,                  // names of the arguments in the functions,
  *   height: 70                  // but the order can be any.
  * });
  * ```
  */
var creationFunctions = {
  svg: function svg(xlink, version, width, height) {
    return new BVG('svg', xlink.constructor.name === 'Object' ? xlink : {
      'xmlns:xlink': xlink,
      version: version,
      width: width,
      height: height
    });
  },

  /** ### `bvg.rect(x, y, width, height)`
    * Create a rectangle at position `(x, y)` at `width` x `height` in size.
    *
    * ```Javascript
    * var rect = bvg.rect(100, 100, 300, 150);
    * ```
    */
  rect: function rect(x, y, width, height) {
    return new BVG('rect', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      width: width,
      height: height
    });
  },

  /** ### `bvg.circle(cx, cy, r)`
    * Create a circle centred on `(cx, cy)` with radius `r`.
    *
    * ```Javascript
    * var circle = bvg.ellipse(100, 100, 50);
    * ```
    */
  circle: function circle(x, y, r) {
    return new BVG('circle', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      r: r
    }, function (tag, data) {
      tag.setAttribute('cx', data.x);
      tag.setAttribute('cy', data.y);
      tag.setAttribute('r', data.r);
    });
  },

  /** ### `bvg.ellipse(cx, cy, rx, ry)`
    * Create a ellipse centred on `(cx, cy)` with radii `rx` and `ry`.
    *
    * ```Javascript
    * var ellipse = bvg.ellipse(100, 100, 200, 180);
    * ```
    */
  ellipse: function ellipse(x, y, rx, ry) {
    return new BVG('ellipse', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      rx: rx,
      ry: ry
    }, function (tag, data) {
      tag.setAttribute('cx', data.x);
      tag.setAttribute('cy', data.y);
      tag.setAttribute('rx', data.rx);
      tag.setAttribute('ry', data.ry);
    });
  },

  /** ### `bvg.line(x1, y1, x2, y2)`
    * Create a line from `(x1, y1)` to `(x2, y2)`.
    *
    * ```Javascript
    * var line = bvg.line(100, 100, 200, 300);
    * ```
    */
  line: function line(x1, y1, x2, y2) {
    return new BVG('line', x1.constructor.name === 'Object' ? x1 : {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2
    });
  },
  /** ### `bvg.polyline([[x1, y1], [x2, y2], ...])`
    * Create a series of lines from point to point.
    *
    * ```Javascript
    * var polyline = bvg.polyline([[100, 200], [200, 300], [400, 800]]);
    * ```
    */
  polyline: function polyline(points) {
    return new BVG('polyline', points.constructor.name === 'Object' ? points : {
      points: points
    }, function (tag, data) {
      tag.setAttribute('points', data.points.join(' '));
    });
  },
  /** ### `bvg.polygon([[x1, y1], [x2, y2], ...])`
    * Create a closed polygon from point to point. The last point will be
    * connected back to the first point.
    *
    * ```Javascript
    * var polygon = bvg.polygon([[100, 200], [200, 300], [400, 800]]);
    * ```
    */
  polygon: function polygon(points) {
    return new BVG('polygon', points.constructor.name === 'Object' ? points : {
      points: points
    }, function (tag, data) {
      tag.setAttribute('points', data.points.join(' '));
    });
  },

  /** ## Grouping Elements
    * ### `bvg.group([transform])`
    *
    * Create a group to contain BVG objects. It acts like a BVG container with
    * an optional `transform` attribute.
    *
    * ```Javascript
    * // Create a new group and fill it with dashes.
    * var dashes = bvg.group();
    * for (int i = 0; i < 5; i++) {
    *   dahses.rect(10, 10 + i * 30, 50, 20);
    * }
    * ```
    */
  group: function group(transform) {
    return new BVG('g', transform.constructor.name === 'Object' ? transform : {
      transform: transform
    });
  },

  /** ## Hyperlinks
    * ### `bvg.hyperlink(url)`
    *
    * Create a hyperlink BVG to target URL `url`. It does not have any display
    * elements. Make sure to append elements to it.
    *
    * ```Javascript
    * // Clicking on this element will bring them to the Github page
    * var githubLink = bvg.hyperlink('https://github.com/spaxe/BVG.js');
    * // Make a button and attack it to the link
    * githubLink.ellipse(200, 200, 50, 50);
    * ```
    */
  hyperlink: function hyperlink(url) {
    return new BVG('a', url.constructor.name === 'Object' ? url : {
      'xmlns:href': url
    });
  },

  /** ## Other Geometry
    * ### `bvg.triangle(cx, cy, r)`
    * Create a regular triangle centred on `(cx, cy)` with vertices `r` distance
    * away.
    *
    * ```Javascript
    * var triangle = bvg.triangle(50, 50, 10);
    * ```
    */
  triangle: function triangle(x, y, r) {
    return new BVG('polygon', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      r: r
    }, function (tag, data) {
      var points = [[data.x, data.y - data.r], [data.x - data.r / 2 * Math.sqrt(3), data.y + data.r / 2], [data.x + data.r / 2 * Math.sqrt(3), data.y + data.r / 2]];
      tag.setAttribute('points', points.join(' '));
    });
  },

  /** ### `bvg.arc(cx, cy, rx, ry, startAngle, endAngle)`
    * Create an arc centred on `(cx, cy)` with radius `rx` and `ry`, starting
    * from `startAngle` anti-clockwise to `endAngle`, where 0 is the positive
    * x-axis.
    *
    * ```Javascript
    * var arc = bvg.arc(50, 50, 50, 100, 0, Math.PI);
    * ```
    */
  arc: function arc(x, y, rx, ry, startAngle, endAngle) {
    return new BVG('path', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      rx: rx,
      ry: ry,
      startAngle: startAngle,
      endAngle: endAngle
    }, function (tag, data) {
      var p1 = getPointOnEllipse(data.x, data.y, data.rx, data.ry, data.startAngle);
      var p2 = getPointOnEllipse(data.x, data.y, data.rx, data.ry, data.endAngle);
      var largeArc = data.endAngle - data.startAngle > Math.PI ? 1 : 0;
      var sweepArc = data.endAngle > data.startAngle ? 1 : 0;
      var d = [['M', p1.x, p1.y], ['A', data.rx, data.ry, 0, largeArc, sweepArc, p2.x, p2.y]];
      tag.setAttribute('d', d.map(function (x) {
        return x.join(' ');
      }).join(' '));

      function getPointOnEllipse(x, y, rx, ry, angle) {
        return {
          x: rx * Math.cos(angle) + x,
          y: ry * Math.sin(angle) + y
        };
      }
    });
  },

  /** ### `bvg.text(text, x, y)`
    * Create a string of `text` text at location `(x, y)`.
    *
    * ```Javascript
    * var text = bvg.text('Mrraa!', 20, 10);
    * ```
    */
  text: function text(_text, x, y) {
    return new BVG('text', _text.constructor.name === 'Object' ? _text : {
      text: _text,
      x: x,
      y: y
    }, function (tag, data) {
      tag.innerHTML = data.text;
      tag.setAttribute('x', data.x);
      tag.setAttribute('y', data.y);
    }).fill('rgba(175, 175, 175, 1)').stroke('rgba(0, 0, 0, 0)');
  }
};

Object.keys(creationFunctions).forEach(function (f) {
  BVG[f] = function () {
    return creationFunctions[f].apply(BVG, arguments);
  };
  BVG.prototype[f] = function () {
    var bvg = creationFunctions[f].apply(this, arguments);
    this.append(bvg);
    return bvg;
  };
});

/** ## The BVG Object
  * BVGs are SVGs with extra superpowers.
  */

/** ### `bvg.find(selector)`
  * Return an array of BVGs matching `selector` inside BVG. `selector` is
  * defined as [CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors).
  */
BVG.prototype.find = function (selector) {
  var result = this._tag.querySelectorAll(selector);
  if (result) {
    var bvgs = [];
    [].slice.call(result).forEach(function (r) {
      bvgs.push(r._getBVG());
    });
    return bvgs;
  }
  return [];
};

/** ### `bvg.append(bvg)`
  * Insert `child_bvg` inside `bvg`. This is useful to add elements inside a
  * `BVG.group()`.
  */
BVG.prototype.append = function (child_bvg) {
  this._tag.appendChild(child_bvg._tag);
  return this;
};

/** ### `bvg.remove()`
  * Remove itself from its parent. Return self reference.
  */
BVG.prototype.remove = function () {
  var parent = this.parent();
  if (parent) {
    parent._tag.removeChild(this._tag);
  }
  return this;
};

/** ### `bvg.parent()`
  * Return the parent BVG. If there is no parent (such is the case for the BVG
  * container itself), return null.
  */
BVG.prototype.parent = function () {
  if (this._tag.parentNode && typeof this._tag.parentNode._getBVG === 'function') return this._tag.parentNode._getBVG();
  return null;
};

/** ### `bvg.children()`
  * Return a list of BVG elements inside `bvg`.
  */
BVG.prototype.children = function () {
  var output = [];
  for (var i = 0; i < this._tag.childNodes.length; i++) {
    if (typeof this._tag.childNodes[i]._getBVG === 'function') output.push(this._tag.childNodes[i]._getBVG());
  }return output;
};

/** ### `bvg.tag()`
  * Return thw BVG graphical content, a SVG.
  */
BVG.prototype.tag = function () {
  return this._tag;
};

/** ### `bvg.data()`
 * Get/set the `data` object in a BVG. There are four ways to use this
 * function.
 *
 *  - `bvg.data()`: Return `data` bound to the BVG.
 *  - `bvg.data(newData)`: Update `data` with `newData` object.
 *  - `bvg.data(property)`: Return `data[property]` from the BVG.
 *  - `bvg.data(property, newValue)`: Update `property` with `newValue`.
 *
 * Return `bvg` object reference.
 */
BVG.prototype.data = function () {
  if (arguments.length === 0) {
    return this._data;
  } else if (arguments.length === 1) {
    if (arguments[0].constructor.name === 'Object') {
      for (var k in arguments[0]) {
        if (arguments[0].hasOwnProperty(k)) {
          this.data(k, arguments[0][k]);
        }
      }
      return this;
    } else {
      return this._data[arguments[0]];
    }
  } else if (arguments.length === 2) {
    this._data[arguments[0]] = arguments[1];
    return this;
  } else {
    throw new RangeError(this, 'data() received more than 2 arguments.');
  }
};

/** ### `bvg.attr()`
  * Get/set attributes on a BVG.
  *
  *  - `bvg.attr(attr)`: Return attribute value.
  *  - `bvg.attr(attr, value)`: Update `attr` with `value`.
  */
BVG.prototype.attr = function (attr, value) {
  if (!attr) throw new Error('attr must be defined');
  if (!value) return this._tag.getAttribute(attr);else this._tag.setAttribute(attr, value);
  return this;
};

/** ### `bvg.fill()`
  * Get/set the filling colour.
  *
  *  - `bvg.fill()`: Return `fill` colour as [r, g, b, a], or `''` (empty
  *                  strig) if fill is not specified on the object.
  *  - `bvg.fill(rgb)`: Set `fill` with a greyscale colour with equal
  *    values `(rgb, rgb, rgb)`.
  *  - `bvg.fill(r, g, b, [a])`: Set `fill` with `(r, g, b, a)`. If `a`
  *    is omitted, it defaults to `1`.
  *
  * `r`, `g`, `b` should be in the range of 0-255 inclusive.
  */
BVG.prototype.fill = function () {
  if (arguments.length === 0) {
    var f = this.attr('fill');
    if (f) return BVG.extractNumberArray(f);
    return '';
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'string') return this.attr('fill', arguments[0]);else return this.attr('fill', BVG.rgba(arguments[0]));
  } else if (arguments.length === 3 || arguments.length === 4) {
    return this.attr('fill', BVG.rgba.apply(BVG, arguments));
  } else {
    throw new RangeError(this, 'fill() received more than 1 argument.');
  }
};

/** ### `bvg.noFill()`
  * Remove BVG object's colour filling completely.
  */
BVG.prototype.noFill = function () {
  return this.fill('rgba(0, 0, 0, 0)');
};

/** ### `bvg.stroke()`
  * Get/set the outline colour.
  *
  *  - `bvg.stroke()`: Return `stroke` colour as [r, g, b, a]. If `stroke` is
  *    not specified, return `''` (empty string).
  *  - `bvg.stroke(rgb)`: Set `stroke` with a greyscale colour with equal
  *    values `(rgb, rgb, rgb)`.
  *  - `bvg.stroke(r, g, b, [a])`: Set `stroke` with `(r, g, b, a)`. If `a`
  *    is omitted, it defaults to `1`.
  *
  * `r`, `g`, `b` should be in the range of 0-255 inclusive.
  */
BVG.prototype.stroke = function () {
  if (arguments.length === 0) {
    var s = this.attr('stroke');
    if (s) return BVG.extractNumberArray(s);
    return '';
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'string') return this.attr('stroke', arguments[0]);else return this.attr('stroke', BVG.rgba(arguments[0]));
  } else if (arguments.length === 3 || arguments.length === 4) {
    return this.attr('stroke', BVG.rgba.apply(BVG, arguments));
  } else {
    throw new RangeError(this, 'stroke() received more than 1 argument.');
  }
};

/** ### `bvg.strokeWidth([width])`
  * Get/set the outline thickness.
  *
  * Returns the current outline thickness if `width` is omitted. Otherise,
  * it assigns the outline thickness with a new value, and returns the `bvg`
  * object reference.
  *
  *  - `width`  : Outline thickness in pixels.
  */
BVG.prototype.strokeWidth = function () {
  if (arguments.length === 0) {
    return this.attr('stroke-width');
  } else if (arguments.length === 1) {
    this.attr('stroke-width', arguments[0]);
    return this;
  } else {
    throw new RangeError(this, 'strokeWidth() received more than 1 argument.');
  }
};

/** ### `bvg.noStroke()`
  * Remove BVG object's outline completely.
  */
BVG.prototype.noStroke = function () {
  return this.strokeWidth(0).stroke('rgba(0, 0, 0, 0)');
};

BVG.prototype.content = function () {
  if (arguments.length === 0) {
    return this._tag.innerHTML;
  } else if (arguments.length === 1) {
    this._tag.innerHTML = arguments[0];
    return this;
  } else {
    throw new RangeError(this, 'content() received more than 1 argument.');
  }
};

/** ### `bvg.addClass(c)`
* Add a class name to the element.
*/
BVG.prototype.addClass = function (c) {
  this._tag.classList.add(c);
  return this;
};

/** ### `bvg.removeClass(c)`
  * Remove a class name to the element.
  */
BVG.prototype.removeClass = function (c) {
  this._tag.classList.remove(c);
  return this;
};

/** ### `bvg.hasClass(c)`
  * Return true if the element has class `c`.
  */
BVG.prototype.hasClass = function (c) {
  return this._tag.classList.contains(c);
};

/** ### `bvg.removeClass(c)`
  * Add or remove the class `c` to the element.
  */
BVG.prototype.toggleClass = function (c) {
  this._tag.classList.toggle(c);
  return this;
};

/** ## Affine Transformations */
BVG.prototype.transform = function () {
  if (arguments.length === 0) {
    return this._tag.getAttribute('transform') || '';
  } else if (arguments.length === 1) {
    this._tag.setAttribute('transform', arguments[0]);
    return this;
  } else {
    throw new Error('transform() received more than 1 argument');
  }
};

/** ### `BVG.translate(x, [y])`
  * Apply a moving translation by `x` and `y` units. If `y` is not given, it
  * is assumed to be 0.
  */
BVG.prototype.translate = function (x, y) {
  if (typeof x !== 'number' && typeof y !== 'number') throw new Error('translate() only take numbers as arguments');
  y = y || 0;
  var transform = this.transform();
  this._tag.setAttribute('transform', [transform, ' translate(', x, ' ', y, ')'].join('').trim());
  return this;
};

/** ## Utility Methods */

/** ### `BVG.rgba(r, g, b, [a])`
  * Return a string in the form of `rgba(r, g, b, a)`.
  *
  * If only `r` is given, the value is copied to `g` and `b` to produce a
  * greyscale value.
  */
BVG.rgba = function (r, g, b) {
  var a = arguments.length <= 3 || arguments[3] === undefined ? 1.0 : arguments[3];

  if (typeof r !== 'number') throw new TypeError('rgba() must take numerical values as input');
  g = g || r;
  b = b || r;
  return 'rgba(' + [r, g, b, a].join(',') + ')';
};

/** ### `BVG.hsla(hue, saturation, lightness, [alpha])`
  * Return the CSS representation in `hsla()` as a string.
  *
  *  - `hue`: A value between `0` and `360`, where `0` is red, `120` is green,
  *           and `240` is blue.
  *  - `saturation` : A value between `0` and `100`, where `0` is grey and
  *                 `100` is fully saturate.
  *  - `lightness`: A value between `0` and `100`, where `0` is black and
  *                 `100` is full intensity of the colour.
  */
BVG.hsla = function (hue, saturation, lightness, alpha) {
  alpha = alpha || 1.0;
  return 'hsla(' + [hue, saturation + '%', lightness + '%', alpha].join(',') + ')';
};

/** ### `BVG.extractNumberArray(str)`
  * Return an array `[x, y, z, ...]` from a string containing common-separated
  * numbers.
  */
BVG.extractNumberArray = function (str) {
  return str.match(/\d*\.?\d+/g).map(Number);
};

/** ## Contribute to this library
* [Make a pull request](https://github.com/Spaxe/BVG.js/pulls) or
* [post an issue](https://github.com/Spaxe/BVG.js/issues). Say hello to
* contact@xaiverho.com.
*/

},{}]},{},[1])(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
"use strict";

var _bvg = require("bvg");

var _bvg2 = _interopRequireDefault(_bvg);

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; } /**
                                                                                                                              * Roguelike Universe
                                                                                                                              * Author: Xavier Ho <contact@xavierho.com>
                                                                                                                              * https://github.com/Spaxe/roguelike-universe
                                                                                                                              */

var server_url = 'http://188.166.209.155/api/v1';
var start_year = 1970,
    end_year = 2020;
var fx = _util.ratio.bind(_util.ratio, start_year, end_year);

document.addEventListener('DOMContentLoaded', function () {

  var bvg = _bvg2.default.create('#container');
  var focus = bvg.group({});
  var width = bvg.tag().clientWidth;
  var height = bvg.tag().clientHeight;
  var GUI_game = document.getElementById('game');
  var selection = 'Dungeon';

  loadRoguelikeRelationsAll().then(function (relations) {

    // Draw timeline
    bvg.text('year', 0.001 * width, height / 2 + 3);
    for (var i = start_year + 2; i < end_year; i++) {
      bvg.text(i.toString().substr(2, 4), (fx(i) - 0.005) * width, height / 2 + 3);
    }

    // Populate game titles
    relations.forEach(function (game) {
      var option = document.createElement('option');
      option.value = game.title;
      option.setAttribute('data-year', game.year);
      option.innerHTML = game.title + " (" + game.year + ")";
      GUI_game.appendChild(option);
    });

    // Bind selection
    GUI_game.addEventListener('change', function (event) {
      selection = event.target.value;
      drawSelection(selection);
    });

    // Draw influence arcs
    relations.forEach(function (_ref) {
      var title = _ref.title;
      var year = _ref.year;
      var inspiredBy = _ref.inspiredBy;
      var inspirationTo = _ref.inspirationTo;
      var otherInspiredBy = _ref.otherInspiredBy;
      var otherInspirationTo = _ref.otherInspirationTo;

      inspiredBy.forEach(function (r) {
        drawArc(bvg, year, r.year, -1.0, 0.1);
      });
      inspirationTo.forEach(function (r) {
        drawArc(bvg, r.year, year, -1.0, 0.1);
      });
      otherInspiredBy.forEach(function (r) {
        drawArc(bvg, year, r.year, 1.0, 0.05);
      });
      otherInspirationTo.forEach(function (r) {
        drawArc(bvg, r.year, year, 1.0, 0.05);
      });
    });

    var drawSelection = function drawSelection(selection) {
      focus.tag().innerHTML = '';

      var _loop = function _loop(i) {
        var relation = relations[i];
        if (relation.title === selection) {

          focus.text(selection, fx(relation.year) * width, 0.095 * height).fill(0);

          focus.line({
            x1: fx(relation.year) * width,
            y1: height * 0.1,
            x2: fx(relation.year) * width,
            y2: height * 0.9
          }).strokeWidth(2).stroke(0, 0, 0, 0.5);

          relation.inspiredBy.forEach(function (r) {
            drawArc(focus, relation.year, r.year, -1, 1, 3);
          });
          relation.inspirationTo.forEach(function (r) {
            drawArc(focus, r.year, relation.year, -1, 1, 3);
          });
          relation.otherInspiredBy.forEach(function (r) {
            drawArc(focus, relation.year, r.year, 1, 1, 3);
          });
          relation.otherInspirationTo.forEach(function (r) {
            drawArc(focus, r.year, relation.year, 1, 1, 3);
          });

          return {
            v: undefined
          };
        }
      };

      for (var i = 0; i < relations.length; i++) {
        var _ret = _loop(i);

        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
      }
    };

    // Fire event to start
    GUI_game.value = selection;
    drawSelection(selection);
  });

  var drawArc = function drawArc(g, yearA, yearB) {
    var invert = arguments.length <= 3 || arguments[3] === undefined ? -1.0 : arguments[3];
    var opacity = arguments.length <= 4 || arguments[4] === undefined ? 1 : arguments[4];
    var strokeWidth = arguments.length <= 5 || arguments[5] === undefined ? 1 : arguments[5];

    var args = arcYeartoYear(yearA, yearB, invert);
    args[0] *= width;args[1] *= height;args[2] *= height;args[3] *= height;
    g.arc.apply(g, _toConsumableArray(args)).stroke(0, 0, 0, opacity).strokeWidth(strokeWidth);
  };
});

var loadRoguelikeRelationsAll = function loadRoguelikeRelationsAll() {

  return (0, _util.getJSON)(server_url + "/roguelike/relations-all");
};

var arcYeartoYear = function arcYeartoYear(a, b) {
  var invert = arguments.length <= 2 || arguments[2] === undefined ? -1.0 : arguments[2];

  var x_a = fx(a, start_year, end_year);
  var x_b = fx(b, start_year, end_year);
  var x = (x_a + x_b) / 2;
  var y = 0.5 + 0.01 * invert;
  var rx = Math.abs(x_b - x_a) / 2;
  var ry = rx;
  var startAngle = 0;
  var endAngle = Math.PI * invert;
  return [x, y, rx, ry, startAngle, endAngle];
};

},{"./util":3,"bvg":1}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var promise = exports.promise = function promise(func) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return new Promise(function (resolve, reject) {
    var callback = function callback(error, data) {
      if (error) reject(error);else resolve(data);
    };
    args.push(callback);
    func.apply(func, args);
  });
};

var ratio = exports.ratio = function ratio(min, max, x) {

  return (x - min) / (max - min);
};

var getURL = exports.getURL = function getURL(url) {
  return new Promise(function (resolve, reject) {
    var req = new XMLHttpRequest();
    req.open('GET', url);
    req.onload = function () {
      if (req.status == 200) {
        resolve(req.response);
      } else {
        reject(new Error(req.statusText));
      }
    };
    req.onerror = function () {
      reject(new Error('Network Error'));
    };
    req.send();
  });
};

var getJSON = exports.getJSON = function getJSON(url) {
  return getURL(url).then(JSON.parse).catch(function (err) {
    console.log('getJSON failed to load', url);
    throw err;
  });
};

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnZnL2J2Zy5qcyIsInJvZ3VlbGlrZS1yZWxhdGlvbnMuanMiLCJ1dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0FBQztBQUNyQixPQUFHLENBQUMsTUFBTSxHQUFHLFlBQVk7QUFDdkIsVUFBSSxHQUFHLENBQUMsTUFBTSxJQUFJLEdBQUcsRUFBRTtBQUNyQixlQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3ZCLE1BQU07QUFDTCxjQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7T0FDbkM7S0FDRixDQUFDO0FBQ0YsT0FBRyxDQUFDLE9BQU8sR0FBRyxZQUFXO0FBQ3ZCLFlBQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO0tBQ3BDLENBQUM7QUFDRixPQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7R0FDWixDQUFDLENBQUM7Q0FDSixDQUFDOztBQUVLLElBQU0sT0FBTyxXQUFQLE9BQU8sR0FBRyxTQUFWLE9BQU8sQ0FBSSxHQUFHLEVBQUs7QUFDOUIsU0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLEVBQUU7QUFDdkQsV0FBTyxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMzQyxVQUFNLEdBQUcsQ0FBQztHQUNYLENBQUMsQ0FBQztDQUNKLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuQlZHID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy9cbi8qKiAjIEJWRyAtIEJpbmRhYmxlIFZlY3RvciBHcmFwaGljc1xuICAqICoqUmVhbC10aW1lIGRhdGEtZHJpdmVuIHZpc3VhbGlzYXRpb24gZm9yIHRoZSB3ZWIuKipcbiAgKlxuICAqICFbRXhhbXBsZV0oaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1NwYXhlL0JWRy5qcy9tYXN0ZXIvZGVtby9pbmRleC5naWYpXG4gICpcbiAgKiBMaXZlIGV4YW1wbGU6IGh0dHA6Ly9zcGF4ZS5naXRodWIuaW8vQlZHLmpzL1xuICAqXG4gICogKkJpbmRhYmxlIFZlY3RvciBHcmFwaGljcyogd2FzIGJvcm4gb3V0IG9mIGZydXN0cmF0aW9uIGZvciBsYWNrIG9mIGFcbiAgKiBtaWRkbGUgbGV2ZWwgU1ZHIGxpYnJhcnkuIFtEMy5qc10oaHR0cDovL2QzanMub3JnLykgYWJzdHJhY3RzIHRvbyBtdWNoXG4gICogbG9naWMsIGFuZCBbU1ZHLmpzXShodHRwOi8vc3ZnanMuY29tLykgcHJvdmlkZXMgb25seSBsb3ctbGV2ZWwgU1ZHIGRyYXdpbmcuXG4gICogQmluZGFibGUgVmVjdG9yIEdyYXBoaWNzIG9mZmVycyBTVkcgZWxlbWVudHMgdGhhdCBjaGFuZ2UgYXMgdGhlIGRhdGEgY2hhbmdlLFxuICAqIGFuZCBnaXZlcyB5b3UgdG9vbHMgdG8gY29udHJvbCB0aGVpciBsb29rLlxuICAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiogVGhlIGhlYXJ0IG9mIHRoaXMgbGlicmFyeSBpcyBhIHRyaW5pdHk6ICoqU1ZHICsgRGF0YSArIEJpbmRpbmcqKi4gVGhpc1xuICAqIGNvbm5lY3RzIHlvdXIgZGF0YSB0byB0aGUgU1ZHIGVsZW1lbnQgdGhyb3VnaCB0aGUgYmluZGluZyBmdW5jdGlvbiwgd2hpY2hcbiAgKiBjcmVhdGVzIGEgbGl2aW5nIGNvbm5lY3Rpb24gdGhhdCBjYW4gcmVhY3QgdG8gY2hhbmdlLiBCVkcgdXNlc1xuICAqIFtgT2JqZWN0Lm9ic2VydmUoKWBdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1vYmplY3Qtb2JzZXJ2ZSkgd2hpY2ggaXNcbiAgKiBhdmFpbGFibGUgb24gQ2hyb21lIDM2KywgT3BlcmEgMjcrIGFuZCBBbmRyb2lkIEJyb3dzZXIgMzcrLlxuICAqXG4gICogSWYgeW91IHdpc2ggdG8gdXNlIHRoaXMgZm9yIG9sZGVyIGJyb3dzZXJzLCB5b3UgY2FuIHBvbHlmaWxsIHdpdGhcbiAgKiBbYE1heEFydDI1MDEvT2JqZWN0Lm9ic2VydmVgXShodHRwczovL2dpdGh1Yi5jb20vTWF4QXJ0MjUwMS9vYmplY3Qtb2JzZXJ2ZSkuXG4gICpcbiAgKiAjIyBJbnN0YWxsYXRpb25cbiAgKlxuICAqICoqSW5zdGFsbCB1c2luZyBgbnBtYCoqOlxuICAqXG4gICogIDEuIEluc3RhbGwgTm9kZS5qczogaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9nZXR0aW5nLXN0YXJ0ZWQvaW5zdGFsbGluZy1ub2RlXG4gICogIDIuIEluIHlvdXIgd29ya2luZyBkaXJlY3Rvcnk6XG4gICpcbiAgKiAgICAgYGBgXG4gICogICAgIG5wbSBpbnN0YWxsIGJ2Z1xuICAqICAgICBgYGBcbiAgKlxuICAqICoqSW5zdGFsbCB2aWEgR2l0SHViKio6XG4gICpcbiAgKiAgMS4gQ2xvbmUgdGhpcyByZXBvOlxuICAqXG4gICogICAgIGBgYFxuICAqICAgICBnaXQgY2xvbmUgaHR0cHM6Ly9naXRodWIuY29tL1NwYXhlL0JWRy5qcy5naXRcbiAgKiAgICAgYGBgXG4gICpcbiAgKiAgMi4gQ29weSBgcmVxdWlyZS5qc2AgYW5kIGBidmcuanNgIGludG8geW91ciB3b3JraW5nIGRpcmVjdG9yeS5cbiAgKlxuICAqICoqVG8gaW5jbHVkZSBgQlZHLmpzYCBpbiB5b3VyIHdlYnBhZ2UqKjpcbiAgKlxuICAqICAxLiBJbiB5b3VyIEhUTUwgYDxoZWFkPmAsIGluY2x1ZGUgdGhpcyBzY3JpcHQgdXNpbmcgYHJlcXVpcmUuanNgOlxuICAqXG4gICogICAgIGBgYEhUTUxcbiAgKiAgICAgPHNjcmlwdCBzcmM9XCJwYXRoL3RvL3JlcXVpcmUuanNcIiBkYXRhLW1haW49XCJ5b3VyLXNjcmlwdC5qc1wiPjwvc2NyaXB0PlxuICAqICAgICBgYGBcbiAgKlxuICAqICAyLiBJbiBgeW91ci1zY3JpcHQuanNgLCBkZWZpbmUgeW91ciBvd24gY29kZSB3aXRoXG4gICpcbiAgKiAgICAgYGBgSmF2YXNjcmlwdFxuICAqICAgICByZXF1aXJlKFsncGF0aC90by9idmcuanMnXSwgZnVuY3Rpb24gKEJWRykge1xuICAqICAgICAgIC8vIHlvdXIgY29kZSBnb2VzIGhlcmUgLi4uXG4gICogICAgIH0pO1xuICAqICAgICBgYGBcbiAgKlxuICAqICMjIFF1aWNrc3RhcnRcbiAgKlxuICAqICFbUXVpY2tzdGFydCBFeGFtcGxlXShodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vU3BheGUvQlZHLmpzL21hc3Rlci9kZW1vLzAwMS1oZWxsby5naWYpXG4gICpcbiAgKiBIVE1MOlxuICAqXG4gICogYGBgSFRNTFxuICAqIDxkaXYgaWQ9XCJidmctY29udGFpbmVyXCI+PC9kaXY+XG4gICogYGBgXG4gICpcbiAgKiBDU1MgKE1ha2UgdGhlIGNvbnRhaW5lciBsYXJnZSBlbm91Z2gpOlxuICAqXG4gICogYGBgQ1NTXG4gICogaHRtbCwgYm9keSwgI2J2Zy1jb250YWluZXIge1xuICAqICAgaGVpZ2h0OiAxMDAlO1xuICAqICAgbWFyZ2luOiAwO1xuICAqIH1cbiAgKiBgYGBcbiAgKlxuICAqIEphdmFzY3JpcHQ6XG4gICpcbiAgKiBgYGBKYXZhc2NyaXB0XG4gICogLy8gQ3JlYXRlIGEgQlZHIGNvbnRhaW5lciBiYXNlZCBvbiBzZWxlY3RlZCBIVE1MIGVsZW1lbnRcbiAgKiB2YXIgYnZnID0gQlZHLmNyZWF0ZSgnI2J2Zy1jb250YWluZXInKTtcbiAgKiAvLyBDcmVhdGUgYSBCaW5kYWJsZSBjaXJjbGUsIGNvbG91ciBpdCBvcmFuZ2VcbiAgKiB2YXIgY2lyY2xlID0gYnZnLmVsbGlwc2UoMCwgMCwgMTUwLCAxNTApXG4gICogICAgICAgICAgICAgICAgIC5maWxsKDIyMCwgNjQsIDEyKTtcbiAgKiAvLyBDaGFuZ2UgaXRzIHNpemUgYmFzZWQgb24gbW91c2UgbW92ZW1lbnRcbiAgKiBidmcudGFnKCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICogICBjaXJjbGUuZGF0YSh7XG4gICogICAgIHJ4OiBldmVudC5jbGllbnRYLFxuICAqICAgICByeTogZXZlbnQuY2xpZW50WVxuICAqICAgfSk7XG4gICogfSk7XG4gICogYGBgXG4gICovXG5cbi8qLSBEZWVwIE9iamVjdC5vYnNlcnZlKCkgKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJWRztcbmZ1bmN0aW9uIG9ic2VydmUob2JqLCBjYWxsYmFjaykge1xuXG4gIC8vIEluY2x1ZGUgaHR0cHM6Ly9naXRodWIuY29tL01heEFydDI1MDEvb2JqZWN0LW9ic2VydmUgaWYgeW91IHdpc2ggdG8gd29ya1xuICAvLyB3aXRoIHBvbHlmaWxsIG9uIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBPYmplY3Qub2JzZXJ2ZSgpXG4gIE9iamVjdC5vYnNlcnZlKG9iaiwgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICBjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuXG4gICAgICAvLyBCaW5kIGNoaWxkIHByb3BlcnR5IGlmIGl0IGlzIGFuIG9iamVjdCBmb3IgZGVlcCBvYnNlcnZpbmdcbiAgICAgIGlmIChvYmpbY2hhbmdlLm5hbWVdIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIG9ic2VydmUob2JqW2NoYW5nZS5uYW1lXSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVHJpZ2dlciB1c2VyIGNhbGxiYWNrXG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCBjaGFuZ2VzKTtcbiAgfSk7XG5cbiAgLy8gSW1tZWRpYXRlbHkgZmlyZSBvYnNlcnZlIHRvIGluaXRpYXRlIGRlZXAgb2JzZXJ2aW5nXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKG9ialtrZXldIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBvYnNlcnZlKG9ialtrZXldLCBjYWxsYmFjayk7XG4gICAgfVxuICB9KTtcbn1cblxuLyotIGBCVkcodGFnLCBkYXRhLCBiaW5kaW5nKWBcbiAgKiBUaGUgdHJpbml0eSBvZiB0aGlzIGxpYnJhcnk6IFNWRyArIERhdGEgKyBCaW5kaW5nIEZ1bmN0aW9uLlxuICAqXG4gICogUmV0dXJuIHRoZSBCVkcgb2JqZWN0IGNyZWF0ZWQuXG4gICpcbiAgKiAgLSBgdGFnYCAgICA6IEVpdGhlciBhIGBTdHJpbmdgIGZvciB0aGUgU1ZHIGB0YWdOYW1lYCBvciBhbnkgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQpXG4gICogIC0gYGRhdGFgICAgOiBPYmplY3Qgd2l0aCBhcmJpdHJhcnkgZGF0YSB0byB5b3VyIGRlc2lyZVxuICAqICAtIGBiaW5kaW5nYDogKG9wdGlvbmFsKSBCaW5kaW5nIGZ1bmN0aW9uIHRoYXQgc2V0cyB0aGUgdGFnIGF0dHJpYnV0ZXNcbiAgKi9cbmZ1bmN0aW9uIEJWRyh0YWcsIGRhdGEsIGJpbmRpbmcpIHtcbiAgdmFyIGJ2ZyA9IHRoaXM7XG4gIHRhZyA9IHRhZyBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgPyB0YWcgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdGFnKTtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGJpbmRpbmcgPSBiaW5kaW5nIHx8IGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHRhZy5zZXRBdHRyaWJ1dGUocHJvcCwgZGF0YVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIE9ic2VydmUgZGF0YSBvYmplY3QgYW5kIGFwcGx5IGJpbmRpbmcgcmlnaHQgYXdheVxuICBvYnNlcnZlKGRhdGEsIGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgYmluZGluZyh0YWcsIGRhdGEpO1xuICB9KTtcbiAgYmluZGluZyh0YWcsIGRhdGEpO1xuXG4gIC8vIElEIGZ1bmN0aW9uIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ29yZG9uYnJhbmRlci8yMjMwMzE3XG4gIHRhZy5zZXRBdHRyaWJ1dGUoJ2lkJywgJ0JWR18nICsgdGFnLnRhZ05hbWUgKyAnXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgNykpO1xuICB0aGlzLl90YWcgPSB0YWc7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB0aGlzLl9iaW5kaW5nID0gYmluZGluZztcblxuICAvLyBGdW5jdGlvbmFsIGNpcmN1bGFyIHJlZmVyZW5jZVxuICB0aGlzLl90YWcuX2dldEJWRyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYnZnO1xuICB9O1xuXG4gIGlmIChbJ3N2ZycsICdnJywgJ2EnXS5pbmRleE9mKHRhZy50YWdOYW1lKSA8IDApIHtcbiAgICBpZiAoIWRhdGEuc3Ryb2tlKSB0aGlzLnN0cm9rZSgxNzUpO1xuICAgIGlmICghZGF0YS5zdHJva2VXaWR0aCkgdGhpcy5zdHJva2VXaWR0aCgwLjUpO1xuICAgIGlmICghZGF0YS5maWxsKSB0aGlzLm5vRmlsbCgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogIyMgVGhlIEJWRyBDb250YWluZXJcbiAgKiBUaGUgcmVzdCBvZiB0aGUgZG9jdW1lbnRhdGlvbiB3aWxsIGFzc3VtZSBgYnZnYCBhcyBvdXIgQlZHIGNvbnRhaW5lclxuICAqIGNyZWF0ZWQgYnkgdGhlIGV4YW1wbGUgYmVsb3cuXG4gICovXG5cbi8qKiAjIyMgYEJWRy5jcmVhdGUoaHRtbEVsZW1lbnQpYFxuICAqIENyZWF0ZSBhIEJWRyBjb250YWluZXIgaW5zaWRlIGBodG1sRWxlbWVudGAuXG4gICpcbiAgKiBSZXR1cm4gdGhlIEJWRyBjb250YWluZXIgb2JqZWN0LlxuICAqXG4gICogIC0gYGh0bWxFbGVtZW50YCAgOiBFaXRoZXIgYSBbQ1NTIFNlbGVjdG9yXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9DU1MvR2V0dGluZ19TdGFydGVkL1NlbGVjdG9ycylcbiAgKiAgICAgICAgICAgICAgICAgICAgIG9yIGFueSBbSFRNTEVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudCkuXG4gICpcbiAgKiBgYGBKYXZhc2NyaXB0XG4gICogLy8gQ3JlYXRlIGEgbmV3IEJWRyBjb250YWluZXIgYW5kIGFwcGVuZCBpdCB0byBhbiBleGlzdGluZyBIVE1MIGVsZW1lbnQuXG4gICogdmFyIGJ2ZyA9IEJWRy5jcmVhdGUoJyNidmctY29udGFpbmVyJyk7XG4gICogYGBgXG4gICovXG52YXIgY3JlYXRlID0gZXhwb3J0cy5jcmVhdGUgPSBCVkcuY3JlYXRlID0gZnVuY3Rpb24gKGh0bWxFbGVtZW50LCB4RGltZW5zaW9uLCB5RGltZW5zaW9uKSB7XG4gIGlmICh0eXBlb2YgaHRtbEVsZW1lbnQgPT09ICdzdHJpbmcnKSBodG1sRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaHRtbEVsZW1lbnQpO1xuICBpZiAoIShodG1sRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignaHRtbEVsZW1lbnQgKCcgKyBodG1sRWxlbWVudCArICcpIHdhcyBub3QgZm91bmQuJyk7XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgJ3htbG5zOnhsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgIHZlcnNpb246IDEuMSxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnXG4gIH07XG4gIHlEaW1lbnNpb24gPSB5RGltZW5zaW9uIHx8IHhEaW1lbnNpb247XG4gIGlmICh4RGltZW5zaW9uKSB7XG4gICAgZGF0YS52aWV3Qm94ID0gWzAsIDAsIHhEaW1lbnNpb24sIHlEaW1lbnNpb25dLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBidmcgPSBuZXcgQlZHKCdzdmcnLCBkYXRhKTtcbiAgaHRtbEVsZW1lbnQuYXBwZW5kQ2hpbGQoYnZnLnRhZygpKTtcbiAgcmV0dXJuIGJ2Zztcbn07XG5cbi8qKiAjIyBCVkcgRWxlbWVudHNcbiAgKiBBbGwgQlZHIG9iamVjdHMsIGluY2x1ZGluZyB0aGUgY29udGFpbmVyLCBoYXZlIGFjY2VzcyB0byBkcmF3aW5nIGZ1bmN0aW9uc1xuICAqIGFuZCByZXR1cm4gcmVmZXJlbmNlIHRvIHRoZSBuZXcgc2hhcGUsIHdoaWNoIGlzIGFsc28gYSBCVkcuXG4gICpcbiAgKiBgYGBKYXZhc2NyaXB0XG4gICogLy8gQ3JlYXRlIGEgcmVjdGFuZ2xlIGF0ICgwLCAwKSB3aXRoIGRpbWVuc2lvbnMgMTAweDEwMCBweCBhbmQgYWRkIGl0IHRvIGJ2Z1xuICAqIHZhciByZWN0ID0gYnZnLnJlY3QoMCwgMCwgMTAwLCAxMDApO1xuICAqIGBgYFxuICAqXG4gICogVGhlIEJWRyBtb2R1bGUgYWxzbyBoYXMgZHJhd2luZyBmdW5jdGlvbnMsIHdoaWNoIHJldHVybiB0aGUgQlZHIG9iamVjdDpcbiAgKlxuICAqIGBgYEphdmFzY3JpcHRcbiAgKiAvLyBDcmVhdGUgYSByZWN0YW5nbGUgYXQgKDAsIDApIHdpdGggZGltZW5zaW9ucyAxMDB4MTAwIHB4XG4gICogLy8gTm90ZSBpdCB1c2VzIHRoZSBCVkcgbW9kdWxlIGRpcmVjdGx5IHRvIGNyZWF0ZSB0aGUgcmVjdGFuZ2xlLlxuICAqIHZhciByZWN0ID0gQlZHLnJlY3QoMCwgMCwgMTAwLCAxMDApO1xuICAqIC8vIEFkZCB0aGUgcmVjdGFuZ2xlIHRvIGFuIGV4aXN0aW5nIEJWRyBjb250YWluZXJcbiAgKiBidmcuYXBwZW5kKHJlY3QpO1xuICAqIGBgYFxuICAqXG4gICogRHJhd2luZyBmdW5jdGlvbnMgY2FuIGJlIGNhbGxlZCBpbiBhIG51bWJlciBvZiB3YXlzLiBUYWtlIGBidmcucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KWBcbiAgKiBhcyBhbiBleGFtcGxlIGJlbG93LiBTb21ldGltZXMgaXQgaXMgZWFzaWVyIHRvIHVzZSBvbmUgb3ZlciBhbm90aGVyIHN0eWxlLlxuICAqXG4gICogYGBgSmF2YXNjcmlwdFxuICAqIGJ2Zy5yZWN0KDAsIDEwLCAzMCwgNzApOyAgICAgIC8vIEFyZ3VtZW50cyBzdHlsZVxuICAqIGJ2Zy5yZWN0KHsgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdCBzdHlsZVxuICAqICAgeDogMCxcbiAgKiAgIHk6IDEwLCAgICAgICAgICAgICAgICAgICAgICAvLyBOYW1lIG9mIHRoZSBvYmplY3QgcHJvcGVydGllcyBtdXN0IG1hdGNoXG4gICogICB3aWR0aDogMzAsICAgICAgICAgICAgICAgICAgLy8gbmFtZXMgb2YgdGhlIGFyZ3VtZW50cyBpbiB0aGUgZnVuY3Rpb25zLFxuICAqICAgaGVpZ2h0OiA3MCAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgb3JkZXIgY2FuIGJlIGFueS5cbiAgKiB9KTtcbiAgKiBgYGBcbiAgKi9cbnZhciBjcmVhdGlvbkZ1bmN0aW9ucyA9IHtcbiAgc3ZnOiBmdW5jdGlvbiBzdmcoeGxpbmssIHZlcnNpb24sIHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gbmV3IEJWRygnc3ZnJywgeGxpbmsuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyB4bGluayA6IHtcbiAgICAgICd4bWxuczp4bGluayc6IHhsaW5rLFxuICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqICMjIyBgYnZnLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodClgXG4gICAgKiBDcmVhdGUgYSByZWN0YW5nbGUgYXQgcG9zaXRpb24gYCh4LCB5KWAgYXQgYHdpZHRoYCB4IGBoZWlnaHRgIGluIHNpemUuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogdmFyIHJlY3QgPSBidmcucmVjdCgxMDAsIDEwMCwgMzAwLCAxNTApO1xuICAgICogYGBgXG4gICAgKi9cbiAgcmVjdDogZnVuY3Rpb24gcmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ3JlY3QnLCB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8geCA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KTtcbiAgfSxcblxuICAvKiogIyMjIGBidmcuY2lyY2xlKGN4LCBjeSwgcilgXG4gICAgKiBDcmVhdGUgYSBjaXJjbGUgY2VudHJlZCBvbiBgKGN4LCBjeSlgIHdpdGggcmFkaXVzIGByYC5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiB2YXIgY2lyY2xlID0gYnZnLmVsbGlwc2UoMTAwLCAxMDAsIDUwKTtcbiAgICAqIGBgYFxuICAgICovXG4gIGNpcmNsZTogZnVuY3Rpb24gY2lyY2xlKHgsIHksIHIpIHtcbiAgICByZXR1cm4gbmV3IEJWRygnY2lyY2xlJywgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHggOiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHI6IHJcbiAgICB9LCBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdjeCcsIGRhdGEueCk7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdjeScsIGRhdGEueSk7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdyJywgZGF0YS5yKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKiogIyMjIGBidmcuZWxsaXBzZShjeCwgY3ksIHJ4LCByeSlgXG4gICAgKiBDcmVhdGUgYSBlbGxpcHNlIGNlbnRyZWQgb24gYChjeCwgY3kpYCB3aXRoIHJhZGlpIGByeGAgYW5kIGByeWAuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogdmFyIGVsbGlwc2UgPSBidmcuZWxsaXBzZSgxMDAsIDEwMCwgMjAwLCAxODApO1xuICAgICogYGBgXG4gICAgKi9cbiAgZWxsaXBzZTogZnVuY3Rpb24gZWxsaXBzZSh4LCB5LCByeCwgcnkpIHtcbiAgICByZXR1cm4gbmV3IEJWRygnZWxsaXBzZScsIHguY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyB4IDoge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICByeDogcngsXG4gICAgICByeTogcnlcbiAgICB9LCBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdjeCcsIGRhdGEueCk7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdjeScsIGRhdGEueSk7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdyeCcsIGRhdGEucngpO1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgncnknLCBkYXRhLnJ5KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKiogIyMjIGBidmcubGluZSh4MSwgeTEsIHgyLCB5MilgXG4gICAgKiBDcmVhdGUgYSBsaW5lIGZyb20gYCh4MSwgeTEpYCB0byBgKHgyLCB5MilgLlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIHZhciBsaW5lID0gYnZnLmxpbmUoMTAwLCAxMDAsIDIwMCwgMzAwKTtcbiAgICAqIGBgYFxuICAgICovXG4gIGxpbmU6IGZ1bmN0aW9uIGxpbmUoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gbmV3IEJWRygnbGluZScsIHgxLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8geDEgOiB7XG4gICAgICB4MTogeDEsXG4gICAgICB5MTogeTEsXG4gICAgICB4MjogeDIsXG4gICAgICB5MjogeTJcbiAgICB9KTtcbiAgfSxcbiAgLyoqICMjIyBgYnZnLnBvbHlsaW5lKFtbeDEsIHkxXSwgW3gyLCB5Ml0sIC4uLl0pYFxuICAgICogQ3JlYXRlIGEgc2VyaWVzIG9mIGxpbmVzIGZyb20gcG9pbnQgdG8gcG9pbnQuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogdmFyIHBvbHlsaW5lID0gYnZnLnBvbHlsaW5lKFtbMTAwLCAyMDBdLCBbMjAwLCAzMDBdLCBbNDAwLCA4MDBdXSk7XG4gICAgKiBgYGBcbiAgICAqL1xuICBwb2x5bGluZTogZnVuY3Rpb24gcG9seWxpbmUocG9pbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ3BvbHlsaW5lJywgcG9pbnRzLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8gcG9pbnRzIDoge1xuICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICB9LCBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdwb2ludHMnLCBkYXRhLnBvaW50cy5qb2luKCcgJykpO1xuICAgIH0pO1xuICB9LFxuICAvKiogIyMjIGBidmcucG9seWdvbihbW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi5dKWBcbiAgICAqIENyZWF0ZSBhIGNsb3NlZCBwb2x5Z29uIGZyb20gcG9pbnQgdG8gcG9pbnQuIFRoZSBsYXN0IHBvaW50IHdpbGwgYmVcbiAgICAqIGNvbm5lY3RlZCBiYWNrIHRvIHRoZSBmaXJzdCBwb2ludC5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiB2YXIgcG9seWdvbiA9IGJ2Zy5wb2x5Z29uKFtbMTAwLCAyMDBdLCBbMjAwLCAzMDBdLCBbNDAwLCA4MDBdXSk7XG4gICAgKiBgYGBcbiAgICAqL1xuICBwb2x5Z29uOiBmdW5jdGlvbiBwb2x5Z29uKHBvaW50cykge1xuICAgIHJldHVybiBuZXcgQlZHKCdwb2x5Z29uJywgcG9pbnRzLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8gcG9pbnRzIDoge1xuICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICB9LCBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdwb2ludHMnLCBkYXRhLnBvaW50cy5qb2luKCcgJykpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKiAjIyBHcm91cGluZyBFbGVtZW50c1xuICAgICogIyMjIGBidmcuZ3JvdXAoW3RyYW5zZm9ybV0pYFxuICAgICpcbiAgICAqIENyZWF0ZSBhIGdyb3VwIHRvIGNvbnRhaW4gQlZHIG9iamVjdHMuIEl0IGFjdHMgbGlrZSBhIEJWRyBjb250YWluZXIgd2l0aFxuICAgICogYW4gb3B0aW9uYWwgYHRyYW5zZm9ybWAgYXR0cmlidXRlLlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIC8vIENyZWF0ZSBhIG5ldyBncm91cCBhbmQgZmlsbCBpdCB3aXRoIGRhc2hlcy5cbiAgICAqIHZhciBkYXNoZXMgPSBidmcuZ3JvdXAoKTtcbiAgICAqIGZvciAoaW50IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgKiAgIGRhaHNlcy5yZWN0KDEwLCAxMCArIGkgKiAzMCwgNTAsIDIwKTtcbiAgICAqIH1cbiAgICAqIGBgYFxuICAgICovXG4gIGdyb3VwOiBmdW5jdGlvbiBncm91cCh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gbmV3IEJWRygnZycsIHRyYW5zZm9ybS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHRyYW5zZm9ybSA6IHtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqICMjIEh5cGVybGlua3NcbiAgICAqICMjIyBgYnZnLmh5cGVybGluayh1cmwpYFxuICAgICpcbiAgICAqIENyZWF0ZSBhIGh5cGVybGluayBCVkcgdG8gdGFyZ2V0IFVSTCBgdXJsYC4gSXQgZG9lcyBub3QgaGF2ZSBhbnkgZGlzcGxheVxuICAgICogZWxlbWVudHMuIE1ha2Ugc3VyZSB0byBhcHBlbmQgZWxlbWVudHMgdG8gaXQuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogLy8gQ2xpY2tpbmcgb24gdGhpcyBlbGVtZW50IHdpbGwgYnJpbmcgdGhlbSB0byB0aGUgR2l0aHViIHBhZ2VcbiAgICAqIHZhciBnaXRodWJMaW5rID0gYnZnLmh5cGVybGluaygnaHR0cHM6Ly9naXRodWIuY29tL3NwYXhlL0JWRy5qcycpO1xuICAgICogLy8gTWFrZSBhIGJ1dHRvbiBhbmQgYXR0YWNrIGl0IHRvIHRoZSBsaW5rXG4gICAgKiBnaXRodWJMaW5rLmVsbGlwc2UoMjAwLCAyMDAsIDUwLCA1MCk7XG4gICAgKiBgYGBcbiAgICAqL1xuICBoeXBlcmxpbms6IGZ1bmN0aW9uIGh5cGVybGluayh1cmwpIHtcbiAgICByZXR1cm4gbmV3IEJWRygnYScsIHVybC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHVybCA6IHtcbiAgICAgICd4bWxuczpocmVmJzogdXJsXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqICMjIE90aGVyIEdlb21ldHJ5XG4gICAgKiAjIyMgYGJ2Zy50cmlhbmdsZShjeCwgY3ksIHIpYFxuICAgICogQ3JlYXRlIGEgcmVndWxhciB0cmlhbmdsZSBjZW50cmVkIG9uIGAoY3gsIGN5KWAgd2l0aCB2ZXJ0aWNlcyBgcmAgZGlzdGFuY2VcbiAgICAqIGF3YXkuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogdmFyIHRyaWFuZ2xlID0gYnZnLnRyaWFuZ2xlKDUwLCA1MCwgMTApO1xuICAgICogYGBgXG4gICAgKi9cbiAgdHJpYW5nbGU6IGZ1bmN0aW9uIHRyaWFuZ2xlKHgsIHksIHIpIHtcbiAgICByZXR1cm4gbmV3IEJWRygncG9seWdvbicsIHguY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyB4IDoge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICByOiByXG4gICAgfSwgZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgICAgdmFyIHBvaW50cyA9IFtbZGF0YS54LCBkYXRhLnkgLSBkYXRhLnJdLCBbZGF0YS54IC0gZGF0YS5yIC8gMiAqIE1hdGguc3FydCgzKSwgZGF0YS55ICsgZGF0YS5yIC8gMl0sIFtkYXRhLnggKyBkYXRhLnIgLyAyICogTWF0aC5zcXJ0KDMpLCBkYXRhLnkgKyBkYXRhLnIgLyAyXV07XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdwb2ludHMnLCBwb2ludHMuam9pbignICcpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKiogIyMjIGBidmcuYXJjKGN4LCBjeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSlgXG4gICAgKiBDcmVhdGUgYW4gYXJjIGNlbnRyZWQgb24gYChjeCwgY3kpYCB3aXRoIHJhZGl1cyBgcnhgIGFuZCBgcnlgLCBzdGFydGluZ1xuICAgICogZnJvbSBgc3RhcnRBbmdsZWAgYW50aS1jbG9ja3dpc2UgdG8gYGVuZEFuZ2xlYCwgd2hlcmUgMCBpcyB0aGUgcG9zaXRpdmVcbiAgICAqIHgtYXhpcy5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiB2YXIgYXJjID0gYnZnLmFyYyg1MCwgNTAsIDUwLCAxMDAsIDAsIE1hdGguUEkpO1xuICAgICogYGBgXG4gICAgKi9cbiAgYXJjOiBmdW5jdGlvbiBhcmMoeCwgeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICAgIHJldHVybiBuZXcgQlZHKCdwYXRoJywgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHggOiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHJ4OiByeCxcbiAgICAgIHJ5OiByeSxcbiAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZTogZW5kQW5nbGVcbiAgICB9LCBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgICB2YXIgcDEgPSBnZXRQb2ludE9uRWxsaXBzZShkYXRhLngsIGRhdGEueSwgZGF0YS5yeCwgZGF0YS5yeSwgZGF0YS5zdGFydEFuZ2xlKTtcbiAgICAgIHZhciBwMiA9IGdldFBvaW50T25FbGxpcHNlKGRhdGEueCwgZGF0YS55LCBkYXRhLnJ4LCBkYXRhLnJ5LCBkYXRhLmVuZEFuZ2xlKTtcbiAgICAgIHZhciBsYXJnZUFyYyA9IGRhdGEuZW5kQW5nbGUgLSBkYXRhLnN0YXJ0QW5nbGUgPiBNYXRoLlBJID8gMSA6IDA7XG4gICAgICB2YXIgc3dlZXBBcmMgPSBkYXRhLmVuZEFuZ2xlID4gZGF0YS5zdGFydEFuZ2xlID8gMSA6IDA7XG4gICAgICB2YXIgZCA9IFtbJ00nLCBwMS54LCBwMS55XSwgWydBJywgZGF0YS5yeCwgZGF0YS5yeSwgMCwgbGFyZ2VBcmMsIHN3ZWVwQXJjLCBwMi54LCBwMi55XV07XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdkJywgZC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguam9pbignICcpO1xuICAgICAgfSkuam9pbignICcpKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0UG9pbnRPbkVsbGlwc2UoeCwgeSwgcngsIHJ5LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJ4ICogTWF0aC5jb3MoYW5nbGUpICsgeCxcbiAgICAgICAgICB5OiByeSAqIE1hdGguc2luKGFuZ2xlKSArIHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKiogIyMjIGBidmcudGV4dCh0ZXh0LCB4LCB5KWBcbiAgICAqIENyZWF0ZSBhIHN0cmluZyBvZiBgdGV4dGAgdGV4dCBhdCBsb2NhdGlvbiBgKHgsIHkpYC5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiB2YXIgdGV4dCA9IGJ2Zy50ZXh0KCdNcnJhYSEnLCAyMCwgMTApO1xuICAgICogYGBgXG4gICAgKi9cbiAgdGV4dDogZnVuY3Rpb24gdGV4dChfdGV4dCwgeCwgeSkge1xuICAgIHJldHVybiBuZXcgQlZHKCd0ZXh0JywgX3RleHQuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyBfdGV4dCA6IHtcbiAgICAgIHRleHQ6IF90ZXh0LFxuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9LCBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgICB0YWcuaW5uZXJIVE1MID0gZGF0YS50ZXh0O1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgneCcsIGRhdGEueCk7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCd5JywgZGF0YS55KTtcbiAgICB9KS5maWxsKCdyZ2JhKDE3NSwgMTc1LCAxNzUsIDEpJykuc3Ryb2tlKCdyZ2JhKDAsIDAsIDAsIDApJyk7XG4gIH1cbn07XG5cbk9iamVjdC5rZXlzKGNyZWF0aW9uRnVuY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIEJWR1tmXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlYXRpb25GdW5jdGlvbnNbZl0uYXBwbHkoQlZHLCBhcmd1bWVudHMpO1xuICB9O1xuICBCVkcucHJvdG90eXBlW2ZdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBidmcgPSBjcmVhdGlvbkZ1bmN0aW9uc1tmXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuYXBwZW5kKGJ2Zyk7XG4gICAgcmV0dXJuIGJ2ZztcbiAgfTtcbn0pO1xuXG4vKiogIyMgVGhlIEJWRyBPYmplY3RcbiAgKiBCVkdzIGFyZSBTVkdzIHdpdGggZXh0cmEgc3VwZXJwb3dlcnMuXG4gICovXG5cbi8qKiAjIyMgYGJ2Zy5maW5kKHNlbGVjdG9yKWBcbiAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgQlZHcyBtYXRjaGluZyBgc2VsZWN0b3JgIGluc2lkZSBCVkcuIGBzZWxlY3RvcmAgaXNcbiAgKiBkZWZpbmVkIGFzIFtDU1MgU2VsZWN0b3JzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9DU1MvR2V0dGluZ19zdGFydGVkL1NlbGVjdG9ycykuXG4gICovXG5CVkcucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX3RhZy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHZhciBidmdzID0gW107XG4gICAgW10uc2xpY2UuY2FsbChyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIGJ2Z3MucHVzaChyLl9nZXRCVkcoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ2Z3M7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcblxuLyoqICMjIyBgYnZnLmFwcGVuZChidmcpYFxuICAqIEluc2VydCBgY2hpbGRfYnZnYCBpbnNpZGUgYGJ2Z2AuIFRoaXMgaXMgdXNlZnVsIHRvIGFkZCBlbGVtZW50cyBpbnNpZGUgYVxuICAqIGBCVkcuZ3JvdXAoKWAuXG4gICovXG5CVkcucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChjaGlsZF9idmcpIHtcbiAgdGhpcy5fdGFnLmFwcGVuZENoaWxkKGNoaWxkX2J2Zy5fdGFnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogIyMjIGBidmcucmVtb3ZlKClgXG4gICogUmVtb3ZlIGl0c2VsZiBmcm9tIGl0cyBwYXJlbnQuIFJldHVybiBzZWxmIHJlZmVyZW5jZS5cbiAgKi9cbkJWRy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQoKTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5fdGFnLnJlbW92ZUNoaWxkKHRoaXMuX3RhZyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogIyMjIGBidmcucGFyZW50KClgXG4gICogUmV0dXJuIHRoZSBwYXJlbnQgQlZHLiBJZiB0aGVyZSBpcyBubyBwYXJlbnQgKHN1Y2ggaXMgdGhlIGNhc2UgZm9yIHRoZSBCVkdcbiAgKiBjb250YWluZXIgaXRzZWxmKSwgcmV0dXJuIG51bGwuXG4gICovXG5CVkcucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3RhZy5wYXJlbnROb2RlICYmIHR5cGVvZiB0aGlzLl90YWcucGFyZW50Tm9kZS5fZ2V0QlZHID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5fdGFnLnBhcmVudE5vZGUuX2dldEJWRygpO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKiAjIyMgYGJ2Zy5jaGlsZHJlbigpYFxuICAqIFJldHVybiBhIGxpc3Qgb2YgQlZHIGVsZW1lbnRzIGluc2lkZSBgYnZnYC5cbiAgKi9cbkJWRy5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90YWcuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fdGFnLmNoaWxkTm9kZXNbaV0uX2dldEJWRyA9PT0gJ2Z1bmN0aW9uJykgb3V0cHV0LnB1c2godGhpcy5fdGFnLmNoaWxkTm9kZXNbaV0uX2dldEJWRygpKTtcbiAgfXJldHVybiBvdXRwdXQ7XG59O1xuXG4vKiogIyMjIGBidmcudGFnKClgXG4gICogUmV0dXJuIHRodyBCVkcgZ3JhcGhpY2FsIGNvbnRlbnQsIGEgU1ZHLlxuICAqL1xuQlZHLnByb3RvdHlwZS50YWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl90YWc7XG59O1xuXG4vKiogIyMjIGBidmcuZGF0YSgpYFxuICogR2V0L3NldCB0aGUgYGRhdGFgIG9iamVjdCBpbiBhIEJWRy4gVGhlcmUgYXJlIGZvdXIgd2F5cyB0byB1c2UgdGhpc1xuICogZnVuY3Rpb24uXG4gKlxuICogIC0gYGJ2Zy5kYXRhKClgOiBSZXR1cm4gYGRhdGFgIGJvdW5kIHRvIHRoZSBCVkcuXG4gKiAgLSBgYnZnLmRhdGEobmV3RGF0YSlgOiBVcGRhdGUgYGRhdGFgIHdpdGggYG5ld0RhdGFgIG9iamVjdC5cbiAqICAtIGBidmcuZGF0YShwcm9wZXJ0eSlgOiBSZXR1cm4gYGRhdGFbcHJvcGVydHldYCBmcm9tIHRoZSBCVkcuXG4gKiAgLSBgYnZnLmRhdGEocHJvcGVydHksIG5ld1ZhbHVlKWA6IFVwZGF0ZSBgcHJvcGVydHlgIHdpdGggYG5ld1ZhbHVlYC5cbiAqXG4gKiBSZXR1cm4gYGJ2Z2Agb2JqZWN0IHJlZmVyZW5jZS5cbiAqL1xuQlZHLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzWzBdLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgdGhpcy5kYXRhKGssIGFyZ3VtZW50c1swXVtrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YVthcmd1bWVudHNbMF1dO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5fZGF0YVthcmd1bWVudHNbMF1dID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHRoaXMsICdkYXRhKCkgcmVjZWl2ZWQgbW9yZSB0aGFuIDIgYXJndW1lbnRzLicpO1xuICB9XG59O1xuXG4vKiogIyMjIGBidmcuYXR0cigpYFxuICAqIEdldC9zZXQgYXR0cmlidXRlcyBvbiBhIEJWRy5cbiAgKlxuICAqICAtIGBidmcuYXR0cihhdHRyKWA6IFJldHVybiBhdHRyaWJ1dGUgdmFsdWUuXG4gICogIC0gYGJ2Zy5hdHRyKGF0dHIsIHZhbHVlKWA6IFVwZGF0ZSBgYXR0cmAgd2l0aCBgdmFsdWVgLlxuICAqL1xuQlZHLnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24gKGF0dHIsIHZhbHVlKSB7XG4gIGlmICghYXR0cikgdGhyb3cgbmV3IEVycm9yKCdhdHRyIG11c3QgYmUgZGVmaW5lZCcpO1xuICBpZiAoIXZhbHVlKSByZXR1cm4gdGhpcy5fdGFnLmdldEF0dHJpYnV0ZShhdHRyKTtlbHNlIHRoaXMuX3RhZy5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiAjIyMgYGJ2Zy5maWxsKClgXG4gICogR2V0L3NldCB0aGUgZmlsbGluZyBjb2xvdXIuXG4gICpcbiAgKiAgLSBgYnZnLmZpbGwoKWA6IFJldHVybiBgZmlsbGAgY29sb3VyIGFzIFtyLCBnLCBiLCBhXSwgb3IgYCcnYCAoZW1wdHlcbiAgKiAgICAgICAgICAgICAgICAgIHN0cmlnKSBpZiBmaWxsIGlzIG5vdCBzcGVjaWZpZWQgb24gdGhlIG9iamVjdC5cbiAgKiAgLSBgYnZnLmZpbGwocmdiKWA6IFNldCBgZmlsbGAgd2l0aCBhIGdyZXlzY2FsZSBjb2xvdXIgd2l0aCBlcXVhbFxuICAqICAgIHZhbHVlcyBgKHJnYiwgcmdiLCByZ2IpYC5cbiAgKiAgLSBgYnZnLmZpbGwociwgZywgYiwgW2FdKWA6IFNldCBgZmlsbGAgd2l0aCBgKHIsIGcsIGIsIGEpYC4gSWYgYGFgXG4gICogICAgaXMgb21pdHRlZCwgaXQgZGVmYXVsdHMgdG8gYDFgLlxuICAqXG4gICogYHJgLCBgZ2AsIGBiYCBzaG91bGQgYmUgaW4gdGhlIHJhbmdlIG9mIDAtMjU1IGluY2x1c2l2ZS5cbiAgKi9cbkJWRy5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgZiA9IHRoaXMuYXR0cignZmlsbCcpO1xuICAgIGlmIChmKSByZXR1cm4gQlZHLmV4dHJhY3ROdW1iZXJBcnJheShmKTtcbiAgICByZXR1cm4gJyc7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJykgcmV0dXJuIHRoaXMuYXR0cignZmlsbCcsIGFyZ3VtZW50c1swXSk7ZWxzZSByZXR1cm4gdGhpcy5hdHRyKCdmaWxsJywgQlZHLnJnYmEoYXJndW1lbnRzWzBdKSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignZmlsbCcsIEJWRy5yZ2JhLmFwcGx5KEJWRywgYXJndW1lbnRzKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IodGhpcywgJ2ZpbGwoKSByZWNlaXZlZCBtb3JlIHRoYW4gMSBhcmd1bWVudC4nKTtcbiAgfVxufTtcblxuLyoqICMjIyBgYnZnLm5vRmlsbCgpYFxuICAqIFJlbW92ZSBCVkcgb2JqZWN0J3MgY29sb3VyIGZpbGxpbmcgY29tcGxldGVseS5cbiAgKi9cbkJWRy5wcm90b3R5cGUubm9GaWxsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5maWxsKCdyZ2JhKDAsIDAsIDAsIDApJyk7XG59O1xuXG4vKiogIyMjIGBidmcuc3Ryb2tlKClgXG4gICogR2V0L3NldCB0aGUgb3V0bGluZSBjb2xvdXIuXG4gICpcbiAgKiAgLSBgYnZnLnN0cm9rZSgpYDogUmV0dXJuIGBzdHJva2VgIGNvbG91ciBhcyBbciwgZywgYiwgYV0uIElmIGBzdHJva2VgIGlzXG4gICogICAgbm90IHNwZWNpZmllZCwgcmV0dXJuIGAnJ2AgKGVtcHR5IHN0cmluZykuXG4gICogIC0gYGJ2Zy5zdHJva2UocmdiKWA6IFNldCBgc3Ryb2tlYCB3aXRoIGEgZ3JleXNjYWxlIGNvbG91ciB3aXRoIGVxdWFsXG4gICogICAgdmFsdWVzIGAocmdiLCByZ2IsIHJnYilgLlxuICAqICAtIGBidmcuc3Ryb2tlKHIsIGcsIGIsIFthXSlgOiBTZXQgYHN0cm9rZWAgd2l0aCBgKHIsIGcsIGIsIGEpYC4gSWYgYGFgXG4gICogICAgaXMgb21pdHRlZCwgaXQgZGVmYXVsdHMgdG8gYDFgLlxuICAqXG4gICogYHJgLCBgZ2AsIGBiYCBzaG91bGQgYmUgaW4gdGhlIHJhbmdlIG9mIDAtMjU1IGluY2x1c2l2ZS5cbiAgKi9cbkJWRy5wcm90b3R5cGUuc3Ryb2tlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBzID0gdGhpcy5hdHRyKCdzdHJva2UnKTtcbiAgICBpZiAocykgcmV0dXJuIEJWRy5leHRyYWN0TnVtYmVyQXJyYXkocyk7XG4gICAgcmV0dXJuICcnO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycpIHJldHVybiB0aGlzLmF0dHIoJ3N0cm9rZScsIGFyZ3VtZW50c1swXSk7ZWxzZSByZXR1cm4gdGhpcy5hdHRyKCdzdHJva2UnLCBCVkcucmdiYShhcmd1bWVudHNbMF0pKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdzdHJva2UnLCBCVkcucmdiYS5hcHBseShCVkcsIGFyZ3VtZW50cykpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHRoaXMsICdzdHJva2UoKSByZWNlaXZlZCBtb3JlIHRoYW4gMSBhcmd1bWVudC4nKTtcbiAgfVxufTtcblxuLyoqICMjIyBgYnZnLnN0cm9rZVdpZHRoKFt3aWR0aF0pYFxuICAqIEdldC9zZXQgdGhlIG91dGxpbmUgdGhpY2tuZXNzLlxuICAqXG4gICogUmV0dXJucyB0aGUgY3VycmVudCBvdXRsaW5lIHRoaWNrbmVzcyBpZiBgd2lkdGhgIGlzIG9taXR0ZWQuIE90aGVyaXNlLFxuICAqIGl0IGFzc2lnbnMgdGhlIG91dGxpbmUgdGhpY2tuZXNzIHdpdGggYSBuZXcgdmFsdWUsIGFuZCByZXR1cm5zIHRoZSBgYnZnYFxuICAqIG9iamVjdCByZWZlcmVuY2UuXG4gICpcbiAgKiAgLSBgd2lkdGhgICA6IE91dGxpbmUgdGhpY2tuZXNzIGluIHBpeGVscy5cbiAgKi9cbkJWRy5wcm90b3R5cGUuc3Ryb2tlV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignc3Ryb2tlLXdpZHRoJyk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuYXR0cignc3Ryb2tlLXdpZHRoJywgYXJndW1lbnRzWzBdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcih0aGlzLCAnc3Ryb2tlV2lkdGgoKSByZWNlaXZlZCBtb3JlIHRoYW4gMSBhcmd1bWVudC4nKTtcbiAgfVxufTtcblxuLyoqICMjIyBgYnZnLm5vU3Ryb2tlKClgXG4gICogUmVtb3ZlIEJWRyBvYmplY3QncyBvdXRsaW5lIGNvbXBsZXRlbHkuXG4gICovXG5CVkcucHJvdG90eXBlLm5vU3Ryb2tlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zdHJva2VXaWR0aCgwKS5zdHJva2UoJ3JnYmEoMCwgMCwgMCwgMCknKTtcbn07XG5cbkJWRy5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fdGFnLmlubmVySFRNTDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5fdGFnLmlubmVySFRNTCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcih0aGlzLCAnY29udGVudCgpIHJlY2VpdmVkIG1vcmUgdGhhbiAxIGFyZ3VtZW50LicpO1xuICB9XG59O1xuXG4vKiogIyMjIGBidmcuYWRkQ2xhc3MoYylgXG4qIEFkZCBhIGNsYXNzIG5hbWUgdG8gdGhlIGVsZW1lbnQuXG4qL1xuQlZHLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChjKSB7XG4gIHRoaXMuX3RhZy5jbGFzc0xpc3QuYWRkKGMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiAjIyMgYGJ2Zy5yZW1vdmVDbGFzcyhjKWBcbiAgKiBSZW1vdmUgYSBjbGFzcyBuYW1lIHRvIHRoZSBlbGVtZW50LlxuICAqL1xuQlZHLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChjKSB7XG4gIHRoaXMuX3RhZy5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiAjIyMgYGJ2Zy5oYXNDbGFzcyhjKWBcbiAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgY2xhc3MgYGNgLlxuICAqL1xuQlZHLnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjKSB7XG4gIHJldHVybiB0aGlzLl90YWcuY2xhc3NMaXN0LmNvbnRhaW5zKGMpO1xufTtcblxuLyoqICMjIyBgYnZnLnJlbW92ZUNsYXNzKGMpYFxuICAqIEFkZCBvciByZW1vdmUgdGhlIGNsYXNzIGBjYCB0byB0aGUgZWxlbWVudC5cbiAgKi9cbkJWRy5wcm90b3R5cGUudG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiAoYykge1xuICB0aGlzLl90YWcuY2xhc3NMaXN0LnRvZ2dsZShjKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogIyMgQWZmaW5lIFRyYW5zZm9ybWF0aW9ucyAqL1xuQlZHLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhZy5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLl90YWcuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBhcmd1bWVudHNbMF0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNmb3JtKCkgcmVjZWl2ZWQgbW9yZSB0aGFuIDEgYXJndW1lbnQnKTtcbiAgfVxufTtcblxuLyoqICMjIyBgQlZHLnRyYW5zbGF0ZSh4LCBbeV0pYFxuICAqIEFwcGx5IGEgbW92aW5nIHRyYW5zbGF0aW9uIGJ5IGB4YCBhbmQgYHlgIHVuaXRzLiBJZiBgeWAgaXMgbm90IGdpdmVuLCBpdFxuICAqIGlzIGFzc3VtZWQgdG8gYmUgMC5cbiAgKi9cbkJWRy5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcigndHJhbnNsYXRlKCkgb25seSB0YWtlIG51bWJlcnMgYXMgYXJndW1lbnRzJyk7XG4gIHkgPSB5IHx8IDA7XG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybSgpO1xuICB0aGlzLl90YWcuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBbdHJhbnNmb3JtLCAnIHRyYW5zbGF0ZSgnLCB4LCAnICcsIHksICcpJ10uam9pbignJykudHJpbSgpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogIyMgVXRpbGl0eSBNZXRob2RzICovXG5cbi8qKiAjIyMgYEJWRy5yZ2JhKHIsIGcsIGIsIFthXSlgXG4gICogUmV0dXJuIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIGByZ2JhKHIsIGcsIGIsIGEpYC5cbiAgKlxuICAqIElmIG9ubHkgYHJgIGlzIGdpdmVuLCB0aGUgdmFsdWUgaXMgY29waWVkIHRvIGBnYCBhbmQgYGJgIHRvIHByb2R1Y2UgYVxuICAqIGdyZXlzY2FsZSB2YWx1ZS5cbiAgKi9cbkJWRy5yZ2JhID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyAxLjAgOiBhcmd1bWVudHNbM107XG5cbiAgaWYgKHR5cGVvZiByICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcigncmdiYSgpIG11c3QgdGFrZSBudW1lcmljYWwgdmFsdWVzIGFzIGlucHV0Jyk7XG4gIGcgPSBnIHx8IHI7XG4gIGIgPSBiIHx8IHI7XG4gIHJldHVybiAncmdiYSgnICsgW3IsIGcsIGIsIGFdLmpvaW4oJywnKSArICcpJztcbn07XG5cbi8qKiAjIyMgYEJWRy5oc2xhKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBbYWxwaGFdKWBcbiAgKiBSZXR1cm4gdGhlIENTUyByZXByZXNlbnRhdGlvbiBpbiBgaHNsYSgpYCBhcyBhIHN0cmluZy5cbiAgKlxuICAqICAtIGBodWVgOiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMzYwYCwgd2hlcmUgYDBgIGlzIHJlZCwgYDEyMGAgaXMgZ3JlZW4sXG4gICogICAgICAgICAgIGFuZCBgMjQwYCBpcyBibHVlLlxuICAqICAtIGBzYXR1cmF0aW9uYCA6IEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxMDBgLCB3aGVyZSBgMGAgaXMgZ3JleSBhbmRcbiAgKiAgICAgICAgICAgICAgICAgYDEwMGAgaXMgZnVsbHkgc2F0dXJhdGUuXG4gICogIC0gYGxpZ2h0bmVzc2A6IEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxMDBgLCB3aGVyZSBgMGAgaXMgYmxhY2sgYW5kXG4gICogICAgICAgICAgICAgICAgIGAxMDBgIGlzIGZ1bGwgaW50ZW5zaXR5IG9mIHRoZSBjb2xvdXIuXG4gICovXG5CVkcuaHNsYSA9IGZ1bmN0aW9uIChodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGEpIHtcbiAgYWxwaGEgPSBhbHBoYSB8fCAxLjA7XG4gIHJldHVybiAnaHNsYSgnICsgW2h1ZSwgc2F0dXJhdGlvbiArICclJywgbGlnaHRuZXNzICsgJyUnLCBhbHBoYV0uam9pbignLCcpICsgJyknO1xufTtcblxuLyoqICMjIyBgQlZHLmV4dHJhY3ROdW1iZXJBcnJheShzdHIpYFxuICAqIFJldHVybiBhbiBhcnJheSBgW3gsIHksIHosIC4uLl1gIGZyb20gYSBzdHJpbmcgY29udGFpbmluZyBjb21tb24tc2VwYXJhdGVkXG4gICogbnVtYmVycy5cbiAgKi9cbkJWRy5leHRyYWN0TnVtYmVyQXJyYXkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIubWF0Y2goL1xcZCpcXC4/XFxkKy9nKS5tYXAoTnVtYmVyKTtcbn07XG5cbi8qKiAjIyBDb250cmlidXRlIHRvIHRoaXMgbGlicmFyeVxuKiBbTWFrZSBhIHB1bGwgcmVxdWVzdF0oaHR0cHM6Ly9naXRodWIuY29tL1NwYXhlL0JWRy5qcy9wdWxscykgb3JcbiogW3Bvc3QgYW4gaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9TcGF4ZS9CVkcuanMvaXNzdWVzKS4gU2F5IGhlbGxvIHRvXG4qIGNvbnRhY3RAeGFpdmVyaG8uY29tLlxuKi9cblxufSx7fV19LHt9LFsxXSkoMSlcbn0pOyIsIi8qKlxuICogUm9ndWVsaWtlIFVuaXZlcnNlXG4gKiBBdXRob3I6IFhhdmllciBIbyA8Y29udGFjdEB4YXZpZXJoby5jb20+XG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3BheGUvcm9ndWVsaWtlLXVuaXZlcnNlXG4gKi9cbmltcG9ydCBCVkcgZnJvbSBcImJ2Z1wiO1xuaW1wb3J0IHsgcHJvbWlzZSwgcmF0aW8sIGdldEpTT04gfSBmcm9tIFwiLi91dGlsXCI7XG5cbmNvbnN0IHNlcnZlcl91cmwgPSAnaHR0cDovLzE4OC4xNjYuMjA5LjE1NS9hcGkvdjEnO1xuY29uc3Qgc3RhcnRfeWVhciA9IDE5NzAsIGVuZF95ZWFyID0gMjAyMDtcbmNvbnN0IGZ4ID0gcmF0aW8uYmluZChyYXRpbywgc3RhcnRfeWVhciwgZW5kX3llYXIpO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuXG4gIGxldCBidmcgPSBCVkcuY3JlYXRlKCcjY29udGFpbmVyJyk7XG4gIGxldCBmb2N1cyA9IGJ2Zy5ncm91cCh7fSk7XG4gIGxldCB3aWR0aCA9IGJ2Zy50YWcoKS5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGJ2Zy50YWcoKS5jbGllbnRIZWlnaHQ7XG4gIGxldCBHVUlfZ2FtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYW1lJyk7XG4gIGxldCBzZWxlY3Rpb24gPSAnRHVuZ2Vvbic7XG5cbiAgbG9hZFJvZ3VlbGlrZVJlbGF0aW9uc0FsbCgpLnRoZW4oIHJlbGF0aW9ucyA9PiB7XG5cbiAgICAvLyBEcmF3IHRpbWVsaW5lXG4gICAgYnZnLnRleHQoJ3llYXInLFxuICAgICAgICAgICAgIDAuMDAxICogd2lkdGgsXG4gICAgICAgICAgICAgaGVpZ2h0IC8gMiArIDMpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydF95ZWFyICsgMjsgaSA8IGVuZF95ZWFyOyBpKyspIHtcbiAgICAgIGJ2Zy50ZXh0KGkudG9TdHJpbmcoKS5zdWJzdHIoMiwgNCksXG4gICAgICAgICAgICAgICAoZngoaSkgLSAwLjAwNSkgKiB3aWR0aCxcbiAgICAgICAgICAgICAgIGhlaWdodCAvIDIgKyAzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFBvcHVsYXRlIGdhbWUgdGl0bGVzXG4gICAgcmVsYXRpb25zLmZvckVhY2goIGdhbWUgPT4ge1xuICAgICAgbGV0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0aW9uLnZhbHVlID0gZ2FtZS50aXRsZTtcbiAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ2RhdGEteWVhcicsIGdhbWUueWVhcik7XG4gICAgICBvcHRpb24uaW5uZXJIVE1MID0gYCR7Z2FtZS50aXRsZX0gKCR7Z2FtZS55ZWFyfSlgO1xuICAgICAgR1VJX2dhbWUuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICB9KTtcblxuICAgIC8vIEJpbmQgc2VsZWN0aW9uXG4gICAgR1VJX2dhbWUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXZlbnQgPT4ge1xuICAgICAgc2VsZWN0aW9uID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgZHJhd1NlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH0pO1xuXG4gICAgLy8gRHJhdyBpbmZsdWVuY2UgYXJjc1xuICAgIHJlbGF0aW9ucy5mb3JFYWNoKCAoe3RpdGxlLCB5ZWFyLCBpbnNwaXJlZEJ5LCBpbnNwaXJhdGlvblRvLCBvdGhlckluc3BpcmVkQnksIG90aGVySW5zcGlyYXRpb25Ub30pID0+IHtcblxuICAgICAgaW5zcGlyZWRCeS5mb3JFYWNoKCByID0+IHtcbiAgICAgICAgZHJhd0FyYyhidmcsIHllYXIsIHIueWVhciwgLTEuMCwgMC4xKTtcbiAgICAgIH0pO1xuICAgICAgaW5zcGlyYXRpb25Uby5mb3JFYWNoKCByID0+IHtcbiAgICAgICAgZHJhd0FyYyhidmcsIHIueWVhciwgeWVhciwgLTEuMCwgMC4xKTtcbiAgICAgIH0pO1xuICAgICAgb3RoZXJJbnNwaXJlZEJ5LmZvckVhY2goIHIgPT4ge1xuICAgICAgICBkcmF3QXJjKGJ2ZywgeWVhciwgci55ZWFyLCAxLjAsIDAuMDUpO1xuICAgICAgfSk7XG4gICAgICBvdGhlckluc3BpcmF0aW9uVG8uZm9yRWFjaCggciA9PiB7XG4gICAgICAgIGRyYXdBcmMoYnZnLCByLnllYXIsIHllYXIsIDEuMCwgMC4wNSk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgbGV0IGRyYXdTZWxlY3Rpb24gPSAoc2VsZWN0aW9uKSA9PiB7XG4gICAgICBmb2N1cy50YWcoKS5pbm5lckhUTUwgPSAnJztcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVsYXRpb24gPSByZWxhdGlvbnNbaV07XG4gICAgICAgIGlmIChyZWxhdGlvbi50aXRsZSA9PT0gc2VsZWN0aW9uKSB7XG5cbiAgICAgICAgICBmb2N1cy50ZXh0KHNlbGVjdGlvbiwgZngocmVsYXRpb24ueWVhcikgKiB3aWR0aCwgMC4wOTUgKiBoZWlnaHQpXG4gICAgICAgICAgICAuZmlsbCgwKTtcblxuICAgICAgICAgIGZvY3VzLmxpbmUoe1xuICAgICAgICAgICAgeDE6IGZ4KHJlbGF0aW9uLnllYXIpICogd2lkdGgsXG4gICAgICAgICAgICB5MTogaGVpZ2h0ICogMC4xLFxuICAgICAgICAgICAgeDI6IGZ4KHJlbGF0aW9uLnllYXIpICogd2lkdGgsXG4gICAgICAgICAgICB5MjogaGVpZ2h0ICogMC45XG4gICAgICAgICAgfSkuc3Ryb2tlV2lkdGgoMikuc3Ryb2tlKDAsIDAsIDAsIDAuNSk7XG5cbiAgICAgICAgICByZWxhdGlvbi5pbnNwaXJlZEJ5LmZvckVhY2goIHIgPT4ge1xuICAgICAgICAgICAgZHJhd0FyYyhmb2N1cywgcmVsYXRpb24ueWVhciwgci55ZWFyLCAtMSwgMSwgMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVsYXRpb24uaW5zcGlyYXRpb25Uby5mb3JFYWNoKCByID0+IHtcbiAgICAgICAgICAgIGRyYXdBcmMoZm9jdXMsIHIueWVhciwgcmVsYXRpb24ueWVhciwgLTEsIDEsIDMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlbGF0aW9uLm90aGVySW5zcGlyZWRCeS5mb3JFYWNoKCByID0+IHtcbiAgICAgICAgICAgIGRyYXdBcmMoZm9jdXMsIHJlbGF0aW9uLnllYXIsIHIueWVhciwgMSwgMSwgMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVsYXRpb24ub3RoZXJJbnNwaXJhdGlvblRvLmZvckVhY2goIHIgPT4ge1xuICAgICAgICAgICAgZHJhd0FyYyhmb2N1cywgci55ZWFyLCByZWxhdGlvbi55ZWFyLCAxLCAxLCAzKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBGaXJlIGV2ZW50IHRvIHN0YXJ0XG4gICAgR1VJX2dhbWUudmFsdWUgPSBzZWxlY3Rpb247XG4gICAgZHJhd1NlbGVjdGlvbihzZWxlY3Rpb24pO1xuXG4gIH0pO1xuXG4gIGxldCBkcmF3QXJjID0gKGcsIHllYXJBLCB5ZWFyQiwgaW52ZXJ0PS0xLjAsIG9wYWNpdHk9MSwgc3Ryb2tlV2lkdGg9MSkgPT4ge1xuICAgIGxldCBhcmdzID0gYXJjWWVhcnRvWWVhcih5ZWFyQSwgeWVhckIsIGludmVydCk7XG4gICAgYXJnc1swXSAqPSB3aWR0aDsgYXJnc1sxXSAqPSBoZWlnaHQ7IGFyZ3NbMl0gKj0gaGVpZ2h0OyBhcmdzWzNdICo9IGhlaWdodDtcbiAgICBnLmFyYyguLi5hcmdzKS5zdHJva2UoMCwgMCwgMCwgb3BhY2l0eSkuc3Ryb2tlV2lkdGgoc3Ryb2tlV2lkdGgpO1xuICB9XG5cbn0pO1xuXG5jb25zdCBsb2FkUm9ndWVsaWtlUmVsYXRpb25zQWxsID0gKCkgPT4ge1xuXG4gIHJldHVybiBnZXRKU09OKGAke3NlcnZlcl91cmx9L3JvZ3VlbGlrZS9yZWxhdGlvbnMtYWxsYCk7XG5cbn07XG5cbmxldCBhcmNZZWFydG9ZZWFyID0gKGEsIGIsIGludmVydD0tMS4wKSA9PiB7XG5cbiAgbGV0IHhfYSA9IGZ4KGEsIHN0YXJ0X3llYXIsIGVuZF95ZWFyKTtcbiAgbGV0IHhfYiA9IGZ4KGIsIHN0YXJ0X3llYXIsIGVuZF95ZWFyKTtcbiAgbGV0IHggPSAoeF9hICsgeF9iKSAvIDI7XG4gIGxldCB5ID0gMC41ICsgMC4wMSAqIGludmVydDtcbiAgbGV0IHJ4ID0gTWF0aC5hYnMoeF9iIC0geF9hKSAvIDI7XG4gIGxldCByeSA9IHJ4O1xuICBsZXQgc3RhcnRBbmdsZSA9IDA7XG4gIGxldCBlbmRBbmdsZSA9IE1hdGguUEkgKiBpbnZlcnQ7XG4gIHJldHVybiBbeCwgeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG5cbn07XG5cbiIsImV4cG9ydCBjb25zdCBwcm9taXNlID0gKCBmdW5jLCAuLi5hcmdzICkgPT4ge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoIGVycm9yLCBkYXRhICkgPT4ge1xuICAgICAgaWYgKGVycm9yKSByZWplY3QoZXJyb3IpO1xuICAgICAgZWxzZSByZXNvbHZlKGRhdGEpO1xuICAgIH07XG4gICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICBmdW5jLmFwcGx5KGZ1bmMsIGFyZ3MpO1xuICB9KTtcblxufTtcblxuZXhwb3J0IGNvbnN0IHJhdGlvID0gKG1pbiwgbWF4LCB4KSA9PiB7XG5cbiAgcmV0dXJuICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xuXG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VVJMID0gKHVybCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXEub3BlbignR0VUJywgdXJsKTtcbiAgICByZXEub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxLnN0YXR1c1RleHQpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdOZXR3b3JrIEVycm9yJykpO1xuICAgIH07XG4gICAgcmVxLnNlbmQoKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SlNPTiA9ICh1cmwpID0+IHtcbiAgcmV0dXJuIGdldFVSTCh1cmwpLnRoZW4oSlNPTi5wYXJzZSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgIGNvbnNvbGUubG9nKCdnZXRKU09OIGZhaWxlZCB0byBsb2FkJywgdXJsKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xufTsiXX0=
