(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.BVG = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//
/** # BVG - Bindable Vector Graphics
  * **Real-time data-driven visualisation for the web.**
  *
  * ![Example](https://raw.githubusercontent.com/Spaxe/BVG.js/master/demo/index.gif)
  *
  * Live example: http://spaxe.github.io/BVG.js/
  *
  * *Bindable Vector Graphics* was born out of frustration for lack of a
  * middle level SVG library. [D3.js](http://d3js.org/) abstracts too much
  * logic, and [SVG.js](http://svgjs.com/) provides only low-level SVG drawing.
  * Bindable Vector Graphics offers SVG elements that change as the data change,
  * and gives you tools to control their look.
  */
'use strict';

/** The heart of this library is a trinity: **SVG + Data + Binding**. This
  * connects your data to the SVG element through the binding function, which
  * creates a living connection that can react to change. BVG uses
  * [`Object.observe()`](http://caniuse.com/#feat=object-observe) which is
  * available on Chrome 36+, Opera 27+ and Android Browser 37+.
  *
  * If you wish to use this for older browsers, you can polyfill with
  * [`MaxArt2501/Object.observe`](https://github.com/MaxArt2501/object-observe).
  *
  * ## Installation
  *
  * **Install using `npm`**:
  *
  *  1. Install Node.js: https://docs.npmjs.com/getting-started/installing-node
  *  2. In your working directory:
  *
  *     ```
  *     npm install bvg
  *     ```
  *
  * **Install via GitHub**:
  *
  *  1. Clone this repo:
  *
  *     ```
  *     git clone https://github.com/Spaxe/BVG.js.git
  *     ```
  *
  *  2. Copy `require.js` and `bvg.js` into your working directory.
  *
  * **To include `BVG.js` in your webpage**:
  *
  *  1. In your HTML `<head>`, include this script using `require.js`:
  *
  *     ```HTML
  *     <script src="path/to/require.js" data-main="your-script.js"></script>
  *     ```
  *
  *  2. In `your-script.js`, define your own code with
  *
  *     ```Javascript
  *     require(['path/to/bvg.js'], function (BVG) {
  *       // your code goes here ...
  *     });
  *     ```
  *
  * ## Quickstart
  *
  * ![Quickstart Example](https://raw.githubusercontent.com/Spaxe/BVG.js/master/demo/001-hello.gif)
  *
  * HTML:
  *
  * ```HTML
  * <div id="bvg-container"></div>
  * ```
  *
  * CSS (Make the container large enough):
  *
  * ```CSS
  * html, body, #bvg-container {
  *   height: 100%;
  *   margin: 0;
  * }
  * ```
  *
  * Javascript:
  *
  * ```Javascript
  * // Create a BVG container based on selected HTML element
  * var bvg = BVG.create('#bvg-container');
  * // Create a Bindable circle, colour it orange
  * var circle = bvg.ellipse(0, 0, 150, 150)
  *                 .fill(220, 64, 12);
  * // Change its size based on mouse movement
  * bvg.tag().addEventListener('mousemove', function (event) {
  *   circle.data({
  *     rx: event.clientX,
  *     ry: event.clientY
  *   });
  * });
  * ```
  */

/*- Deep Object.observe() */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BVG;
function observe(obj, callback) {

  // Include https://github.com/MaxArt2501/object-observe if you wish to work
  // with polyfill on browsers that don't support Object.observe()
  Object.observe(obj, function (changes) {
    changes.forEach(function (change) {

      // Bind child property if it is an object for deep observing
      if (obj[change.name] instanceof Object) {
        observe(obj[change.name], callback);
      }
    });

    // Trigger user callback
    callback.call(this, changes);
  });

  // Immediately fire observe to initiate deep observing
  Object.keys(obj).forEach(function (key) {
    if (obj[key] instanceof Object) {
      observe(obj[key], callback);
    }
  });
}

/*- `BVG(tag, data, binding)`
  * The trinity of this library: SVG + Data + Binding Function.
  *
  * Return the BVG object created.
  *
  *  - `tag`    : Either a `String` for the SVG `tagName` or any [`SVGElement`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element)
  *  - `data`   : Object with arbitrary data to your desire
  *  - `binding`: (optional) Binding function that sets the tag attributes
  */
function BVG(tag, data, binding) {
  var bvg = this;
  tag = tag instanceof SVGElement ? tag : document.createElementNS('http://www.w3.org/2000/svg', tag);
  data = data || {};
  binding = binding || function (tag, data) {
    for (var prop in data) {
      if (data.hasOwnProperty(prop)) {
        tag.setAttribute(prop, data[prop]);
      }
    }
  };

  // Observe data object and apply binding right away
  observe(data, function (changes) {
    binding(tag, data);
  });
  binding(tag, data);

  // ID function from https://gist.github.com/gordonbrander/2230317
  tag.setAttribute('id', 'BVG_' + tag.tagName + '_' + Math.random().toString(36).substr(2, 7));
  this._tag = tag;
  this._data = data;
  this._binding = binding;

  // Functional circular reference
  this._tag._getBVG = function () {
    return bvg;
  };

  if (['svg', 'g', 'a'].indexOf(tag.tagName) < 0) {
    if (!data.stroke) this.stroke(175);
    if (!data.strokeWidth) this.strokeWidth(0.5);
    if (!data.fill) this.noFill();
  }

  return this;
};

/** ## The BVG Container
  * The rest of the documentation will assume `bvg` as our BVG container
  * created by the example below.
  */

/** ### `BVG.create(htmlElement)`
  * Create a BVG container inside `htmlElement`.
  *
  * Return the BVG container object.
  *
  *  - `htmlElement`  : Either a [CSS Selector](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
  *                     or any [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
  *
  * ```Javascript
  * // Create a new BVG container and append it to an existing HTML element.
  * var bvg = BVG.create('#bvg-container');
  * ```
  */
var create = exports.create = BVG.create = function (htmlElement, xDimension, yDimension) {
  if (typeof htmlElement === 'string') htmlElement = document.querySelector(htmlElement);
  if (!(htmlElement instanceof HTMLElement)) throw new TypeError('htmlElement (' + htmlElement + ') was not found.');

  var data = {
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    version: 1.1,
    width: '100%',
    height: '100%'
  };
  yDimension = yDimension || xDimension;
  if (xDimension) {
    data.viewBox = [0, 0, xDimension, yDimension].join(' ');
  }

  var bvg = new BVG('svg', data);
  htmlElement.appendChild(bvg.tag());
  return bvg;
};

/** ## BVG Elements
  * All BVG objects, including the container, have access to drawing functions
  * and return reference to the new shape, which is also a BVG.
  *
  * ```Javascript
  * // Create a rectangle at (0, 0) with dimensions 100x100 px and add it to bvg
  * var rect = bvg.rect(0, 0, 100, 100);
  * ```
  *
  * The BVG module also has drawing functions, which return the BVG object:
  *
  * ```Javascript
  * // Create a rectangle at (0, 0) with dimensions 100x100 px
  * // Note it uses the BVG module directly to create the rectangle.
  * var rect = BVG.rect(0, 0, 100, 100);
  * // Add the rectangle to an existing BVG container
  * bvg.append(rect);
  * ```
  *
  * Drawing functions can be called in a number of ways. Take `bvg.rect(x, y, width, height)`
  * as an example below. Sometimes it is easier to use one over another style.
  *
  * ```Javascript
  * bvg.rect(0, 10, 30, 70);      // Arguments style
  * bvg.rect({                    // Object style
  *   x: 0,
  *   y: 10,                      // Name of the object properties must match
  *   width: 30,                  // names of the arguments in the functions,
  *   height: 70                  // but the order can be any.
  * });
  * ```
  */
var creationFunctions = {
  svg: function svg(xlink, version, width, height) {
    return new BVG('svg', xlink.constructor.name === 'Object' ? xlink : {
      'xmlns:xlink': xlink,
      version: version,
      width: width,
      height: height
    });
  },

  /** ### `bvg.rect(x, y, width, height)`
    * Create a rectangle at position `(x, y)` at `width` x `height` in size.
    *
    * ```Javascript
    * var rect = bvg.rect(100, 100, 300, 150);
    * ```
    */
  rect: function rect(x, y, width, height) {
    return new BVG('rect', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      width: width,
      height: height
    });
  },

  /** ### `bvg.circle(cx, cy, r)`
    * Create a circle centred on `(cx, cy)` with radius `r`.
    *
    * ```Javascript
    * var circle = bvg.ellipse(100, 100, 50);
    * ```
    */
  circle: function circle(x, y, r) {
    return new BVG('circle', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      r: r
    }, function (tag, data) {
      tag.setAttribute('cx', data.x);
      tag.setAttribute('cy', data.y);
      tag.setAttribute('r', data.r);
    });
  },

  /** ### `bvg.ellipse(cx, cy, rx, ry)`
    * Create a ellipse centred on `(cx, cy)` with radii `rx` and `ry`.
    *
    * ```Javascript
    * var ellipse = bvg.ellipse(100, 100, 200, 180);
    * ```
    */
  ellipse: function ellipse(x, y, rx, ry) {
    return new BVG('ellipse', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      rx: rx,
      ry: ry
    }, function (tag, data) {
      tag.setAttribute('cx', data.x);
      tag.setAttribute('cy', data.y);
      tag.setAttribute('rx', data.rx);
      tag.setAttribute('ry', data.ry);
    });
  },

  /** ### `bvg.line(x1, y1, x2, y2)`
    * Create a line from `(x1, y1)` to `(x2, y2)`.
    *
    * ```Javascript
    * var line = bvg.line(100, 100, 200, 300);
    * ```
    */
  line: function line(x1, y1, x2, y2) {
    return new BVG('line', x1.constructor.name === 'Object' ? x1 : {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2
    });
  },
  /** ### `bvg.polyline([[x1, y1], [x2, y2], ...])`
    * Create a series of lines from point to point.
    *
    * ```Javascript
    * var polyline = bvg.polyline([[100, 200], [200, 300], [400, 800]]);
    * ```
    */
  polyline: function polyline(points) {
    return new BVG('polyline', points.constructor.name === 'Object' ? points : {
      points: points
    }, function (tag, data) {
      tag.setAttribute('points', data.points.join(' '));
    });
  },
  /** ### `bvg.polygon([[x1, y1], [x2, y2], ...])`
    * Create a closed polygon from point to point. The last point will be
    * connected back to the first point.
    *
    * ```Javascript
    * var polygon = bvg.polygon([[100, 200], [200, 300], [400, 800]]);
    * ```
    */
  polygon: function polygon(points) {
    return new BVG('polygon', points.constructor.name === 'Object' ? points : {
      points: points
    }, function (tag, data) {
      tag.setAttribute('points', data.points.join(' '));
    });
  },

  /** ## Grouping Elements
    * ### `bvg.group([transform])`
    *
    * Create a group to contain BVG objects. It acts like a BVG container with
    * an optional `transform` attribute.
    *
    * ```Javascript
    * // Create a new group and fill it with dashes.
    * var dashes = bvg.group();
    * for (int i = 0; i < 5; i++) {
    *   dahses.rect(10, 10 + i * 30, 50, 20);
    * }
    * ```
    */
  group: function group(transform) {
    return new BVG('g', transform.constructor.name === 'Object' ? transform : {
      transform: transform
    });
  },

  /** ## Hyperlinks
    * ### `bvg.hyperlink(url)`
    *
    * Create a hyperlink BVG to target URL `url`. It does not have any display
    * elements. Make sure to append elements to it.
    *
    * ```Javascript
    * // Clicking on this element will bring them to the Github page
    * var githubLink = bvg.hyperlink('https://github.com/spaxe/BVG.js');
    * // Make a button and attack it to the link
    * githubLink.ellipse(200, 200, 50, 50);
    * ```
    */
  hyperlink: function hyperlink(url) {
    return new BVG('a', url.constructor.name === 'Object' ? url : {
      'xmlns:href': url
    });
  },

  /** ## Other Geometry
    * ### `bvg.triangle(cx, cy, r)`
    * Create a regular triangle centred on `(cx, cy)` with vertices `r` distance
    * away.
    *
    * ```Javascript
    * var triangle = bvg.triangle(50, 50, 10);
    * ```
    */
  triangle: function triangle(x, y, r) {
    return new BVG('polygon', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      r: r
    }, function (tag, data) {
      var points = [[data.x, data.y - data.r], [data.x - data.r / 2 * Math.sqrt(3), data.y + data.r / 2], [data.x + data.r / 2 * Math.sqrt(3), data.y + data.r / 2]];
      tag.setAttribute('points', points.join(' '));
    });
  },

  /** ### `bvg.arc(cx, cy, rx, ry, startAngle, endAngle)`
    * Create an arc centred on `(cx, cy)` with radius `rx` and `ry`, starting
    * from `startAngle` anti-clockwise to `endAngle`, where 0 is the positive
    * x-axis.
    *
    * ```Javascript
    * var arc = bvg.arc(50, 50, 50, 100, 0, Math.PI);
    * ```
    */
  arc: function arc(x, y, rx, ry, startAngle, endAngle) {
    return new BVG('path', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      rx: rx,
      ry: ry,
      startAngle: startAngle,
      endAngle: endAngle
    }, function (tag, data) {
      var p1 = getPointOnEllipse(data.x, data.y, data.rx, data.ry, data.startAngle);
      var p2 = getPointOnEllipse(data.x, data.y, data.rx, data.ry, data.endAngle);
      var largeArc = data.endAngle - data.startAngle > Math.PI ? 1 : 0;
      var sweepArc = data.endAngle > data.startAngle ? 1 : 0;
      var d = [['M', p1.x, p1.y], ['A', data.rx, data.ry, 0, largeArc, sweepArc, p2.x, p2.y]];
      tag.setAttribute('d', d.map(function (x) {
        return x.join(' ');
      }).join(' '));

      function getPointOnEllipse(x, y, rx, ry, angle) {
        return {
          x: rx * Math.cos(angle) + x,
          y: ry * Math.sin(angle) + y
        };
      }
    });
  },

  /** ### `bvg.text(text, x, y)`
    * Create a string of `text` text at location `(x, y)`.
    *
    * ```Javascript
    * var text = bvg.text('Mrraa!', 20, 10);
    * ```
    */
  text: function text(_text, x, y) {
    return new BVG('text', _text.constructor.name === 'Object' ? _text : {
      text: _text,
      x: x,
      y: y
    }, function (tag, data) {
      tag.innerHTML = data.text;
      tag.setAttribute('x', data.x);
      tag.setAttribute('y', data.y);
    }).fill('rgba(175, 175, 175, 1)').stroke('rgba(0, 0, 0, 0)');
  }
};

Object.keys(creationFunctions).forEach(function (f) {
  BVG[f] = function () {
    return creationFunctions[f].apply(BVG, arguments);
  };
  BVG.prototype[f] = function () {
    var bvg = creationFunctions[f].apply(this, arguments);
    this.append(bvg);
    return bvg;
  };
});

/** ## The BVG Object
  * BVGs are SVGs with extra superpowers.
  */

/** ### `bvg.find(selector)`
  * Return an array of BVGs matching `selector` inside BVG. `selector` is
  * defined as [CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors).
  */
BVG.prototype.find = function (selector) {
  var result = this._tag.querySelectorAll(selector);
  if (result) {
    var bvgs = [];
    [].slice.call(result).forEach(function (r) {
      bvgs.push(r._getBVG());
    });
    return bvgs;
  }
  return [];
};

/** ### `bvg.append(bvg)`
  * Insert `child_bvg` inside `bvg`. This is useful to add elements inside a
  * `BVG.group()`.
  */
BVG.prototype.append = function (child_bvg) {
  this._tag.appendChild(child_bvg._tag);
  return this;
};

/** ### `bvg.remove()`
  * Remove itself from its parent. Return self reference.
  */
BVG.prototype.remove = function () {
  var parent = this.parent();
  if (parent) {
    parent._tag.removeChild(this._tag);
  }
  return this;
};

/** ### `bvg.parent()`
  * Return the parent BVG. If there is no parent (such is the case for the BVG
  * container itself), return null.
  */
BVG.prototype.parent = function () {
  if (this._tag.parentNode && typeof this._tag.parentNode._getBVG === 'function') return this._tag.parentNode._getBVG();
  return null;
};

/** ### `bvg.children()`
  * Return a list of BVG elements inside `bvg`.
  */
BVG.prototype.children = function () {
  var output = [];
  for (var i = 0; i < this._tag.childNodes.length; i++) {
    if (typeof this._tag.childNodes[i]._getBVG === 'function') output.push(this._tag.childNodes[i]._getBVG());
  }return output;
};

/** ### `bvg.tag()`
  * Return thw BVG graphical content, a SVG.
  */
BVG.prototype.tag = function () {
  return this._tag;
};

/** ### `bvg.data()`
 * Get/set the `data` object in a BVG. There are four ways to use this
 * function.
 *
 *  - `bvg.data()`: Return `data` bound to the BVG.
 *  - `bvg.data(newData)`: Update `data` with `newData` object.
 *  - `bvg.data(property)`: Return `data[property]` from the BVG.
 *  - `bvg.data(property, newValue)`: Update `property` with `newValue`.
 *
 * Return `bvg` object reference.
 */
BVG.prototype.data = function () {
  if (arguments.length === 0) {
    return this._data;
  } else if (arguments.length === 1) {
    if (arguments[0].constructor.name === 'Object') {
      for (var k in arguments[0]) {
        if (arguments[0].hasOwnProperty(k)) {
          this.data(k, arguments[0][k]);
        }
      }
      return this;
    } else {
      return this._data[arguments[0]];
    }
  } else if (arguments.length === 2) {
    this._data[arguments[0]] = arguments[1];
    return this;
  } else {
    throw new RangeError(this, 'data() received more than 2 arguments.');
  }
};

/** ### `bvg.attr()`
  * Get/set attributes on a BVG.
  *
  *  - `bvg.attr(attr)`: Return attribute value.
  *  - `bvg.attr(attr, value)`: Update `attr` with `value`.
  */
BVG.prototype.attr = function (attr, value) {
  if (!attr) throw new Error('attr must be defined');
  if (!value) return this._tag.getAttribute(attr);else this._tag.setAttribute(attr, value);
  return this;
};

/** ### `bvg.fill()`
  * Get/set the filling colour.
  *
  *  - `bvg.fill()`: Return `fill` colour as [r, g, b, a], or `''` (empty
  *                  strig) if fill is not specified on the object.
  *  - `bvg.fill(rgb)`: Set `fill` with a greyscale colour with equal
  *    values `(rgb, rgb, rgb)`.
  *  - `bvg.fill(r, g, b, [a])`: Set `fill` with `(r, g, b, a)`. If `a`
  *    is omitted, it defaults to `1`.
  *
  * `r`, `g`, `b` should be in the range of 0-255 inclusive.
  */
BVG.prototype.fill = function () {
  if (arguments.length === 0) {
    var f = this.attr('fill');
    if (f) return BVG.extractNumberArray(f);
    return '';
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'string') return this.attr('fill', arguments[0]);else return this.attr('fill', BVG.rgba(arguments[0]));
  } else if (arguments.length === 3 || arguments.length === 4) {
    return this.attr('fill', BVG.rgba.apply(BVG, arguments));
  } else {
    throw new RangeError(this, 'fill() received more than 1 argument.');
  }
};

/** ### `bvg.noFill()`
  * Remove BVG object's colour filling completely.
  */
BVG.prototype.noFill = function () {
  return this.fill('rgba(0, 0, 0, 0)');
};

/** ### `bvg.stroke()`
  * Get/set the outline colour.
  *
  *  - `bvg.stroke()`: Return `stroke` colour as [r, g, b, a]. If `stroke` is
  *    not specified, return `''` (empty string).
  *  - `bvg.stroke(rgb)`: Set `stroke` with a greyscale colour with equal
  *    values `(rgb, rgb, rgb)`.
  *  - `bvg.stroke(r, g, b, [a])`: Set `stroke` with `(r, g, b, a)`. If `a`
  *    is omitted, it defaults to `1`.
  *
  * `r`, `g`, `b` should be in the range of 0-255 inclusive.
  */
BVG.prototype.stroke = function () {
  if (arguments.length === 0) {
    var s = this.attr('stroke');
    if (s) return BVG.extractNumberArray(s);
    return '';
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'string') return this.attr('stroke', arguments[0]);else return this.attr('stroke', BVG.rgba(arguments[0]));
  } else if (arguments.length === 3 || arguments.length === 4) {
    return this.attr('stroke', BVG.rgba.apply(BVG, arguments));
  } else {
    throw new RangeError(this, 'stroke() received more than 1 argument.');
  }
};

/** ### `bvg.strokeWidth([width])`
  * Get/set the outline thickness.
  *
  * Returns the current outline thickness if `width` is omitted. Otherise,
  * it assigns the outline thickness with a new value, and returns the `bvg`
  * object reference.
  *
  *  - `width`  : Outline thickness in pixels.
  */
BVG.prototype.strokeWidth = function () {
  if (arguments.length === 0) {
    return this.attr('stroke-width');
  } else if (arguments.length === 1) {
    this.attr('stroke-width', arguments[0]);
    return this;
  } else {
    throw new RangeError(this, 'strokeWidth() received more than 1 argument.');
  }
};

/** ### `bvg.noStroke()`
  * Remove BVG object's outline completely.
  */
BVG.prototype.noStroke = function () {
  return this.strokeWidth(0).stroke('rgba(0, 0, 0, 0)');
};

BVG.prototype.content = function () {
  if (arguments.length === 0) {
    return this._tag.innerHTML;
  } else if (arguments.length === 1) {
    this._tag.innerHTML = arguments[0];
    return this;
  } else {
    throw new RangeError(this, 'content() received more than 1 argument.');
  }
};

/** ### `bvg.addClass(c)`
* Add a class name to the element.
*/
BVG.prototype.addClass = function (c) {
  this._tag.classList.add(c);
  return this;
};

/** ### `bvg.removeClass(c)`
  * Remove a class name to the element.
  */
BVG.prototype.removeClass = function (c) {
  this._tag.classList.remove(c);
  return this;
};

/** ### `bvg.hasClass(c)`
  * Return true if the element has class `c`.
  */
BVG.prototype.hasClass = function (c) {
  return this._tag.classList.contains(c);
};

/** ### `bvg.removeClass(c)`
  * Add or remove the class `c` to the element.
  */
BVG.prototype.toggleClass = function (c) {
  this._tag.classList.toggle(c);
  return this;
};

/** ## Affine Transformations */
BVG.prototype.transform = function () {
  if (arguments.length === 0) {
    return this._tag.getAttribute('transform') || '';
  } else if (arguments.length === 1) {
    this._tag.setAttribute('transform', arguments[0]);
    return this;
  } else {
    throw new Error('transform() received more than 1 argument');
  }
};

/** ### `BVG.translate(x, [y])`
  * Apply a moving translation by `x` and `y` units. If `y` is not given, it
  * is assumed to be 0.
  */
BVG.prototype.translate = function (x, y) {
  if (typeof x !== 'number' && typeof y !== 'number') throw new Error('translate() only take numbers as arguments');
  y = y || 0;
  var transform = this.transform();
  this._tag.setAttribute('transform', [transform, ' translate(', x, ' ', y, ')'].join('').trim());
  return this;
};

/** ## Utility Methods */

/** ### `BVG.rgba(r, g, b, [a])`
  * Return a string in the form of `rgba(r, g, b, a)`.
  *
  * If only `r` is given, the value is copied to `g` and `b` to produce a
  * greyscale value.
  */
BVG.rgba = function (r, g, b) {
  var a = arguments.length <= 3 || arguments[3] === undefined ? 1.0 : arguments[3];

  if (typeof r !== 'number') throw new TypeError('rgba() must take numerical values as input');
  g = g || r;
  b = b || r;
  return 'rgba(' + [r, g, b, a].join(',') + ')';
};

/** ### `BVG.hsla(hue, saturation, lightness, [alpha])`
  * Return the CSS representation in `hsla()` as a string.
  *
  *  - `hue`: A value between `0` and `360`, where `0` is red, `120` is green,
  *           and `240` is blue.
  *  - `saturation` : A value between `0` and `100`, where `0` is grey and
  *                 `100` is fully saturate.
  *  - `lightness`: A value between `0` and `100`, where `0` is black and
  *                 `100` is full intensity of the colour.
  */
BVG.hsla = function (hue, saturation, lightness, alpha) {
  alpha = alpha || 1.0;
  return 'hsla(' + [hue, saturation + '%', lightness + '%', alpha].join(',') + ')';
};

/** ### `BVG.extractNumberArray(str)`
  * Return an array `[x, y, z, ...]` from a string containing common-separated
  * numbers.
  */
BVG.extractNumberArray = function (str) {
  return str.match(/\d*\.?\d+/g).map(Number);
};

/** ## Contribute to this library
* [Make a pull request](https://github.com/Spaxe/BVG.js/pulls) or
* [post an issue](https://github.com/Spaxe/BVG.js/issues). Say hello to
* contact@xaiverho.com.
*/

},{}]},{},[1])(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
"use strict";

var _bvg = require("bvg");

var _bvg2 = _interopRequireDefault(_bvg);

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; } /**
                                                                                                                              * Roguelike Universe
                                                                                                                              * Author: Xavier Ho <contact@xavierho.com>
                                                                                                                              * https://github.com/Spaxe/roguelike-universe
                                                                                                                              */

var server_url = 'http://188.166.209.155/api/v1';
var start_year = 1970,
    end_year = 2020;
var fx = _util.ratio.bind(_util.ratio, start_year, end_year);

document.addEventListener('DOMContentLoaded', function () {

  roguelikeRelations();
  genreInfluenceMap();
});

var roguelikeRelations = function roguelikeRelations() {

  var bvg = _bvg2.default.create('#roguelike-relations');
  var focus = bvg.group('');
  var width = bvg.tag().clientWidth;
  var height = bvg.tag().clientHeight;
  var GUI_game = document.getElementById('game');
  var selection = 'Dungeon';

  loadRoguelikeRelationsAll().then(function (relations) {

    // Draw timeline
    bvg.text('year', 0.001 * width, height / 2 + 3);
    for (var i = start_year + 2; i < end_year; i++) {
      bvg.text(i.toString().substr(2, 4), (fx(i) - 0.005) * width, height / 2 + 3);
    }
    bvg.text('In-genre', 0.001 * width, 0.1 * height);
    bvg.text('Out-of-genre', 0.001 * width, 0.9 * height);

    // Populate game titles
    relations.forEach(function (game) {
      var option = document.createElement('option');
      option.value = game.title;
      option.setAttribute('data-year', game.year);
      option.innerHTML = game.title + " (" + game.year + ")";
      GUI_game.appendChild(option);
    });

    // Bind selection
    GUI_game.addEventListener('change', function (event) {
      selection = event.target.value;
      drawSelection(selection);
    });

    // Draw influence arcs
    relations.forEach(function (_ref) {
      var title = _ref.title;
      var year = _ref.year;
      var inspiredBy = _ref.inspiredBy;
      var inspirationTo = _ref.inspirationTo;
      var otherInspiredBy = _ref.otherInspiredBy;
      var otherInspirationTo = _ref.otherInspirationTo;

      inspiredBy.forEach(function (r) {
        drawArc(bvg, year, r.year, -1.0, 0.1);
      });
      inspirationTo.forEach(function (r) {
        drawArc(bvg, r.year, year, -1.0, 0.1);
      });
      otherInspiredBy.forEach(function (r) {
        drawArc(bvg, year, r.year, 1.0, 0.05);
      });
      otherInspirationTo.forEach(function (r) {
        drawArc(bvg, r.year, year, 1.0, 0.05);
      });
    });

    var drawSelection = function drawSelection(selection) {
      focus.tag().innerHTML = '';

      var _loop = function _loop(i) {
        var relation = relations[i];
        if (relation.title === selection) {

          focus.text(selection, fx(relation.year) * width, 0.095 * height).fill(0);

          focus.line({
            x1: fx(relation.year) * width,
            y1: height * 0.1,
            x2: fx(relation.year) * width,
            y2: height * 0.9
          }).strokeWidth(2).stroke(0, 0, 0, 0.5);

          relation.inspiredBy.forEach(function (r) {
            drawArc(focus, relation.year, r.year, -1, 1, 3);
          });
          relation.inspirationTo.forEach(function (r) {
            drawArc(focus, r.year, relation.year, -1, 1, 3);
          });
          relation.otherInspiredBy.forEach(function (r) {
            drawArc(focus, relation.year, r.year, 1, 1, 3);
          });
          relation.otherInspirationTo.forEach(function (r) {
            drawArc(focus, r.year, relation.year, 1, 1, 3);
          });

          return {
            v: undefined
          };
        }
      };

      for (var i = 0; i < relations.length; i++) {
        var _ret = _loop(i);

        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
      }
    };

    // Fire event to start
    GUI_game.value = selection;
    drawSelection(selection);
  });

  var drawArc = function drawArc(g, yearA, yearB) {
    var invert = arguments.length <= 3 || arguments[3] === undefined ? -1.0 : arguments[3];
    var opacity = arguments.length <= 4 || arguments[4] === undefined ? 1 : arguments[4];
    var strokeWidth = arguments.length <= 5 || arguments[5] === undefined ? 1 : arguments[5];

    var args = arcYeartoYear(yearA, yearB, invert);
    args[0] *= width;args[1] *= height;args[2] *= height;args[3] *= height;
    g.arc.apply(g, _toConsumableArray(args)).stroke(0, 0, 0, opacity).strokeWidth(strokeWidth);
  };
};

var genreInfluenceMap = function genreInfluenceMap() {

  var bvg = _bvg2.default.create('#genre-influence');
  var focus = bvg.group('');
  var width = bvg.tag().clientWidth;
  var height = bvg.tag().clientHeight;
  var radius = 3;

  // Axis
  bvg.line(0.1 * width, 0.01 * height, 0.1 * width, 0.9 * height).stroke(0);
  bvg.line(0.1 * width, 0.9 * height, 0.99 * width, 0.9 * height).stroke(0);
  var verticalLabelIn = bvg.group("translate(" + 0.09 * width + " " + 0.15 * height + ")");
  verticalLabelIn.text('Influences from in-genre', 0, 0).transform('rotate(-90)');
  var verticalLabelOut = bvg.group("translate(" + 0.09 * width + " " + 0.9 * height + ")");
  verticalLabelOut.text('Influences from out-of-genre', 0, 0).transform('rotate(-90)');
  bvg.text('Influenced by its past', 0.11 * width, 0.915 * height);
  bvg.text('Influences its future', 0.87 * width, 0.915 * height);

  loadRoguelikeRelationsAll().then(function (relations) {

    var max = 0;
    var games = relations.map(function (_ref2) {
      var title = _ref2.title;
      var year = _ref2.year;
      var inspiredBy = _ref2.inspiredBy;
      var inspirationTo = _ref2.inspirationTo;
      var otherInspiredBy = _ref2.otherInspiredBy;
      var otherInspirationTo = _ref2.otherInspirationTo;

      if (['Dungeon Crawl Stone Soup', 'Pokémon Mystery Dungeon: Explorers of Time and Explorers of Darkness', 'Shiren the Wanderer', 'Mystery Dungeon: Shiren the Wanderer', 'Weird Worlds: Return to Infinite Space', 'Pokémon Mystery Dungeon: Explorers of Sky', 'Izuna 2: The Unemployed Ninja Returns', 'Sword of the Stars: The Pit', "Tao's Adventure: Curse of the Demon Sea", 'Dragon Quest: Shonen Yangus to Fushigi no Dungeon', 'Teleglitch', "Moraff's Revenge", 'Doom, the Roguelike', "Chocobo's Dungeon 2", 'Not the Robots', 'Izuna: Legend of the Unemployed Ninja', 'Deadly Dungeons', "Tao's Adventure: Curse of the Demon Seal", 'Chocobo no Fushigina Dungeon', 'Rogue Legacy'].indexOf(title) >= 0) return { title: title, x: 0, y: 0 };

      var iB = inspiredBy.length;
      var iT = inspirationTo.length;
      var oB = otherInspiredBy.length / 4;
      var oT = otherInspirationTo.length / 4;
      var x = -iB - oB + iT + oT;
      var y = -iB + oB - iT + oT;
      max = Math.max(max, Math.pow(Math.abs(x), 2), Math.pow(Math.abs(y), 2)) + 1;
      return { title: title, x: x, y: y };
    });

    games.forEach(function (c) {
      if (c.x === 0 && c.y === 0) return;
      var sx = c.x && c.x / Math.abs(c.x);
      var sy = c.y && c.y / Math.abs(c.y);
      var cx = Math.abs(c.x) > 0 ? Math.sqrt(Math.abs(c.x)) * 2 : 0;
      var cy = Math.abs(c.y) > 0 ? Math.sqrt(Math.abs(c.y)) * 2 : 0;
      var x = (0.5 + sx * cx / Math.sqrt(max)) * width;
      var y = (0.5 + sy * cy / Math.sqrt(max)) * height;
      bvg.circle(x, y, radius).fill(0);
      bvg.text(c.title, x + 5, y + 3).fill(0);
    });
  });
};

var loadRoguelikeRelationsAll = function loadRoguelikeRelationsAll() {

  return (0, _util.getJSON)(server_url + "/roguelike/relations-all");
};

var arcYeartoYear = function arcYeartoYear(a, b) {
  var invert = arguments.length <= 2 || arguments[2] === undefined ? -1.0 : arguments[2];

  var x_a = fx(a, start_year, end_year);
  var x_b = fx(b, start_year, end_year);
  var x = (x_a + x_b) / 2;
  var y = 0.5 + 0.01 * invert;
  var rx = Math.abs(x_b - x_a) / 2;
  var ry = rx;
  var startAngle = 0;
  var endAngle = Math.PI * invert;
  return [x, y, rx, ry, startAngle, endAngle];
};

},{"./util":3,"bvg":1}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var promise = exports.promise = function promise(func) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return new Promise(function (resolve, reject) {
    var callback = function callback(error, data) {
      if (error) reject(error);else resolve(data);
    };
    args.push(callback);
    func.apply(func, args);
  });
};

var ratio = exports.ratio = function ratio(min, max, x) {

  return (x - min) / (max - min);
};

var getURL = exports.getURL = function getURL(url) {
  return new Promise(function (resolve, reject) {
    var req = new XMLHttpRequest();
    req.open('GET', url);
    req.onload = function () {
      if (req.status == 200) {
        resolve(req.response);
      } else {
        reject(new Error(req.statusText));
      }
    };
    req.onerror = function () {
      reject(new Error('Network Error'));
    };
    req.send();
  });
};

var getJSON = exports.getJSON = function getJSON(url) {
  return getURL(url).then(JSON.parse).catch(function (err) {
    console.log('getJSON failed to load', url);
    throw err;
  });
};

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnZnL2J2Zy5qcyIsInJvZ3VlbGlrZS1yZWxhdGlvbnMuanMiLCJ1dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM1RSxhQUFPLEVBQUUsS0FBSyxFQUFMLEtBQUssRUFBRSxDQUFDLEVBQUQsQ0FBQyxFQUFFLENBQUMsRUFBRCxDQUFDLEVBQUUsQ0FBQztLQUV4QixDQUFDLENBQUM7O0FBRUgsU0FBSyxDQUFDLE9BQU8sQ0FBRSxVQUFBLENBQUMsRUFBSTtBQUNsQixVQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLE9BQU87QUFDbkMsVUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLFVBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQyxVQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDOUQsVUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxD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TyxDQUFDLFVBQVUsT0FBTyxFQUFFLE1BQU0sRUFBRTtBQUM1QyxRQUFJLEdBQUcsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO0FBQy9CLE9BQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3JCLE9BQUcsQ0FBQyxNQUFNLEdBQUcsWUFBWTtBQUN2QixVQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksR0FBRyxFQUFFO0FBQ3JCLGVBQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDdkIsTUFBTTtBQUNMLGNBQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztPQUNuQztLQUNGLENBQUM7QUFDRixPQUFHLENBQUMsT0FBTyxHQUFHLFlBQVc7QUFDdkIsWUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7S0FDcEMsQ0FBQztBQUNGLE9BQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztHQUNaLENBQUMsQ0FBQztDQUNKLENBQUM7O0FBRUssSUFBTSxPQUFPLFdBQVAsT0FBTyxHQUFHLFNBQVYsT0FBTyxDQUFJLEdBQUcsRUFBSztBQUM5QixTQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsRUFBRTtBQUN2RCxXQUFPLENBQUMsR0FBRyxDQUFDLHdCQUF3QixFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzNDLFVBQU0sR0FBRyxDQUFDO0dBQ1gsQ0FBQyxDQUFDO0NBQ0osQ0FBQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5CVkcgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vL1xuLyoqICMgQlZHIC0gQmluZGFibGUgVmVjdG9yIEdyYXBoaWNzXG4gICogKipSZWFsLXRpbWUgZGF0YS1kcml2ZW4gdmlzdWFsaXNhdGlvbiBmb3IgdGhlIHdlYi4qKlxuICAqXG4gICogIVtFeGFtcGxlXShodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vU3BheGUvQlZHLmpzL21hc3Rlci9kZW1vL2luZGV4LmdpZilcbiAgKlxuICAqIExpdmUgZXhhbXBsZTogaHR0cDovL3NwYXhlLmdpdGh1Yi5pby9CVkcuanMvXG4gICpcbiAgKiAqQmluZGFibGUgVmVjdG9yIEdyYXBoaWNzKiB3YXMgYm9ybiBvdXQgb2YgZnJ1c3RyYXRpb24gZm9yIGxhY2sgb2YgYVxuICAqIG1pZGRsZSBsZXZlbCBTVkcgbGlicmFyeS4gW0QzLmpzXShodHRwOi8vZDNqcy5vcmcvKSBhYnN0cmFjdHMgdG9vIG11Y2hcbiAgKiBsb2dpYywgYW5kIFtTVkcuanNdKGh0dHA6Ly9zdmdqcy5jb20vKSBwcm92aWRlcyBvbmx5IGxvdy1sZXZlbCBTVkcgZHJhd2luZy5cbiAgKiBCaW5kYWJsZSBWZWN0b3IgR3JhcGhpY3Mgb2ZmZXJzIFNWRyBlbGVtZW50cyB0aGF0IGNoYW5nZSBhcyB0aGUgZGF0YSBjaGFuZ2UsXG4gICogYW5kIGdpdmVzIHlvdSB0b29scyB0byBjb250cm9sIHRoZWlyIGxvb2suXG4gICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKiBUaGUgaGVhcnQgb2YgdGhpcyBsaWJyYXJ5IGlzIGEgdHJpbml0eTogKipTVkcgKyBEYXRhICsgQmluZGluZyoqLiBUaGlzXG4gICogY29ubmVjdHMgeW91ciBkYXRhIHRvIHRoZSBTVkcgZWxlbWVudCB0aHJvdWdoIHRoZSBiaW5kaW5nIGZ1bmN0aW9uLCB3aGljaFxuICAqIGNyZWF0ZXMgYSBsaXZpbmcgY29ubmVjdGlvbiB0aGF0IGNhbiByZWFjdCB0byBjaGFuZ2UuIEJWRyB1c2VzXG4gICogW2BPYmplY3Qub2JzZXJ2ZSgpYF0oaHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PW9iamVjdC1vYnNlcnZlKSB3aGljaCBpc1xuICAqIGF2YWlsYWJsZSBvbiBDaHJvbWUgMzYrLCBPcGVyYSAyNysgYW5kIEFuZHJvaWQgQnJvd3NlciAzNysuXG4gICpcbiAgKiBJZiB5b3Ugd2lzaCB0byB1c2UgdGhpcyBmb3Igb2xkZXIgYnJvd3NlcnMsIHlvdSBjYW4gcG9seWZpbGwgd2l0aFxuICAqIFtgTWF4QXJ0MjUwMS9PYmplY3Qub2JzZXJ2ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9NYXhBcnQyNTAxL29iamVjdC1vYnNlcnZlKS5cbiAgKlxuICAqICMjIEluc3RhbGxhdGlvblxuICAqXG4gICogKipJbnN0YWxsIHVzaW5nIGBucG1gKio6XG4gICpcbiAgKiAgMS4gSW5zdGFsbCBOb2RlLmpzOiBodHRwczovL2RvY3MubnBtanMuY29tL2dldHRpbmctc3RhcnRlZC9pbnN0YWxsaW5nLW5vZGVcbiAgKiAgMi4gSW4geW91ciB3b3JraW5nIGRpcmVjdG9yeTpcbiAgKlxuICAqICAgICBgYGBcbiAgKiAgICAgbnBtIGluc3RhbGwgYnZnXG4gICogICAgIGBgYFxuICAqXG4gICogKipJbnN0YWxsIHZpYSBHaXRIdWIqKjpcbiAgKlxuICAqICAxLiBDbG9uZSB0aGlzIHJlcG86XG4gICpcbiAgKiAgICAgYGBgXG4gICogICAgIGdpdCBjbG9uZSBodHRwczovL2dpdGh1Yi5jb20vU3BheGUvQlZHLmpzLmdpdFxuICAqICAgICBgYGBcbiAgKlxuICAqICAyLiBDb3B5IGByZXF1aXJlLmpzYCBhbmQgYGJ2Zy5qc2AgaW50byB5b3VyIHdvcmtpbmcgZGlyZWN0b3J5LlxuICAqXG4gICogKipUbyBpbmNsdWRlIGBCVkcuanNgIGluIHlvdXIgd2VicGFnZSoqOlxuICAqXG4gICogIDEuIEluIHlvdXIgSFRNTCBgPGhlYWQ+YCwgaW5jbHVkZSB0aGlzIHNjcmlwdCB1c2luZyBgcmVxdWlyZS5qc2A6XG4gICpcbiAgKiAgICAgYGBgSFRNTFxuICAqICAgICA8c2NyaXB0IHNyYz1cInBhdGgvdG8vcmVxdWlyZS5qc1wiIGRhdGEtbWFpbj1cInlvdXItc2NyaXB0LmpzXCI+PC9zY3JpcHQ+XG4gICogICAgIGBgYFxuICAqXG4gICogIDIuIEluIGB5b3VyLXNjcmlwdC5qc2AsIGRlZmluZSB5b3VyIG93biBjb2RlIHdpdGhcbiAgKlxuICAqICAgICBgYGBKYXZhc2NyaXB0XG4gICogICAgIHJlcXVpcmUoWydwYXRoL3RvL2J2Zy5qcyddLCBmdW5jdGlvbiAoQlZHKSB7XG4gICogICAgICAgLy8geW91ciBjb2RlIGdvZXMgaGVyZSAuLi5cbiAgKiAgICAgfSk7XG4gICogICAgIGBgYFxuICAqXG4gICogIyMgUXVpY2tzdGFydFxuICAqXG4gICogIVtRdWlja3N0YXJ0IEV4YW1wbGVdKGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9TcGF4ZS9CVkcuanMvbWFzdGVyL2RlbW8vMDAxLWhlbGxvLmdpZilcbiAgKlxuICAqIEhUTUw6XG4gICpcbiAgKiBgYGBIVE1MXG4gICogPGRpdiBpZD1cImJ2Zy1jb250YWluZXJcIj48L2Rpdj5cbiAgKiBgYGBcbiAgKlxuICAqIENTUyAoTWFrZSB0aGUgY29udGFpbmVyIGxhcmdlIGVub3VnaCk6XG4gICpcbiAgKiBgYGBDU1NcbiAgKiBodG1sLCBib2R5LCAjYnZnLWNvbnRhaW5lciB7XG4gICogICBoZWlnaHQ6IDEwMCU7XG4gICogICBtYXJnaW46IDA7XG4gICogfVxuICAqIGBgYFxuICAqXG4gICogSmF2YXNjcmlwdDpcbiAgKlxuICAqIGBgYEphdmFzY3JpcHRcbiAgKiAvLyBDcmVhdGUgYSBCVkcgY29udGFpbmVyIGJhc2VkIG9uIHNlbGVjdGVkIEhUTUwgZWxlbWVudFxuICAqIHZhciBidmcgPSBCVkcuY3JlYXRlKCcjYnZnLWNvbnRhaW5lcicpO1xuICAqIC8vIENyZWF0ZSBhIEJpbmRhYmxlIGNpcmNsZSwgY29sb3VyIGl0IG9yYW5nZVxuICAqIHZhciBjaXJjbGUgPSBidmcuZWxsaXBzZSgwLCAwLCAxNTAsIDE1MClcbiAgKiAgICAgICAgICAgICAgICAgLmZpbGwoMjIwLCA2NCwgMTIpO1xuICAqIC8vIENoYW5nZSBpdHMgc2l6ZSBiYXNlZCBvbiBtb3VzZSBtb3ZlbWVudFxuICAqIGJ2Zy50YWcoKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgKiAgIGNpcmNsZS5kYXRhKHtcbiAgKiAgICAgcng6IGV2ZW50LmNsaWVudFgsXG4gICogICAgIHJ5OiBldmVudC5jbGllbnRZXG4gICogICB9KTtcbiAgKiB9KTtcbiAgKiBgYGBcbiAgKi9cblxuLyotIERlZXAgT2JqZWN0Lm9ic2VydmUoKSAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQlZHO1xuZnVuY3Rpb24gb2JzZXJ2ZShvYmosIGNhbGxiYWNrKSB7XG5cbiAgLy8gSW5jbHVkZSBodHRwczovL2dpdGh1Yi5jb20vTWF4QXJ0MjUwMS9vYmplY3Qtb2JzZXJ2ZSBpZiB5b3Ugd2lzaCB0byB3b3JrXG4gIC8vIHdpdGggcG9seWZpbGwgb24gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IE9iamVjdC5vYnNlcnZlKClcbiAgT2JqZWN0Lm9ic2VydmUob2JqLCBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgIGNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG5cbiAgICAgIC8vIEJpbmQgY2hpbGQgcHJvcGVydHkgaWYgaXQgaXMgYW4gb2JqZWN0IGZvciBkZWVwIG9ic2VydmluZ1xuICAgICAgaWYgKG9ialtjaGFuZ2UubmFtZV0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgb2JzZXJ2ZShvYmpbY2hhbmdlLm5hbWVdLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUcmlnZ2VyIHVzZXIgY2FsbGJhY2tcbiAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGNoYW5nZXMpO1xuICB9KTtcblxuICAvLyBJbW1lZGlhdGVseSBmaXJlIG9ic2VydmUgdG8gaW5pdGlhdGUgZGVlcCBvYnNlcnZpbmdcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIG9ic2VydmUob2JqW2tleV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKi0gYEJWRyh0YWcsIGRhdGEsIGJpbmRpbmcpYFxuICAqIFRoZSB0cmluaXR5IG9mIHRoaXMgbGlicmFyeTogU1ZHICsgRGF0YSArIEJpbmRpbmcgRnVuY3Rpb24uXG4gICpcbiAgKiBSZXR1cm4gdGhlIEJWRyBvYmplY3QgY3JlYXRlZC5cbiAgKlxuICAqICAtIGB0YWdgICAgIDogRWl0aGVyIGEgYFN0cmluZ2AgZm9yIHRoZSBTVkcgYHRhZ05hbWVgIG9yIGFueSBbYFNWR0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudClcbiAgKiAgLSBgZGF0YWAgICA6IE9iamVjdCB3aXRoIGFyYml0cmFyeSBkYXRhIHRvIHlvdXIgZGVzaXJlXG4gICogIC0gYGJpbmRpbmdgOiAob3B0aW9uYWwpIEJpbmRpbmcgZnVuY3Rpb24gdGhhdCBzZXRzIHRoZSB0YWcgYXR0cmlidXRlc1xuICAqL1xuZnVuY3Rpb24gQlZHKHRhZywgZGF0YSwgYmluZGluZykge1xuICB2YXIgYnZnID0gdGhpcztcbiAgdGFnID0gdGFnIGluc3RhbmNlb2YgU1ZHRWxlbWVudCA/IHRhZyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0YWcpO1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgYmluZGluZyA9IGJpbmRpbmcgfHwgZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgIGZvciAodmFyIHByb3AgaW4gZGF0YSkge1xuICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgdGFnLnNldEF0dHJpYnV0ZShwcm9wLCBkYXRhW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gT2JzZXJ2ZSBkYXRhIG9iamVjdCBhbmQgYXBwbHkgYmluZGluZyByaWdodCBhd2F5XG4gIG9ic2VydmUoZGF0YSwgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICBiaW5kaW5nKHRhZywgZGF0YSk7XG4gIH0pO1xuICBiaW5kaW5nKHRhZywgZGF0YSk7XG5cbiAgLy8gSUQgZnVuY3Rpb24gZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9nb3Jkb25icmFuZGVyLzIyMzAzMTdcbiAgdGFnLnNldEF0dHJpYnV0ZSgnaWQnLCAnQlZHXycgKyB0YWcudGFnTmFtZSArICdfJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA3KSk7XG4gIHRoaXMuX3RhZyA9IHRhZztcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIHRoaXMuX2JpbmRpbmcgPSBiaW5kaW5nO1xuXG4gIC8vIEZ1bmN0aW9uYWwgY2lyY3VsYXIgcmVmZXJlbmNlXG4gIHRoaXMuX3RhZy5fZ2V0QlZHID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBidmc7XG4gIH07XG5cbiAgaWYgKFsnc3ZnJywgJ2cnLCAnYSddLmluZGV4T2YodGFnLnRhZ05hbWUpIDwgMCkge1xuICAgIGlmICghZGF0YS5zdHJva2UpIHRoaXMuc3Ryb2tlKDE3NSk7XG4gICAgaWYgKCFkYXRhLnN0cm9rZVdpZHRoKSB0aGlzLnN0cm9rZVdpZHRoKDAuNSk7XG4gICAgaWYgKCFkYXRhLmZpbGwpIHRoaXMubm9GaWxsKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiAjIyBUaGUgQlZHIENvbnRhaW5lclxuICAqIFRoZSByZXN0IG9mIHRoZSBkb2N1bWVudGF0aW9uIHdpbGwgYXNzdW1lIGBidmdgIGFzIG91ciBCVkcgY29udGFpbmVyXG4gICogY3JlYXRlZCBieSB0aGUgZXhhbXBsZSBiZWxvdy5cbiAgKi9cblxuLyoqICMjIyBgQlZHLmNyZWF0ZShodG1sRWxlbWVudClgXG4gICogQ3JlYXRlIGEgQlZHIGNvbnRhaW5lciBpbnNpZGUgYGh0bWxFbGVtZW50YC5cbiAgKlxuICAqIFJldHVybiB0aGUgQlZHIGNvbnRhaW5lciBvYmplY3QuXG4gICpcbiAgKiAgLSBgaHRtbEVsZW1lbnRgICA6IEVpdGhlciBhIFtDU1MgU2VsZWN0b3JdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0NTUy9HZXR0aW5nX1N0YXJ0ZWQvU2VsZWN0b3JzKVxuICAqICAgICAgICAgICAgICAgICAgICAgb3IgYW55IFtIVE1MRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50KS5cbiAgKlxuICAqIGBgYEphdmFzY3JpcHRcbiAgKiAvLyBDcmVhdGUgYSBuZXcgQlZHIGNvbnRhaW5lciBhbmQgYXBwZW5kIGl0IHRvIGFuIGV4aXN0aW5nIEhUTUwgZWxlbWVudC5cbiAgKiB2YXIgYnZnID0gQlZHLmNyZWF0ZSgnI2J2Zy1jb250YWluZXInKTtcbiAgKiBgYGBcbiAgKi9cbnZhciBjcmVhdGUgPSBleHBvcnRzLmNyZWF0ZSA9IEJWRy5jcmVhdGUgPSBmdW5jdGlvbiAoaHRtbEVsZW1lbnQsIHhEaW1lbnNpb24sIHlEaW1lbnNpb24pIHtcbiAgaWYgKHR5cGVvZiBodG1sRWxlbWVudCA9PT0gJ3N0cmluZycpIGh0bWxFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihodG1sRWxlbWVudCk7XG4gIGlmICghKGh0bWxFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdodG1sRWxlbWVudCAoJyArIGh0bWxFbGVtZW50ICsgJykgd2FzIG5vdCBmb3VuZC4nKTtcblxuICB2YXIgZGF0YSA9IHtcbiAgICAneG1sbnM6eGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgdmVyc2lvbjogMS4xLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJSdcbiAgfTtcbiAgeURpbWVuc2lvbiA9IHlEaW1lbnNpb24gfHwgeERpbWVuc2lvbjtcbiAgaWYgKHhEaW1lbnNpb24pIHtcbiAgICBkYXRhLnZpZXdCb3ggPSBbMCwgMCwgeERpbWVuc2lvbiwgeURpbWVuc2lvbl0uam9pbignICcpO1xuICB9XG5cbiAgdmFyIGJ2ZyA9IG5ldyBCVkcoJ3N2ZycsIGRhdGEpO1xuICBodG1sRWxlbWVudC5hcHBlbmRDaGlsZChidmcudGFnKCkpO1xuICByZXR1cm4gYnZnO1xufTtcblxuLyoqICMjIEJWRyBFbGVtZW50c1xuICAqIEFsbCBCVkcgb2JqZWN0cywgaW5jbHVkaW5nIHRoZSBjb250YWluZXIsIGhhdmUgYWNjZXNzIHRvIGRyYXdpbmcgZnVuY3Rpb25zXG4gICogYW5kIHJldHVybiByZWZlcmVuY2UgdG8gdGhlIG5ldyBzaGFwZSwgd2hpY2ggaXMgYWxzbyBhIEJWRy5cbiAgKlxuICAqIGBgYEphdmFzY3JpcHRcbiAgKiAvLyBDcmVhdGUgYSByZWN0YW5nbGUgYXQgKDAsIDApIHdpdGggZGltZW5zaW9ucyAxMDB4MTAwIHB4IGFuZCBhZGQgaXQgdG8gYnZnXG4gICogdmFyIHJlY3QgPSBidmcucmVjdCgwLCAwLCAxMDAsIDEwMCk7XG4gICogYGBgXG4gICpcbiAgKiBUaGUgQlZHIG1vZHVsZSBhbHNvIGhhcyBkcmF3aW5nIGZ1bmN0aW9ucywgd2hpY2ggcmV0dXJuIHRoZSBCVkcgb2JqZWN0OlxuICAqXG4gICogYGBgSmF2YXNjcmlwdFxuICAqIC8vIENyZWF0ZSBhIHJlY3RhbmdsZSBhdCAoMCwgMCkgd2l0aCBkaW1lbnNpb25zIDEwMHgxMDAgcHhcbiAgKiAvLyBOb3RlIGl0IHVzZXMgdGhlIEJWRyBtb2R1bGUgZGlyZWN0bHkgdG8gY3JlYXRlIHRoZSByZWN0YW5nbGUuXG4gICogdmFyIHJlY3QgPSBCVkcucmVjdCgwLCAwLCAxMDAsIDEwMCk7XG4gICogLy8gQWRkIHRoZSByZWN0YW5nbGUgdG8gYW4gZXhpc3RpbmcgQlZHIGNvbnRhaW5lclxuICAqIGJ2Zy5hcHBlbmQocmVjdCk7XG4gICogYGBgXG4gICpcbiAgKiBEcmF3aW5nIGZ1bmN0aW9ucyBjYW4gYmUgY2FsbGVkIGluIGEgbnVtYmVyIG9mIHdheXMuIFRha2UgYGJ2Zy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpYFxuICAqIGFzIGFuIGV4YW1wbGUgYmVsb3cuIFNvbWV0aW1lcyBpdCBpcyBlYXNpZXIgdG8gdXNlIG9uZSBvdmVyIGFub3RoZXIgc3R5bGUuXG4gICpcbiAgKiBgYGBKYXZhc2NyaXB0XG4gICogYnZnLnJlY3QoMCwgMTAsIDMwLCA3MCk7ICAgICAgLy8gQXJndW1lbnRzIHN0eWxlXG4gICogYnZnLnJlY3QoeyAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IHN0eWxlXG4gICogICB4OiAwLFxuICAqICAgeTogMTAsICAgICAgICAgICAgICAgICAgICAgIC8vIE5hbWUgb2YgdGhlIG9iamVjdCBwcm9wZXJ0aWVzIG11c3QgbWF0Y2hcbiAgKiAgIHdpZHRoOiAzMCwgICAgICAgICAgICAgICAgICAvLyBuYW1lcyBvZiB0aGUgYXJndW1lbnRzIGluIHRoZSBmdW5jdGlvbnMsXG4gICogICBoZWlnaHQ6IDcwICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoZSBvcmRlciBjYW4gYmUgYW55LlxuICAqIH0pO1xuICAqIGBgYFxuICAqL1xudmFyIGNyZWF0aW9uRnVuY3Rpb25zID0ge1xuICBzdmc6IGZ1bmN0aW9uIHN2Zyh4bGluaywgdmVyc2lvbiwgd2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiBuZXcgQlZHKCdzdmcnLCB4bGluay5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHhsaW5rIDoge1xuICAgICAgJ3htbG5zOnhsaW5rJzogeGxpbmssXG4gICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KTtcbiAgfSxcblxuICAvKiogIyMjIGBidmcucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KWBcbiAgICAqIENyZWF0ZSBhIHJlY3RhbmdsZSBhdCBwb3NpdGlvbiBgKHgsIHkpYCBhdCBgd2lkdGhgIHggYGhlaWdodGAgaW4gc2l6ZS5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiB2YXIgcmVjdCA9IGJ2Zy5yZWN0KDEwMCwgMTAwLCAzMDAsIDE1MCk7XG4gICAgKiBgYGBcbiAgICAqL1xuICByZWN0OiBmdW5jdGlvbiByZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gbmV3IEJWRygncmVjdCcsIHguY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyB4IDoge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKiAjIyMgYGJ2Zy5jaXJjbGUoY3gsIGN5LCByKWBcbiAgICAqIENyZWF0ZSBhIGNpcmNsZSBjZW50cmVkIG9uIGAoY3gsIGN5KWAgd2l0aCByYWRpdXMgYHJgLlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIHZhciBjaXJjbGUgPSBidmcuZWxsaXBzZSgxMDAsIDEwMCwgNTApO1xuICAgICogYGBgXG4gICAgKi9cbiAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUoeCwgeSwgcikge1xuICAgIHJldHVybiBuZXcgQlZHKCdjaXJjbGUnLCB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8geCA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgcjogclxuICAgIH0sIGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ2N4JywgZGF0YS54KTtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ2N5JywgZGF0YS55KTtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3InLCBkYXRhLnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKiAjIyMgYGJ2Zy5lbGxpcHNlKGN4LCBjeSwgcngsIHJ5KWBcbiAgICAqIENyZWF0ZSBhIGVsbGlwc2UgY2VudHJlZCBvbiBgKGN4LCBjeSlgIHdpdGggcmFkaWkgYHJ4YCBhbmQgYHJ5YC5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiB2YXIgZWxsaXBzZSA9IGJ2Zy5lbGxpcHNlKDEwMCwgMTAwLCAyMDAsIDE4MCk7XG4gICAgKiBgYGBcbiAgICAqL1xuICBlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKHgsIHksIHJ4LCByeSkge1xuICAgIHJldHVybiBuZXcgQlZHKCdlbGxpcHNlJywgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHggOiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHJ4OiByeCxcbiAgICAgIHJ5OiByeVxuICAgIH0sIGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ2N4JywgZGF0YS54KTtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ2N5JywgZGF0YS55KTtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3J4JywgZGF0YS5yeCk7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCdyeScsIGRhdGEucnkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKiAjIyMgYGJ2Zy5saW5lKHgxLCB5MSwgeDIsIHkyKWBcbiAgICAqIENyZWF0ZSBhIGxpbmUgZnJvbSBgKHgxLCB5MSlgIHRvIGAoeDIsIHkyKWAuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogdmFyIGxpbmUgPSBidmcubGluZSgxMDAsIDEwMCwgMjAwLCAzMDApO1xuICAgICogYGBgXG4gICAgKi9cbiAgbGluZTogZnVuY3Rpb24gbGluZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBuZXcgQlZHKCdsaW5lJywgeDEuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyB4MSA6IHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHkxOiB5MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIHkyOiB5MlxuICAgIH0pO1xuICB9LFxuICAvKiogIyMjIGBidmcucG9seWxpbmUoW1t4MSwgeTFdLCBbeDIsIHkyXSwgLi4uXSlgXG4gICAgKiBDcmVhdGUgYSBzZXJpZXMgb2YgbGluZXMgZnJvbSBwb2ludCB0byBwb2ludC5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiB2YXIgcG9seWxpbmUgPSBidmcucG9seWxpbmUoW1sxMDAsIDIwMF0sIFsyMDAsIDMwMF0sIFs0MDAsIDgwMF1dKTtcbiAgICAqIGBgYFxuICAgICovXG4gIHBvbHlsaW5lOiBmdW5jdGlvbiBwb2x5bGluZShwb2ludHMpIHtcbiAgICByZXR1cm4gbmV3IEJWRygncG9seWxpbmUnLCBwb2ludHMuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyBwb2ludHMgOiB7XG4gICAgICBwb2ludHM6IHBvaW50c1xuICAgIH0sIGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3BvaW50cycsIGRhdGEucG9pbnRzLmpvaW4oJyAnKSk7XG4gICAgfSk7XG4gIH0sXG4gIC8qKiAjIyMgYGJ2Zy5wb2x5Z29uKFtbeDEsIHkxXSwgW3gyLCB5Ml0sIC4uLl0pYFxuICAgICogQ3JlYXRlIGEgY2xvc2VkIHBvbHlnb24gZnJvbSBwb2ludCB0byBwb2ludC4gVGhlIGxhc3QgcG9pbnQgd2lsbCBiZVxuICAgICogY29ubmVjdGVkIGJhY2sgdG8gdGhlIGZpcnN0IHBvaW50LlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIHZhciBwb2x5Z29uID0gYnZnLnBvbHlnb24oW1sxMDAsIDIwMF0sIFsyMDAsIDMwMF0sIFs0MDAsIDgwMF1dKTtcbiAgICAqIGBgYFxuICAgICovXG4gIHBvbHlnb246IGZ1bmN0aW9uIHBvbHlnb24ocG9pbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ3BvbHlnb24nLCBwb2ludHMuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyBwb2ludHMgOiB7XG4gICAgICBwb2ludHM6IHBvaW50c1xuICAgIH0sIGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3BvaW50cycsIGRhdGEucG9pbnRzLmpvaW4oJyAnKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqICMjIEdyb3VwaW5nIEVsZW1lbnRzXG4gICAgKiAjIyMgYGJ2Zy5ncm91cChbdHJhbnNmb3JtXSlgXG4gICAgKlxuICAgICogQ3JlYXRlIGEgZ3JvdXAgdG8gY29udGFpbiBCVkcgb2JqZWN0cy4gSXQgYWN0cyBsaWtlIGEgQlZHIGNvbnRhaW5lciB3aXRoXG4gICAgKiBhbiBvcHRpb25hbCBgdHJhbnNmb3JtYCBhdHRyaWJ1dGUuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogLy8gQ3JlYXRlIGEgbmV3IGdyb3VwIGFuZCBmaWxsIGl0IHdpdGggZGFzaGVzLlxuICAgICogdmFyIGRhc2hlcyA9IGJ2Zy5ncm91cCgpO1xuICAgICogZm9yIChpbnQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAqICAgZGFoc2VzLnJlY3QoMTAsIDEwICsgaSAqIDMwLCA1MCwgMjApO1xuICAgICogfVxuICAgICogYGBgXG4gICAgKi9cbiAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBuZXcgQlZHKCdnJywgdHJhbnNmb3JtLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8gdHJhbnNmb3JtIDoge1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgICB9KTtcbiAgfSxcblxuICAvKiogIyMgSHlwZXJsaW5rc1xuICAgICogIyMjIGBidmcuaHlwZXJsaW5rKHVybClgXG4gICAgKlxuICAgICogQ3JlYXRlIGEgaHlwZXJsaW5rIEJWRyB0byB0YXJnZXQgVVJMIGB1cmxgLiBJdCBkb2VzIG5vdCBoYXZlIGFueSBkaXNwbGF5XG4gICAgKiBlbGVtZW50cy4gTWFrZSBzdXJlIHRvIGFwcGVuZCBlbGVtZW50cyB0byBpdC5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiAvLyBDbGlja2luZyBvbiB0aGlzIGVsZW1lbnQgd2lsbCBicmluZyB0aGVtIHRvIHRoZSBHaXRodWIgcGFnZVxuICAgICogdmFyIGdpdGh1YkxpbmsgPSBidmcuaHlwZXJsaW5rKCdodHRwczovL2dpdGh1Yi5jb20vc3BheGUvQlZHLmpzJyk7XG4gICAgKiAvLyBNYWtlIGEgYnV0dG9uIGFuZCBhdHRhY2sgaXQgdG8gdGhlIGxpbmtcbiAgICAqIGdpdGh1YkxpbmsuZWxsaXBzZSgyMDAsIDIwMCwgNTAsIDUwKTtcbiAgICAqIGBgYFxuICAgICovXG4gIGh5cGVybGluazogZnVuY3Rpb24gaHlwZXJsaW5rKHVybCkge1xuICAgIHJldHVybiBuZXcgQlZHKCdhJywgdXJsLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8gdXJsIDoge1xuICAgICAgJ3htbG5zOmhyZWYnOiB1cmxcbiAgICB9KTtcbiAgfSxcblxuICAvKiogIyMgT3RoZXIgR2VvbWV0cnlcbiAgICAqICMjIyBgYnZnLnRyaWFuZ2xlKGN4LCBjeSwgcilgXG4gICAgKiBDcmVhdGUgYSByZWd1bGFyIHRyaWFuZ2xlIGNlbnRyZWQgb24gYChjeCwgY3kpYCB3aXRoIHZlcnRpY2VzIGByYCBkaXN0YW5jZVxuICAgICogYXdheS5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiB2YXIgdHJpYW5nbGUgPSBidmcudHJpYW5nbGUoNTAsIDUwLCAxMCk7XG4gICAgKiBgYGBcbiAgICAqL1xuICB0cmlhbmdsZTogZnVuY3Rpb24gdHJpYW5nbGUoeCwgeSwgcikge1xuICAgIHJldHVybiBuZXcgQlZHKCdwb2x5Z29uJywgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHggOiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHI6IHJcbiAgICB9LCBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW1tkYXRhLngsIGRhdGEueSAtIGRhdGEucl0sIFtkYXRhLnggLSBkYXRhLnIgLyAyICogTWF0aC5zcXJ0KDMpLCBkYXRhLnkgKyBkYXRhLnIgLyAyXSwgW2RhdGEueCArIGRhdGEuciAvIDIgKiBNYXRoLnNxcnQoMyksIGRhdGEueSArIGRhdGEuciAvIDJdXTtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3BvaW50cycsIHBvaW50cy5qb2luKCcgJykpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKiAjIyMgYGJ2Zy5hcmMoY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKWBcbiAgICAqIENyZWF0ZSBhbiBhcmMgY2VudHJlZCBvbiBgKGN4LCBjeSlgIHdpdGggcmFkaXVzIGByeGAgYW5kIGByeWAsIHN0YXJ0aW5nXG4gICAgKiBmcm9tIGBzdGFydEFuZ2xlYCBhbnRpLWNsb2Nrd2lzZSB0byBgZW5kQW5nbGVgLCB3aGVyZSAwIGlzIHRoZSBwb3NpdGl2ZVxuICAgICogeC1heGlzLlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIHZhciBhcmMgPSBidmcuYXJjKDUwLCA1MCwgNTAsIDEwMCwgMCwgTWF0aC5QSSk7XG4gICAgKiBgYGBcbiAgICAqL1xuICBhcmM6IGZ1bmN0aW9uIGFyYyh4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ3BhdGgnLCB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8geCA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgcng6IHJ4LFxuICAgICAgcnk6IHJ5LFxuICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgIH0sIGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICAgIHZhciBwMSA9IGdldFBvaW50T25FbGxpcHNlKGRhdGEueCwgZGF0YS55LCBkYXRhLnJ4LCBkYXRhLnJ5LCBkYXRhLnN0YXJ0QW5nbGUpO1xuICAgICAgdmFyIHAyID0gZ2V0UG9pbnRPbkVsbGlwc2UoZGF0YS54LCBkYXRhLnksIGRhdGEucngsIGRhdGEucnksIGRhdGEuZW5kQW5nbGUpO1xuICAgICAgdmFyIGxhcmdlQXJjID0gZGF0YS5lbmRBbmdsZSAtIGRhdGEuc3RhcnRBbmdsZSA+IE1hdGguUEkgPyAxIDogMDtcbiAgICAgIHZhciBzd2VlcEFyYyA9IGRhdGEuZW5kQW5nbGUgPiBkYXRhLnN0YXJ0QW5nbGUgPyAxIDogMDtcbiAgICAgIHZhciBkID0gW1snTScsIHAxLngsIHAxLnldLCBbJ0EnLCBkYXRhLnJ4LCBkYXRhLnJ5LCAwLCBsYXJnZUFyYywgc3dlZXBBcmMsIHAyLngsIHAyLnldXTtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ2QnLCBkLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5qb2luKCcgJyk7XG4gICAgICB9KS5qb2luKCcgJykpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRQb2ludE9uRWxsaXBzZSh4LCB5LCByeCwgcnksIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcnggKiBNYXRoLmNvcyhhbmdsZSkgKyB4LFxuICAgICAgICAgIHk6IHJ5ICogTWF0aC5zaW4oYW5nbGUpICsgeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKiAjIyMgYGJ2Zy50ZXh0KHRleHQsIHgsIHkpYFxuICAgICogQ3JlYXRlIGEgc3RyaW5nIG9mIGB0ZXh0YCB0ZXh0IGF0IGxvY2F0aW9uIGAoeCwgeSlgLlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIHZhciB0ZXh0ID0gYnZnLnRleHQoJ01ycmFhIScsIDIwLCAxMCk7XG4gICAgKiBgYGBcbiAgICAqL1xuICB0ZXh0OiBmdW5jdGlvbiB0ZXh0KF90ZXh0LCB4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ3RleHQnLCBfdGV4dC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IF90ZXh0IDoge1xuICAgICAgdGV4dDogX3RleHQsXG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0sIGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICAgIHRhZy5pbm5lckhUTUwgPSBkYXRhLnRleHQ7XG4gICAgICB0YWcuc2V0QXR0cmlidXRlKCd4JywgZGF0YS54KTtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3knLCBkYXRhLnkpO1xuICAgIH0pLmZpbGwoJ3JnYmEoMTc1LCAxNzUsIDE3NSwgMSknKS5zdHJva2UoJ3JnYmEoMCwgMCwgMCwgMCknKTtcbiAgfVxufTtcblxuT2JqZWN0LmtleXMoY3JlYXRpb25GdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgQlZHW2ZdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGlvbkZ1bmN0aW9uc1tmXS5hcHBseShCVkcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIEJWRy5wcm90b3R5cGVbZl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ2ZyA9IGNyZWF0aW9uRnVuY3Rpb25zW2ZdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5hcHBlbmQoYnZnKTtcbiAgICByZXR1cm4gYnZnO1xuICB9O1xufSk7XG5cbi8qKiAjIyBUaGUgQlZHIE9iamVjdFxuICAqIEJWR3MgYXJlIFNWR3Mgd2l0aCBleHRyYSBzdXBlcnBvd2Vycy5cbiAgKi9cblxuLyoqICMjIyBgYnZnLmZpbmQoc2VsZWN0b3IpYFxuICAqIFJldHVybiBhbiBhcnJheSBvZiBCVkdzIG1hdGNoaW5nIGBzZWxlY3RvcmAgaW5zaWRlIEJWRy4gYHNlbGVjdG9yYCBpc1xuICAqIGRlZmluZWQgYXMgW0NTUyBTZWxlY3RvcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0NTUy9HZXR0aW5nX3N0YXJ0ZWQvU2VsZWN0b3JzKS5cbiAgKi9cbkJWRy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fdGFnLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdmFyIGJ2Z3MgPSBbXTtcbiAgICBbXS5zbGljZS5jYWxsKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgYnZncy5wdXNoKHIuX2dldEJWRygpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnZncztcbiAgfVxuICByZXR1cm4gW107XG59O1xuXG4vKiogIyMjIGBidmcuYXBwZW5kKGJ2ZylgXG4gICogSW5zZXJ0IGBjaGlsZF9idmdgIGluc2lkZSBgYnZnYC4gVGhpcyBpcyB1c2VmdWwgdG8gYWRkIGVsZW1lbnRzIGluc2lkZSBhXG4gICogYEJWRy5ncm91cCgpYC5cbiAgKi9cbkJWRy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGNoaWxkX2J2Zykge1xuICB0aGlzLl90YWcuYXBwZW5kQ2hpbGQoY2hpbGRfYnZnLl90YWcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiAjIyMgYGJ2Zy5yZW1vdmUoKWBcbiAgKiBSZW1vdmUgaXRzZWxmIGZyb20gaXRzIHBhcmVudC4gUmV0dXJuIHNlbGYgcmVmZXJlbmNlLlxuICAqL1xuQlZHLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50Ll90YWcucmVtb3ZlQ2hpbGQodGhpcy5fdGFnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiAjIyMgYGJ2Zy5wYXJlbnQoKWBcbiAgKiBSZXR1cm4gdGhlIHBhcmVudCBCVkcuIElmIHRoZXJlIGlzIG5vIHBhcmVudCAoc3VjaCBpcyB0aGUgY2FzZSBmb3IgdGhlIEJWR1xuICAqIGNvbnRhaW5lciBpdHNlbGYpLCByZXR1cm4gbnVsbC5cbiAgKi9cbkJWRy5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fdGFnLnBhcmVudE5vZGUgJiYgdHlwZW9mIHRoaXMuX3RhZy5wYXJlbnROb2RlLl9nZXRCVkcgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLl90YWcucGFyZW50Tm9kZS5fZ2V0QlZHKCk7XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqICMjIyBgYnZnLmNoaWxkcmVuKClgXG4gICogUmV0dXJuIGEgbGlzdCBvZiBCVkcgZWxlbWVudHMgaW5zaWRlIGBidmdgLlxuICAqL1xuQlZHLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RhZy5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl90YWcuY2hpbGROb2Rlc1tpXS5fZ2V0QlZHID09PSAnZnVuY3Rpb24nKSBvdXRwdXQucHVzaCh0aGlzLl90YWcuY2hpbGROb2Rlc1tpXS5fZ2V0QlZHKCkpO1xuICB9cmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKiAjIyMgYGJ2Zy50YWcoKWBcbiAgKiBSZXR1cm4gdGh3IEJWRyBncmFwaGljYWwgY29udGVudCwgYSBTVkcuXG4gICovXG5CVkcucHJvdG90eXBlLnRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3RhZztcbn07XG5cbi8qKiAjIyMgYGJ2Zy5kYXRhKClgXG4gKiBHZXQvc2V0IHRoZSBgZGF0YWAgb2JqZWN0IGluIGEgQlZHLiBUaGVyZSBhcmUgZm91ciB3YXlzIHRvIHVzZSB0aGlzXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiAgLSBgYnZnLmRhdGEoKWA6IFJldHVybiBgZGF0YWAgYm91bmQgdG8gdGhlIEJWRy5cbiAqICAtIGBidmcuZGF0YShuZXdEYXRhKWA6IFVwZGF0ZSBgZGF0YWAgd2l0aCBgbmV3RGF0YWAgb2JqZWN0LlxuICogIC0gYGJ2Zy5kYXRhKHByb3BlcnR5KWA6IFJldHVybiBgZGF0YVtwcm9wZXJ0eV1gIGZyb20gdGhlIEJWRy5cbiAqICAtIGBidmcuZGF0YShwcm9wZXJ0eSwgbmV3VmFsdWUpYDogVXBkYXRlIGBwcm9wZXJ0eWAgd2l0aCBgbmV3VmFsdWVgLlxuICpcbiAqIFJldHVybiBgYnZnYCBvYmplY3QgcmVmZXJlbmNlLlxuICovXG5CVkcucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0uY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0uaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICB0aGlzLmRhdGEoaywgYXJndW1lbnRzWzBdW2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhW2FyZ3VtZW50c1swXV07XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0aGlzLl9kYXRhW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IodGhpcywgJ2RhdGEoKSByZWNlaXZlZCBtb3JlIHRoYW4gMiBhcmd1bWVudHMuJyk7XG4gIH1cbn07XG5cbi8qKiAjIyMgYGJ2Zy5hdHRyKClgXG4gICogR2V0L3NldCBhdHRyaWJ1dGVzIG9uIGEgQlZHLlxuICAqXG4gICogIC0gYGJ2Zy5hdHRyKGF0dHIpYDogUmV0dXJuIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgKiAgLSBgYnZnLmF0dHIoYXR0ciwgdmFsdWUpYDogVXBkYXRlIGBhdHRyYCB3aXRoIGB2YWx1ZWAuXG4gICovXG5CVkcucHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbiAoYXR0ciwgdmFsdWUpIHtcbiAgaWYgKCFhdHRyKSB0aHJvdyBuZXcgRXJyb3IoJ2F0dHIgbXVzdCBiZSBkZWZpbmVkJyk7XG4gIGlmICghdmFsdWUpIHJldHVybiB0aGlzLl90YWcuZ2V0QXR0cmlidXRlKGF0dHIpO2Vsc2UgdGhpcy5fdGFnLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqICMjIyBgYnZnLmZpbGwoKWBcbiAgKiBHZXQvc2V0IHRoZSBmaWxsaW5nIGNvbG91ci5cbiAgKlxuICAqICAtIGBidmcuZmlsbCgpYDogUmV0dXJuIGBmaWxsYCBjb2xvdXIgYXMgW3IsIGcsIGIsIGFdLCBvciBgJydgIChlbXB0eVxuICAqICAgICAgICAgICAgICAgICAgc3RyaWcpIGlmIGZpbGwgaXMgbm90IHNwZWNpZmllZCBvbiB0aGUgb2JqZWN0LlxuICAqICAtIGBidmcuZmlsbChyZ2IpYDogU2V0IGBmaWxsYCB3aXRoIGEgZ3JleXNjYWxlIGNvbG91ciB3aXRoIGVxdWFsXG4gICogICAgdmFsdWVzIGAocmdiLCByZ2IsIHJnYilgLlxuICAqICAtIGBidmcuZmlsbChyLCBnLCBiLCBbYV0pYDogU2V0IGBmaWxsYCB3aXRoIGAociwgZywgYiwgYSlgLiBJZiBgYWBcbiAgKiAgICBpcyBvbWl0dGVkLCBpdCBkZWZhdWx0cyB0byBgMWAuXG4gICpcbiAgKiBgcmAsIGBnYCwgYGJgIHNob3VsZCBiZSBpbiB0aGUgcmFuZ2Ugb2YgMC0yNTUgaW5jbHVzaXZlLlxuICAqL1xuQlZHLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBmID0gdGhpcy5hdHRyKCdmaWxsJyk7XG4gICAgaWYgKGYpIHJldHVybiBCVkcuZXh0cmFjdE51bWJlckFycmF5KGYpO1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSByZXR1cm4gdGhpcy5hdHRyKCdmaWxsJywgYXJndW1lbnRzWzBdKTtlbHNlIHJldHVybiB0aGlzLmF0dHIoJ2ZpbGwnLCBCVkcucmdiYShhcmd1bWVudHNbMF0pKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdmaWxsJywgQlZHLnJnYmEuYXBwbHkoQlZHLCBhcmd1bWVudHMpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcih0aGlzLCAnZmlsbCgpIHJlY2VpdmVkIG1vcmUgdGhhbiAxIGFyZ3VtZW50LicpO1xuICB9XG59O1xuXG4vKiogIyMjIGBidmcubm9GaWxsKClgXG4gICogUmVtb3ZlIEJWRyBvYmplY3QncyBjb2xvdXIgZmlsbGluZyBjb21wbGV0ZWx5LlxuICAqL1xuQlZHLnByb3RvdHlwZS5ub0ZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmZpbGwoJ3JnYmEoMCwgMCwgMCwgMCknKTtcbn07XG5cbi8qKiAjIyMgYGJ2Zy5zdHJva2UoKWBcbiAgKiBHZXQvc2V0IHRoZSBvdXRsaW5lIGNvbG91ci5cbiAgKlxuICAqICAtIGBidmcuc3Ryb2tlKClgOiBSZXR1cm4gYHN0cm9rZWAgY29sb3VyIGFzIFtyLCBnLCBiLCBhXS4gSWYgYHN0cm9rZWAgaXNcbiAgKiAgICBub3Qgc3BlY2lmaWVkLCByZXR1cm4gYCcnYCAoZW1wdHkgc3RyaW5nKS5cbiAgKiAgLSBgYnZnLnN0cm9rZShyZ2IpYDogU2V0IGBzdHJva2VgIHdpdGggYSBncmV5c2NhbGUgY29sb3VyIHdpdGggZXF1YWxcbiAgKiAgICB2YWx1ZXMgYChyZ2IsIHJnYiwgcmdiKWAuXG4gICogIC0gYGJ2Zy5zdHJva2UociwgZywgYiwgW2FdKWA6IFNldCBgc3Ryb2tlYCB3aXRoIGAociwgZywgYiwgYSlgLiBJZiBgYWBcbiAgKiAgICBpcyBvbWl0dGVkLCBpdCBkZWZhdWx0cyB0byBgMWAuXG4gICpcbiAgKiBgcmAsIGBnYCwgYGJgIHNob3VsZCBiZSBpbiB0aGUgcmFuZ2Ugb2YgMC0yNTUgaW5jbHVzaXZlLlxuICAqL1xuQlZHLnByb3RvdHlwZS5zdHJva2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIHMgPSB0aGlzLmF0dHIoJ3N0cm9rZScpO1xuICAgIGlmIChzKSByZXR1cm4gQlZHLmV4dHJhY3ROdW1iZXJBcnJheShzKTtcbiAgICByZXR1cm4gJyc7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJykgcmV0dXJuIHRoaXMuYXR0cignc3Ryb2tlJywgYXJndW1lbnRzWzBdKTtlbHNlIHJldHVybiB0aGlzLmF0dHIoJ3N0cm9rZScsIEJWRy5yZ2JhKGFyZ3VtZW50c1swXSkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3N0cm9rZScsIEJWRy5yZ2JhLmFwcGx5KEJWRywgYXJndW1lbnRzKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IodGhpcywgJ3N0cm9rZSgpIHJlY2VpdmVkIG1vcmUgdGhhbiAxIGFyZ3VtZW50LicpO1xuICB9XG59O1xuXG4vKiogIyMjIGBidmcuc3Ryb2tlV2lkdGgoW3dpZHRoXSlgXG4gICogR2V0L3NldCB0aGUgb3V0bGluZSB0aGlja25lc3MuXG4gICpcbiAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG91dGxpbmUgdGhpY2tuZXNzIGlmIGB3aWR0aGAgaXMgb21pdHRlZC4gT3RoZXJpc2UsXG4gICogaXQgYXNzaWducyB0aGUgb3V0bGluZSB0aGlja25lc3Mgd2l0aCBhIG5ldyB2YWx1ZSwgYW5kIHJldHVybnMgdGhlIGBidmdgXG4gICogb2JqZWN0IHJlZmVyZW5jZS5cbiAgKlxuICAqICAtIGB3aWR0aGAgIDogT3V0bGluZSB0aGlja25lc3MgaW4gcGl4ZWxzLlxuICAqL1xuQlZHLnByb3RvdHlwZS5zdHJva2VXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdzdHJva2Utd2lkdGgnKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5hdHRyKCdzdHJva2Utd2lkdGgnLCBhcmd1bWVudHNbMF0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHRoaXMsICdzdHJva2VXaWR0aCgpIHJlY2VpdmVkIG1vcmUgdGhhbiAxIGFyZ3VtZW50LicpO1xuICB9XG59O1xuXG4vKiogIyMjIGBidmcubm9TdHJva2UoKWBcbiAgKiBSZW1vdmUgQlZHIG9iamVjdCdzIG91dGxpbmUgY29tcGxldGVseS5cbiAgKi9cbkJWRy5wcm90b3R5cGUubm9TdHJva2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnN0cm9rZVdpZHRoKDApLnN0cm9rZSgncmdiYSgwLCAwLCAwLCAwKScpO1xufTtcblxuQlZHLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl90YWcuaW5uZXJIVE1MO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLl90YWcuaW5uZXJIVE1MID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHRoaXMsICdjb250ZW50KCkgcmVjZWl2ZWQgbW9yZSB0aGFuIDEgYXJndW1lbnQuJyk7XG4gIH1cbn07XG5cbi8qKiAjIyMgYGJ2Zy5hZGRDbGFzcyhjKWBcbiogQWRkIGEgY2xhc3MgbmFtZSB0byB0aGUgZWxlbWVudC5cbiovXG5CVkcucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gKGMpIHtcbiAgdGhpcy5fdGFnLmNsYXNzTGlzdC5hZGQoYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqICMjIyBgYnZnLnJlbW92ZUNsYXNzKGMpYFxuICAqIFJlbW92ZSBhIGNsYXNzIG5hbWUgdG8gdGhlIGVsZW1lbnQuXG4gICovXG5CVkcucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGMpIHtcbiAgdGhpcy5fdGFnLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqICMjIyBgYnZnLmhhc0NsYXNzKGMpYFxuICAqIFJldHVybiB0cnVlIGlmIHRoZSBlbGVtZW50IGhhcyBjbGFzcyBgY2AuXG4gICovXG5CVkcucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gKGMpIHtcbiAgcmV0dXJuIHRoaXMuX3RhZy5jbGFzc0xpc3QuY29udGFpbnMoYyk7XG59O1xuXG4vKiogIyMjIGBidmcucmVtb3ZlQ2xhc3MoYylgXG4gICogQWRkIG9yIHJlbW92ZSB0aGUgY2xhc3MgYGNgIHRvIHRoZSBlbGVtZW50LlxuICAqL1xuQlZHLnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIChjKSB7XG4gIHRoaXMuX3RhZy5jbGFzc0xpc3QudG9nZ2xlKGMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiAjIyBBZmZpbmUgVHJhbnNmb3JtYXRpb25zICovXG5CVkcucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fdGFnLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJyc7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuX3RhZy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGFyZ3VtZW50c1swXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2Zvcm0oKSByZWNlaXZlZCBtb3JlIHRoYW4gMSBhcmd1bWVudCcpO1xuICB9XG59O1xuXG4vKiogIyMjIGBCVkcudHJhbnNsYXRlKHgsIFt5XSlgXG4gICogQXBwbHkgYSBtb3ZpbmcgdHJhbnNsYXRpb24gYnkgYHhgIGFuZCBgeWAgdW5pdHMuIElmIGB5YCBpcyBub3QgZ2l2ZW4sIGl0XG4gICogaXMgYXNzdW1lZCB0byBiZSAwLlxuICAqL1xuQlZHLnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInICYmIHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2xhdGUoKSBvbmx5IHRha2UgbnVtYmVycyBhcyBhcmd1bWVudHMnKTtcbiAgeSA9IHkgfHwgMDtcbiAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtKCk7XG4gIHRoaXMuX3RhZy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFt0cmFuc2Zvcm0sICcgdHJhbnNsYXRlKCcsIHgsICcgJywgeSwgJyknXS5qb2luKCcnKS50cmltKCkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiAjIyBVdGlsaXR5IE1ldGhvZHMgKi9cblxuLyoqICMjIyBgQlZHLnJnYmEociwgZywgYiwgW2FdKWBcbiAgKiBSZXR1cm4gYSBzdHJpbmcgaW4gdGhlIGZvcm0gb2YgYHJnYmEociwgZywgYiwgYSlgLlxuICAqXG4gICogSWYgb25seSBgcmAgaXMgZ2l2ZW4sIHRoZSB2YWx1ZSBpcyBjb3BpZWQgdG8gYGdgIGFuZCBgYmAgdG8gcHJvZHVjZSBhXG4gICogZ3JleXNjYWxlIHZhbHVlLlxuICAqL1xuQlZHLnJnYmEgPSBmdW5jdGlvbiAociwgZywgYikge1xuICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IDEuMCA6IGFyZ3VtZW50c1szXTtcblxuICBpZiAodHlwZW9mIHIgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZ2JhKCkgbXVzdCB0YWtlIG51bWVyaWNhbCB2YWx1ZXMgYXMgaW5wdXQnKTtcbiAgZyA9IGcgfHwgcjtcbiAgYiA9IGIgfHwgcjtcbiAgcmV0dXJuICdyZ2JhKCcgKyBbciwgZywgYiwgYV0uam9pbignLCcpICsgJyknO1xufTtcblxuLyoqICMjIyBgQlZHLmhzbGEoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIFthbHBoYV0pYFxuICAqIFJldHVybiB0aGUgQ1NTIHJlcHJlc2VudGF0aW9uIGluIGBoc2xhKClgIGFzIGEgc3RyaW5nLlxuICAqXG4gICogIC0gYGh1ZWA6IEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAzNjBgLCB3aGVyZSBgMGAgaXMgcmVkLCBgMTIwYCBpcyBncmVlbixcbiAgKiAgICAgICAgICAgYW5kIGAyNDBgIGlzIGJsdWUuXG4gICogIC0gYHNhdHVyYXRpb25gIDogQSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmQgYDEwMGAsIHdoZXJlIGAwYCBpcyBncmV5IGFuZFxuICAqICAgICAgICAgICAgICAgICBgMTAwYCBpcyBmdWxseSBzYXR1cmF0ZS5cbiAgKiAgLSBgbGlnaHRuZXNzYDogQSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmQgYDEwMGAsIHdoZXJlIGAwYCBpcyBibGFjayBhbmRcbiAgKiAgICAgICAgICAgICAgICAgYDEwMGAgaXMgZnVsbCBpbnRlbnNpdHkgb2YgdGhlIGNvbG91ci5cbiAgKi9cbkJWRy5oc2xhID0gZnVuY3Rpb24gKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuICBhbHBoYSA9IGFscGhhIHx8IDEuMDtcbiAgcmV0dXJuICdoc2xhKCcgKyBbaHVlLCBzYXR1cmF0aW9uICsgJyUnLCBsaWdodG5lc3MgKyAnJScsIGFscGhhXS5qb2luKCcsJykgKyAnKSc7XG59O1xuXG4vKiogIyMjIGBCVkcuZXh0cmFjdE51bWJlckFycmF5KHN0cilgXG4gICogUmV0dXJuIGFuIGFycmF5IGBbeCwgeSwgeiwgLi4uXWAgZnJvbSBhIHN0cmluZyBjb250YWluaW5nIGNvbW1vbi1zZXBhcmF0ZWRcbiAgKiBudW1iZXJzLlxuICAqL1xuQlZHLmV4dHJhY3ROdW1iZXJBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5tYXRjaCgvXFxkKlxcLj9cXGQrL2cpLm1hcChOdW1iZXIpO1xufTtcblxuLyoqICMjIENvbnRyaWJ1dGUgdG8gdGhpcyBsaWJyYXJ5XG4qIFtNYWtlIGEgcHVsbCByZXF1ZXN0XShodHRwczovL2dpdGh1Yi5jb20vU3BheGUvQlZHLmpzL3B1bGxzKSBvclxuKiBbcG9zdCBhbiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL1NwYXhlL0JWRy5qcy9pc3N1ZXMpLiBTYXkgaGVsbG8gdG9cbiogY29udGFjdEB4YWl2ZXJoby5jb20uXG4qL1xuXG59LHt9XX0se30sWzFdKSgxKVxufSk7IiwiLyoqXG4gKiBSb2d1ZWxpa2UgVW5pdmVyc2VcbiAqIEF1dGhvcjogWGF2aWVyIEhvIDxjb250YWN0QHhhdmllcmhvLmNvbT5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TcGF4ZS9yb2d1ZWxpa2UtdW5pdmVyc2VcbiAqL1xuaW1wb3J0IEJWRyBmcm9tIFwiYnZnXCI7XG5pbXBvcnQgeyBwcm9taXNlLCByYXRpbywgZ2V0SlNPTiB9IGZyb20gXCIuL3V0aWxcIjtcblxuY29uc3Qgc2VydmVyX3VybCA9ICdodHRwOi8vMTg4LjE2Ni4yMDkuMTU1L2FwaS92MSc7XG5jb25zdCBzdGFydF95ZWFyID0gMTk3MCwgZW5kX3llYXIgPSAyMDIwO1xuY29uc3QgZnggPSByYXRpby5iaW5kKHJhdGlvLCBzdGFydF95ZWFyLCBlbmRfeWVhcik7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG5cbiAgcm9ndWVsaWtlUmVsYXRpb25zKCk7XG4gIGdlbnJlSW5mbHVlbmNlTWFwKCk7XG5cbn0pO1xuXG5jb25zdCByb2d1ZWxpa2VSZWxhdGlvbnMgPSAoKSA9PiB7XG5cbiAgbGV0IGJ2ZyA9IEJWRy5jcmVhdGUoJyNyb2d1ZWxpa2UtcmVsYXRpb25zJyk7XG4gIGxldCBmb2N1cyA9IGJ2Zy5ncm91cCgnJyk7XG4gIGxldCB3aWR0aCA9IGJ2Zy50YWcoKS5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGJ2Zy50YWcoKS5jbGllbnRIZWlnaHQ7XG4gIGxldCBHVUlfZ2FtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYW1lJyk7XG4gIGxldCBzZWxlY3Rpb24gPSAnRHVuZ2Vvbic7XG5cbiAgbG9hZFJvZ3VlbGlrZVJlbGF0aW9uc0FsbCgpLnRoZW4oIHJlbGF0aW9ucyA9PiB7XG5cbiAgICAvLyBEcmF3IHRpbWVsaW5lXG4gICAgYnZnLnRleHQoJ3llYXInLFxuICAgICAgICAgICAgIDAuMDAxICogd2lkdGgsXG4gICAgICAgICAgICAgaGVpZ2h0IC8gMiArIDMpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydF95ZWFyICsgMjsgaSA8IGVuZF95ZWFyOyBpKyspIHtcbiAgICAgIGJ2Zy50ZXh0KGkudG9TdHJpbmcoKS5zdWJzdHIoMiwgNCksXG4gICAgICAgICAgICAgICAoZngoaSkgLSAwLjAwNSkgKiB3aWR0aCxcbiAgICAgICAgICAgICAgIGhlaWdodCAvIDIgKyAzXG4gICAgICApO1xuICAgIH1cbiAgICBidmcudGV4dCgnSW4tZ2VucmUnLFxuICAgICAgICAgICAgIDAuMDAxICogd2lkdGgsXG4gICAgICAgICAgICAgMC4xICogaGVpZ2h0KTtcbiAgICBidmcudGV4dCgnT3V0LW9mLWdlbnJlJyxcbiAgICAgICAgICAgICAwLjAwMSAqIHdpZHRoLFxuICAgICAgICAgICAgIDAuOSAqIGhlaWdodCk7XG5cblxuICAgIC8vIFBvcHVsYXRlIGdhbWUgdGl0bGVzXG4gICAgcmVsYXRpb25zLmZvckVhY2goIGdhbWUgPT4ge1xuICAgICAgbGV0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0aW9uLnZhbHVlID0gZ2FtZS50aXRsZTtcbiAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ2RhdGEteWVhcicsIGdhbWUueWVhcik7XG4gICAgICBvcHRpb24uaW5uZXJIVE1MID0gYCR7Z2FtZS50aXRsZX0gKCR7Z2FtZS55ZWFyfSlgO1xuICAgICAgR1VJX2dhbWUuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICB9KTtcblxuICAgIC8vIEJpbmQgc2VsZWN0aW9uXG4gICAgR1VJX2dhbWUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXZlbnQgPT4ge1xuICAgICAgc2VsZWN0aW9uID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgZHJhd1NlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH0pO1xuXG4gICAgLy8gRHJhdyBpbmZsdWVuY2UgYXJjc1xuICAgIHJlbGF0aW9ucy5mb3JFYWNoKCAoe3RpdGxlLCB5ZWFyLCBpbnNwaXJlZEJ5LCBpbnNwaXJhdGlvblRvLCBvdGhlckluc3BpcmVkQnksIG90aGVySW5zcGlyYXRpb25Ub30pID0+IHtcblxuICAgICAgaW5zcGlyZWRCeS5mb3JFYWNoKCByID0+IHtcbiAgICAgICAgZHJhd0FyYyhidmcsIHllYXIsIHIueWVhciwgLTEuMCwgMC4xKTtcbiAgICAgIH0pO1xuICAgICAgaW5zcGlyYXRpb25Uby5mb3JFYWNoKCByID0+IHtcbiAgICAgICAgZHJhd0FyYyhidmcsIHIueWVhciwgeWVhciwgLTEuMCwgMC4xKTtcbiAgICAgIH0pO1xuICAgICAgb3RoZXJJbnNwaXJlZEJ5LmZvckVhY2goIHIgPT4ge1xuICAgICAgICBkcmF3QXJjKGJ2ZywgeWVhciwgci55ZWFyLCAxLjAsIDAuMDUpO1xuICAgICAgfSk7XG4gICAgICBvdGhlckluc3BpcmF0aW9uVG8uZm9yRWFjaCggciA9PiB7XG4gICAgICAgIGRyYXdBcmMoYnZnLCByLnllYXIsIHllYXIsIDEuMCwgMC4wNSk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgbGV0IGRyYXdTZWxlY3Rpb24gPSAoc2VsZWN0aW9uKSA9PiB7XG4gICAgICBmb2N1cy50YWcoKS5pbm5lckhUTUwgPSAnJztcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVsYXRpb24gPSByZWxhdGlvbnNbaV07XG4gICAgICAgIGlmIChyZWxhdGlvbi50aXRsZSA9PT0gc2VsZWN0aW9uKSB7XG5cbiAgICAgICAgICBmb2N1cy50ZXh0KHNlbGVjdGlvbiwgZngocmVsYXRpb24ueWVhcikgKiB3aWR0aCwgMC4wOTUgKiBoZWlnaHQpXG4gICAgICAgICAgICAuZmlsbCgwKTtcblxuICAgICAgICAgIGZvY3VzLmxpbmUoe1xuICAgICAgICAgICAgeDE6IGZ4KHJlbGF0aW9uLnllYXIpICogd2lkdGgsXG4gICAgICAgICAgICB5MTogaGVpZ2h0ICogMC4xLFxuICAgICAgICAgICAgeDI6IGZ4KHJlbGF0aW9uLnllYXIpICogd2lkdGgsXG4gICAgICAgICAgICB5MjogaGVpZ2h0ICogMC45XG4gICAgICAgICAgfSkuc3Ryb2tlV2lkdGgoMikuc3Ryb2tlKDAsIDAsIDAsIDAuNSk7XG5cbiAgICAgICAgICByZWxhdGlvbi5pbnNwaXJlZEJ5LmZvckVhY2goIHIgPT4ge1xuICAgICAgICAgICAgZHJhd0FyYyhmb2N1cywgcmVsYXRpb24ueWVhciwgci55ZWFyLCAtMSwgMSwgMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVsYXRpb24uaW5zcGlyYXRpb25Uby5mb3JFYWNoKCByID0+IHtcbiAgICAgICAgICAgIGRyYXdBcmMoZm9jdXMsIHIueWVhciwgcmVsYXRpb24ueWVhciwgLTEsIDEsIDMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlbGF0aW9uLm90aGVySW5zcGlyZWRCeS5mb3JFYWNoKCByID0+IHtcbiAgICAgICAgICAgIGRyYXdBcmMoZm9jdXMsIHJlbGF0aW9uLnllYXIsIHIueWVhciwgMSwgMSwgMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVsYXRpb24ub3RoZXJJbnNwaXJhdGlvblRvLmZvckVhY2goIHIgPT4ge1xuICAgICAgICAgICAgZHJhd0FyYyhmb2N1cywgci55ZWFyLCByZWxhdGlvbi55ZWFyLCAxLCAxLCAzKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBGaXJlIGV2ZW50IHRvIHN0YXJ0XG4gICAgR1VJX2dhbWUudmFsdWUgPSBzZWxlY3Rpb247XG4gICAgZHJhd1NlbGVjdGlvbihzZWxlY3Rpb24pO1xuXG4gIH0pO1xuXG4gIGxldCBkcmF3QXJjID0gKGcsIHllYXJBLCB5ZWFyQiwgaW52ZXJ0PS0xLjAsIG9wYWNpdHk9MSwgc3Ryb2tlV2lkdGg9MSkgPT4ge1xuICAgIGxldCBhcmdzID0gYXJjWWVhcnRvWWVhcih5ZWFyQSwgeWVhckIsIGludmVydCk7XG4gICAgYXJnc1swXSAqPSB3aWR0aDsgYXJnc1sxXSAqPSBoZWlnaHQ7IGFyZ3NbMl0gKj0gaGVpZ2h0OyBhcmdzWzNdICo9IGhlaWdodDtcbiAgICBnLmFyYyguLi5hcmdzKS5zdHJva2UoMCwgMCwgMCwgb3BhY2l0eSkuc3Ryb2tlV2lkdGgoc3Ryb2tlV2lkdGgpO1xuICB9O1xufTtcblxuY29uc3QgZ2VucmVJbmZsdWVuY2VNYXAgPSAoKSA9PiB7XG5cbiAgbGV0IGJ2ZyA9IEJWRy5jcmVhdGUoJyNnZW5yZS1pbmZsdWVuY2UnKTtcbiAgbGV0IGZvY3VzID0gYnZnLmdyb3VwKCcnKTtcbiAgbGV0IHdpZHRoID0gYnZnLnRhZygpLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gYnZnLnRhZygpLmNsaWVudEhlaWdodDtcbiAgbGV0IHJhZGl1cyA9IDM7XG5cbiAgLy8gQXhpc1xuICBidmcubGluZSgwLjEgKiB3aWR0aCwgMC4wMSAqIGhlaWdodCwgMC4xICogd2lkdGgsIDAuOSAqIGhlaWdodCkuc3Ryb2tlKDApO1xuICBidmcubGluZSgwLjEgKiB3aWR0aCwgMC45ICogaGVpZ2h0LCAwLjk5ICogd2lkdGgsIDAuOSAqIGhlaWdodCkuc3Ryb2tlKDApO1xuICBsZXQgdmVydGljYWxMYWJlbEluID0gYnZnLmdyb3VwKGB0cmFuc2xhdGUoJHswLjA5ICogd2lkdGh9ICR7MC4xNSAqIGhlaWdodH0pYCk7XG4gIHZlcnRpY2FsTGFiZWxJbi50ZXh0KCdJbmZsdWVuY2VzIGZyb20gaW4tZ2VucmUnLCAwLCAwKS50cmFuc2Zvcm0oJ3JvdGF0ZSgtOTApJyk7XG4gIGxldCB2ZXJ0aWNhbExhYmVsT3V0ID0gYnZnLmdyb3VwKGB0cmFuc2xhdGUoJHswLjA5ICogd2lkdGh9ICR7MC45ICogaGVpZ2h0fSlgKTtcbiAgdmVydGljYWxMYWJlbE91dC50ZXh0KCdJbmZsdWVuY2VzIGZyb20gb3V0LW9mLWdlbnJlJywgMCwgMCkudHJhbnNmb3JtKCdyb3RhdGUoLTkwKScpO1xuICBidmcudGV4dCgnSW5mbHVlbmNlZCBieSBpdHMgcGFzdCcsIDAuMTEgKiB3aWR0aCwgMC45MTUgKiBoZWlnaHQpO1xuICBidmcudGV4dCgnSW5mbHVlbmNlcyBpdHMgZnV0dXJlJywgMC44NyAqIHdpZHRoLCAwLjkxNSAqIGhlaWdodCk7XG5cbiAgbG9hZFJvZ3VlbGlrZVJlbGF0aW9uc0FsbCgpLnRoZW4oIHJlbGF0aW9ucyA9PiB7XG5cbiAgICBsZXQgbWF4ID0gMDtcbiAgICBsZXQgZ2FtZXMgPSByZWxhdGlvbnMubWFwKCAoe3RpdGxlLCB5ZWFyLCBpbnNwaXJlZEJ5LCBpbnNwaXJhdGlvblRvLCBvdGhlckluc3BpcmVkQnksIG90aGVySW5zcGlyYXRpb25Ub30pID0+IHtcblxuICAgICAgaWYgKFtcbiAgICAgICAgJ0R1bmdlb24gQ3Jhd2wgU3RvbmUgU291cCcsXG4gICAgICAgICdQb2vDqW1vbiBNeXN0ZXJ5IER1bmdlb246IEV4cGxvcmVycyBvZiBUaW1lIGFuZCBFeHBsb3JlcnMgb2YgRGFya25lc3MnLFxuICAgICAgICAnU2hpcmVuIHRoZSBXYW5kZXJlcicsXG4gICAgICAgICdNeXN0ZXJ5IER1bmdlb246IFNoaXJlbiB0aGUgV2FuZGVyZXInLFxuICAgICAgICAnV2VpcmQgV29ybGRzOiBSZXR1cm4gdG8gSW5maW5pdGUgU3BhY2UnLFxuICAgICAgICAnUG9rw6ltb24gTXlzdGVyeSBEdW5nZW9uOiBFeHBsb3JlcnMgb2YgU2t5JyxcbiAgICAgICAgJ0l6dW5hIDI6IFRoZSBVbmVtcGxveWVkIE5pbmphIFJldHVybnMnLFxuICAgICAgICAnU3dvcmQgb2YgdGhlIFN0YXJzOiBUaGUgUGl0JyxcbiAgICAgICAgXCJUYW8ncyBBZHZlbnR1cmU6IEN1cnNlIG9mIHRoZSBEZW1vbiBTZWFcIixcbiAgICAgICAgJ0RyYWdvbiBRdWVzdDogU2hvbmVuIFlhbmd1cyB0byBGdXNoaWdpIG5vIER1bmdlb24nLFxuICAgICAgICAnVGVsZWdsaXRjaCcsXG4gICAgICAgIFwiTW9yYWZmJ3MgUmV2ZW5nZVwiLFxuICAgICAgICAnRG9vbSwgdGhlIFJvZ3VlbGlrZScsXG4gICAgICAgIFwiQ2hvY29ibydzIER1bmdlb24gMlwiLFxuICAgICAgICAnTm90IHRoZSBSb2JvdHMnLFxuICAgICAgICAnSXp1bmE6IExlZ2VuZCBvZiB0aGUgVW5lbXBsb3llZCBOaW5qYScsXG4gICAgICAgICdEZWFkbHkgRHVuZ2VvbnMnLFxuICAgICAgICBcIlRhbydzIEFkdmVudHVyZTogQ3Vyc2Ugb2YgdGhlIERlbW9uIFNlYWxcIixcbiAgICAgICAgJ0Nob2NvYm8gbm8gRnVzaGlnaW5hIER1bmdlb24nLFxuICAgICAgICAnUm9ndWUgTGVnYWN5J1xuICAgICAgXS5pbmRleE9mKHRpdGxlKSA+PSAwKSByZXR1cm4ge3RpdGxlLCB4OiAwLCB5OiAwfTtcblxuICAgICAgbGV0IGlCID0gaW5zcGlyZWRCeS5sZW5ndGg7XG4gICAgICBsZXQgaVQgPSBpbnNwaXJhdGlvblRvLmxlbmd0aDtcbiAgICAgIGxldCBvQiA9IG90aGVySW5zcGlyZWRCeS5sZW5ndGggLyA0O1xuICAgICAgbGV0IG9UID0gb3RoZXJJbnNwaXJhdGlvblRvLmxlbmd0aCAvIDQ7XG4gICAgICBsZXQgeCA9IC1pQiAtIG9CICsgaVQgKyBvVDtcbiAgICAgIGxldCB5ID0gLWlCICsgb0IgLSBpVCArIG9UO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMiksIE1hdGgucG93KE1hdGguYWJzKHkpLCAyKSkgKyAxO1xuICAgICAgcmV0dXJuIHsgdGl0bGUsIHgsIHkgfTtcblxuICAgIH0pO1xuXG4gICAgZ2FtZXMuZm9yRWFjaCggYyA9PiB7XG4gICAgICBpZiAoYy54ID09PSAwICYmIGMueSA9PT0gMCkgcmV0dXJuO1xuICAgICAgbGV0IHN4ID0gYy54ICYmIGMueCAvIE1hdGguYWJzKGMueCk7XG4gICAgICBsZXQgc3kgPSBjLnkgJiYgYy55IC8gTWF0aC5hYnMoYy55KTtcbiAgICAgIGxldCBjeCA9IE1hdGguYWJzKGMueCkgPiAwID8gTWF0aC5zcXJ0KE1hdGguYWJzKGMueCkpICogMiA6IDA7XG4gICAgICBsZXQgY3kgPSBNYXRoLmFicyhjLnkpID4gMCA/IE1hdGguc3FydChNYXRoLmFicyhjLnkpKSAqIDIgOiAwO1xuICAgICAgbGV0IHggPSAoMC41ICsgc3ggKiBjeCAvIE1hdGguc3FydChtYXgpKSAqIHdpZHRoO1xuICAgICAgbGV0IHkgPSAoMC41ICsgc3kgKiBjeSAvIE1hdGguc3FydChtYXgpKSAqIGhlaWdodDtcbiAgICAgIGJ2Zy5jaXJjbGUoeCwgeSwgcmFkaXVzKS5maWxsKDApO1xuICAgICAgYnZnLnRleHQoYy50aXRsZSwgeCArIDUsIHkgKyAzKS5maWxsKDApO1xuICAgIH0pO1xuXG4gIH0pO1xuXG59O1xuXG5jb25zdCBsb2FkUm9ndWVsaWtlUmVsYXRpb25zQWxsID0gKCkgPT4ge1xuXG4gIHJldHVybiBnZXRKU09OKGAke3NlcnZlcl91cmx9L3JvZ3VlbGlrZS9yZWxhdGlvbnMtYWxsYCk7XG5cbn07XG5cbmxldCBhcmNZZWFydG9ZZWFyID0gKGEsIGIsIGludmVydD0tMS4wKSA9PiB7XG5cbiAgbGV0IHhfYSA9IGZ4KGEsIHN0YXJ0X3llYXIsIGVuZF95ZWFyKTtcbiAgbGV0IHhfYiA9IGZ4KGIsIHN0YXJ0X3llYXIsIGVuZF95ZWFyKTtcbiAgbGV0IHggPSAoeF9hICsgeF9iKSAvIDI7XG4gIGxldCB5ID0gMC41ICsgMC4wMSAqIGludmVydDtcbiAgbGV0IHJ4ID0gTWF0aC5hYnMoeF9iIC0geF9hKSAvIDI7XG4gIGxldCByeSA9IHJ4O1xuICBsZXQgc3RhcnRBbmdsZSA9IDA7XG4gIGxldCBlbmRBbmdsZSA9IE1hdGguUEkgKiBpbnZlcnQ7XG4gIHJldHVybiBbeCwgeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG5cbn07XG5cbiIsImV4cG9ydCBjb25zdCBwcm9taXNlID0gKCBmdW5jLCAuLi5hcmdzICkgPT4ge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoIGVycm9yLCBkYXRhICkgPT4ge1xuICAgICAgaWYgKGVycm9yKSByZWplY3QoZXJyb3IpO1xuICAgICAgZWxzZSByZXNvbHZlKGRhdGEpO1xuICAgIH07XG4gICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICBmdW5jLmFwcGx5KGZ1bmMsIGFyZ3MpO1xuICB9KTtcblxufTtcblxuZXhwb3J0IGNvbnN0IHJhdGlvID0gKG1pbiwgbWF4LCB4KSA9PiB7XG5cbiAgcmV0dXJuICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xuXG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VVJMID0gKHVybCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXEub3BlbignR0VUJywgdXJsKTtcbiAgICByZXEub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxLnN0YXR1c1RleHQpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdOZXR3b3JrIEVycm9yJykpO1xuICAgIH07XG4gICAgcmVxLnNlbmQoKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SlNPTiA9ICh1cmwpID0+IHtcbiAgcmV0dXJuIGdldFVSTCh1cmwpLnRoZW4oSlNPTi5wYXJzZSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgIGNvbnNvbGUubG9nKCdnZXRKU09OIGZhaWxlZCB0byBsb2FkJywgdXJsKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xufTsiXX0=
