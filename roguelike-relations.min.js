(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.BVG = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//
/** # BVG - Bindable Vector Graphics
  * **Real-time data-driven visualisation for the web.**
  *
  * ![Example](https://raw.githubusercontent.com/Spaxe/BVG.js/master/demo/index.gif)
  *
  * Live example: http://spaxe.github.io/BVG.js/
  *
  * *Bindable Vector Graphics* was born out of frustration for lack of a
  * middle level SVG library. [D3.js](http://d3js.org/) abstracts too much
  * logic, and [SVG.js](http://svgjs.com/) provides only low-level SVG drawing.
  * Bindable Vector Graphics offers SVG elements that change as the data change,
  * and gives you tools to control their look.
  */
'use strict';

/** The heart of this library is a trinity: **SVG + Data + Binding**. This
  * connects your data to the SVG element through the binding function, which
  * creates a living connection that can react to change. BVG uses
  * [`Object.observe()`](http://caniuse.com/#feat=object-observe) which is
  * available on Chrome 36+, Opera 27+ and Android Browser 37+.
  *
  * If you wish to use this for older browsers, you can polyfill with
  * [`MaxArt2501/Object.observe`](https://github.com/MaxArt2501/object-observe).
  *
  * ## Installation
  *
  * **Install using `npm`**:
  *
  *  1. Install Node.js: https://docs.npmjs.com/getting-started/installing-node
  *  2. In your working directory:
  *
  *     ```
  *     npm install bvg
  *     ```
  *
  * **Install via GitHub**:
  *
  *  1. Clone this repo:
  *
  *     ```
  *     git clone https://github.com/Spaxe/BVG.js.git
  *     ```
  *
  *  2. Copy `require.js` and `bvg.js` into your working directory.
  *
  * **To include `BVG.js` in your webpage**:
  *
  *  1. In your HTML `<head>`, include this script using `require.js`:
  *
  *     ```HTML
  *     <script src="path/to/require.js" data-main="your-script.js"></script>
  *     ```
  *
  *  2. In `your-script.js`, define your own code with
  *
  *     ```Javascript
  *     require(['path/to/bvg.js'], function (BVG) {
  *       // your code goes here ...
  *     });
  *     ```
  *
  * ## Quickstart
  *
  * ![Quickstart Example](https://raw.githubusercontent.com/Spaxe/BVG.js/master/demo/001-hello.gif)
  *
  * HTML:
  *
  * ```HTML
  * <div id="bvg-container"></div>
  * ```
  *
  * CSS (Make the container large enough):
  *
  * ```CSS
  * html, body, #bvg-container {
  *   height: 100%;
  *   margin: 0;
  * }
  * ```
  *
  * Javascript:
  *
  * ```Javascript
  * // Create a BVG container based on selected HTML element
  * var bvg = BVG.create('#bvg-container');
  * // Create a Bindable circle, colour it orange
  * var circle = bvg.ellipse(0, 0, 150, 150)
  *                 .fill(220, 64, 12);
  * // Change its size based on mouse movement
  * bvg.tag().addEventListener('mousemove', function (event) {
  *   circle.data({
  *     rx: event.clientX,
  *     ry: event.clientY
  *   });
  * });
  * ```
  */

/*- Deep Object.observe() */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BVG;
function observe(obj, callback) {

  // Include https://github.com/MaxArt2501/object-observe if you wish to work
  // with polyfill on browsers that don't support Object.observe()
  Object.observe(obj, function (changes) {
    changes.forEach(function (change) {

      // Bind child property if it is an object for deep observing
      if (obj[change.name] instanceof Object) {
        observe(obj[change.name], callback);
      }
    });

    // Trigger user callback
    callback.call(this, changes);
  });

  // Immediately fire observe to initiate deep observing
  Object.keys(obj).forEach(function (key) {
    if (obj[key] instanceof Object) {
      observe(obj[key], callback);
    }
  });
}

/*- `BVG(tag, data, binding)`
  * The trinity of this library: SVG + Data + Binding Function.
  *
  * Return the BVG object created.
  *
  *  - `tag`    : Either a `String` for the SVG `tagName` or any [`SVGElement`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element)
  *  - `data`   : Object with arbitrary data to your desire
  *  - `binding`: (optional) Binding function that sets the tag attributes
  */
function BVG(tag, data, binding) {
  var bvg = this;
  tag = tag instanceof SVGElement ? tag : document.createElementNS('http://www.w3.org/2000/svg', tag);
  data = data || {};
  binding = binding || function (tag, data) {
    for (var prop in data) {
      if (data.hasOwnProperty(prop)) {
        tag.setAttribute(prop, data[prop]);
      }
    }
  };

  // Observe data object and apply binding right away
  observe(data, function (changes) {
    binding(tag, data);
  });
  binding(tag, data);

  // ID function from https://gist.github.com/gordonbrander/2230317
  tag.setAttribute('id', 'BVG_' + tag.tagName + '_' + Math.random().toString(36).substr(2, 7));
  this._tag = tag;
  this._data = data;
  this._binding = binding;

  // Functional circular reference
  this._tag._getBVG = function () {
    return bvg;
  };

  if (['svg', 'g', 'a'].indexOf(tag.tagName) < 0) {
    if (!data.stroke) this.stroke(175);
    if (!data.strokeWidth) this.strokeWidth(0.5);
    if (!data.fill) this.noFill();
  }

  return this;
};

/** ## The BVG Container
  * The rest of the documentation will assume `bvg` as our BVG container
  * created by the example below.
  */

/** ### `BVG.create(htmlElement)`
  * Create a BVG container inside `htmlElement`.
  *
  * Return the BVG container object.
  *
  *  - `htmlElement`  : Either a [CSS Selector](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
  *                     or any [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
  *
  * ```Javascript
  * // Create a new BVG container and append it to an existing HTML element.
  * var bvg = BVG.create('#bvg-container');
  * ```
  */
var create = exports.create = BVG.create = function (htmlElement, xDimension, yDimension) {
  if (typeof htmlElement === 'string') htmlElement = document.querySelector(htmlElement);
  if (!(htmlElement instanceof HTMLElement)) throw new TypeError('htmlElement (' + htmlElement + ') was not found.');

  var data = {
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    version: 1.1,
    width: '100%',
    height: '100%'
  };
  yDimension = yDimension || xDimension;
  if (xDimension) {
    data.viewBox = [0, 0, xDimension, yDimension].join(' ');
  }

  var bvg = new BVG('svg', data);
  htmlElement.appendChild(bvg.tag());
  return bvg;
};

/** ## BVG Elements
  * All BVG objects, including the container, have access to drawing functions
  * and return reference to the new shape, which is also a BVG.
  *
  * ```Javascript
  * // Create a rectangle at (0, 0) with dimensions 100x100 px and add it to bvg
  * var rect = bvg.rect(0, 0, 100, 100);
  * ```
  *
  * The BVG module also has drawing functions, which return the BVG object:
  *
  * ```Javascript
  * // Create a rectangle at (0, 0) with dimensions 100x100 px
  * // Note it uses the BVG module directly to create the rectangle.
  * var rect = BVG.rect(0, 0, 100, 100);
  * // Add the rectangle to an existing BVG container
  * bvg.append(rect);
  * ```
  *
  * Drawing functions can be called in a number of ways. Take `bvg.rect(x, y, width, height)`
  * as an example below. Sometimes it is easier to use one over another style.
  *
  * ```Javascript
  * bvg.rect(0, 10, 30, 70);      // Arguments style
  * bvg.rect({                    // Object style
  *   x: 0,
  *   y: 10,                      // Name of the object properties must match
  *   width: 30,                  // names of the arguments in the functions,
  *   height: 70                  // but the order can be any.
  * });
  * ```
  */
var creationFunctions = {
  svg: function svg(xlink, version, width, height) {
    return new BVG('svg', xlink.constructor.name === 'Object' ? xlink : {
      'xmlns:xlink': xlink,
      version: version,
      width: width,
      height: height
    });
  },

  /** ### `bvg.rect(x, y, width, height)`
    * Create a rectangle at position `(x, y)` at `width` x `height` in size.
    *
    * ```Javascript
    * var rect = bvg.rect(100, 100, 300, 150);
    * ```
    */
  rect: function rect(x, y, width, height) {
    return new BVG('rect', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      width: width,
      height: height
    });
  },

  /** ### `bvg.circle(cx, cy, r)`
    * Create a circle centred on `(cx, cy)` with radius `r`.
    *
    * ```Javascript
    * var circle = bvg.ellipse(100, 100, 50);
    * ```
    */
  circle: function circle(x, y, r) {
    return new BVG('circle', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      r: r
    }, function (tag, data) {
      tag.setAttribute('cx', data.x);
      tag.setAttribute('cy', data.y);
      tag.setAttribute('r', data.r);
    });
  },

  /** ### `bvg.ellipse(cx, cy, rx, ry)`
    * Create a ellipse centred on `(cx, cy)` with radii `rx` and `ry`.
    *
    * ```Javascript
    * var ellipse = bvg.ellipse(100, 100, 200, 180);
    * ```
    */
  ellipse: function ellipse(x, y, rx, ry) {
    return new BVG('ellipse', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      rx: rx,
      ry: ry
    }, function (tag, data) {
      tag.setAttribute('cx', data.x);
      tag.setAttribute('cy', data.y);
      tag.setAttribute('rx', data.rx);
      tag.setAttribute('ry', data.ry);
    });
  },

  /** ### `bvg.line(x1, y1, x2, y2)`
    * Create a line from `(x1, y1)` to `(x2, y2)`.
    *
    * ```Javascript
    * var line = bvg.line(100, 100, 200, 300);
    * ```
    */
  line: function line(x1, y1, x2, y2) {
    return new BVG('line', x1.constructor.name === 'Object' ? x1 : {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2
    });
  },
  /** ### `bvg.polyline([[x1, y1], [x2, y2], ...])`
    * Create a series of lines from point to point.
    *
    * ```Javascript
    * var polyline = bvg.polyline([[100, 200], [200, 300], [400, 800]]);
    * ```
    */
  polyline: function polyline(points) {
    return new BVG('polyline', points.constructor.name === 'Object' ? points : {
      points: points
    }, function (tag, data) {
      tag.setAttribute('points', data.points.join(' '));
    });
  },
  /** ### `bvg.polygon([[x1, y1], [x2, y2], ...])`
    * Create a closed polygon from point to point. The last point will be
    * connected back to the first point.
    *
    * ```Javascript
    * var polygon = bvg.polygon([[100, 200], [200, 300], [400, 800]]);
    * ```
    */
  polygon: function polygon(points) {
    return new BVG('polygon', points.constructor.name === 'Object' ? points : {
      points: points
    }, function (tag, data) {
      tag.setAttribute('points', data.points.join(' '));
    });
  },

  /** ## Grouping Elements
    * ### `bvg.group([transform])`
    *
    * Create a group to contain BVG objects. It acts like a BVG container with
    * an optional `transform` attribute.
    *
    * ```Javascript
    * // Create a new group and fill it with dashes.
    * var dashes = bvg.group();
    * for (int i = 0; i < 5; i++) {
    *   dahses.rect(10, 10 + i * 30, 50, 20);
    * }
    * ```
    */
  group: function group(transform) {
    return new BVG('g', transform.constructor.name === 'Object' ? transform : {
      transform: transform
    });
  },

  /** ## Hyperlinks
    * ### `bvg.hyperlink(url)`
    *
    * Create a hyperlink BVG to target URL `url`. It does not have any display
    * elements. Make sure to append elements to it.
    *
    * ```Javascript
    * // Clicking on this element will bring them to the Github page
    * var githubLink = bvg.hyperlink('https://github.com/spaxe/BVG.js');
    * // Make a button and attack it to the link
    * githubLink.ellipse(200, 200, 50, 50);
    * ```
    */
  hyperlink: function hyperlink(url) {
    return new BVG('a', url.constructor.name === 'Object' ? url : {
      'xmlns:href': url
    });
  },

  /** ## Other Geometry
    * ### `bvg.triangle(cx, cy, r)`
    * Create a regular triangle centred on `(cx, cy)` with vertices `r` distance
    * away.
    *
    * ```Javascript
    * var triangle = bvg.triangle(50, 50, 10);
    * ```
    */
  triangle: function triangle(x, y, r) {
    return new BVG('polygon', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      r: r
    }, function (tag, data) {
      var points = [[data.x, data.y - data.r], [data.x - data.r / 2 * Math.sqrt(3), data.y + data.r / 2], [data.x + data.r / 2 * Math.sqrt(3), data.y + data.r / 2]];
      tag.setAttribute('points', points.join(' '));
    });
  },

  /** ### `bvg.arc(cx, cy, rx, ry, startAngle, endAngle)`
    * Create an arc centred on `(cx, cy)` with radius `rx` and `ry`, starting
    * from `startAngle` anti-clockwise to `endAngle`, where 0 is the positive
    * x-axis.
    *
    * ```Javascript
    * var arc = bvg.arc(50, 50, 50, 100, 0, Math.PI);
    * ```
    */
  arc: function arc(x, y, rx, ry, startAngle, endAngle) {
    return new BVG('path', x.constructor.name === 'Object' ? x : {
      x: x,
      y: y,
      rx: rx,
      ry: ry,
      startAngle: startAngle,
      endAngle: endAngle
    }, function (tag, data) {
      var p1 = getPointOnEllipse(data.x, data.y, data.rx, data.ry, data.startAngle);
      var p2 = getPointOnEllipse(data.x, data.y, data.rx, data.ry, data.endAngle);
      var largeArc = data.endAngle - data.startAngle > Math.PI ? 1 : 0;
      var sweepArc = data.endAngle > data.startAngle ? 1 : 0;
      var d = [['M', p1.x, p1.y], ['A', data.rx, data.ry, 0, largeArc, sweepArc, p2.x, p2.y]];
      tag.setAttribute('d', d.map(function (x) {
        return x.join(' ');
      }).join(' '));

      function getPointOnEllipse(x, y, rx, ry, angle) {
        return {
          x: rx * Math.cos(angle) + x,
          y: ry * Math.sin(angle) + y
        };
      }
    });
  },

  /** ### `bvg.text(text, x, y)`
    * Create a string of `text` text at location `(x, y)`.
    *
    * ```Javascript
    * var text = bvg.text('Mrraa!', 20, 10);
    * ```
    */
  text: function text(_text, x, y) {
    return new BVG('text', _text.constructor.name === 'Object' ? _text : {
      text: _text,
      x: x,
      y: y
    }, function (tag, data) {
      tag.innerHTML = data.text;
      tag.setAttribute('x', data.x);
      tag.setAttribute('y', data.y);
    }).fill('rgba(175, 175, 175, 1)').stroke('rgba(0, 0, 0, 0)');
  }
};

Object.keys(creationFunctions).forEach(function (f) {
  BVG[f] = function () {
    return creationFunctions[f].apply(BVG, arguments);
  };
  BVG.prototype[f] = function () {
    var bvg = creationFunctions[f].apply(this, arguments);
    this.append(bvg);
    return bvg;
  };
});

/** ## The BVG Object
  * BVGs are SVGs with extra superpowers.
  */

/** ### `bvg.find(selector)`
  * Return an array of BVGs matching `selector` inside BVG. `selector` is
  * defined as [CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors).
  */
BVG.prototype.find = function (selector) {
  var result = this._tag.querySelectorAll(selector);
  if (result) {
    var bvgs = [];
    [].slice.call(result).forEach(function (r) {
      bvgs.push(r._getBVG());
    });
    return bvgs;
  }
  return [];
};

/** ### `bvg.append(bvg)`
  * Insert `child_bvg` inside `bvg`. This is useful to add elements inside a
  * `BVG.group()`.
  */
BVG.prototype.append = function (child_bvg) {
  this._tag.appendChild(child_bvg._tag);
  return this;
};

/** ### `bvg.remove()`
  * Remove itself from its parent. Return self reference.
  */
BVG.prototype.remove = function () {
  var parent = this.parent();
  if (parent) {
    parent._tag.removeChild(this._tag);
  }
  return this;
};

/** ### `bvg.parent()`
  * Return the parent BVG. If there is no parent (such is the case for the BVG
  * container itself), return null.
  */
BVG.prototype.parent = function () {
  if (this._tag.parentNode && typeof this._tag.parentNode._getBVG === 'function') return this._tag.parentNode._getBVG();
  return null;
};

/** ### `bvg.children()`
  * Return a list of BVG elements inside `bvg`.
  */
BVG.prototype.children = function () {
  var output = [];
  for (var i = 0; i < this._tag.childNodes.length; i++) {
    if (typeof this._tag.childNodes[i]._getBVG === 'function') output.push(this._tag.childNodes[i]._getBVG());
  }return output;
};

/** ### `bvg.tag()`
  * Return thw BVG graphical content, a SVG.
  */
BVG.prototype.tag = function () {
  return this._tag;
};

/** ### `bvg.data()`
 * Get/set the `data` object in a BVG. There are four ways to use this
 * function.
 *
 *  - `bvg.data()`: Return `data` bound to the BVG.
 *  - `bvg.data(newData)`: Update `data` with `newData` object.
 *  - `bvg.data(property)`: Return `data[property]` from the BVG.
 *  - `bvg.data(property, newValue)`: Update `property` with `newValue`.
 *
 * Return `bvg` object reference.
 */
BVG.prototype.data = function () {
  if (arguments.length === 0) {
    return this._data;
  } else if (arguments.length === 1) {
    if (arguments[0].constructor.name === 'Object') {
      for (var k in arguments[0]) {
        if (arguments[0].hasOwnProperty(k)) {
          this.data(k, arguments[0][k]);
        }
      }
      return this;
    } else {
      return this._data[arguments[0]];
    }
  } else if (arguments.length === 2) {
    this._data[arguments[0]] = arguments[1];
    return this;
  } else {
    throw new RangeError(this, 'data() received more than 2 arguments.');
  }
};

/** ### `bvg.attr()`
  * Get/set attributes on a BVG.
  *
  *  - `bvg.attr(attr)`: Return attribute value.
  *  - `bvg.attr(attr, value)`: Update `attr` with `value`.
  */
BVG.prototype.attr = function (attr, value) {
  if (!attr) throw new Error('attr must be defined');
  if (!value) return this._tag.getAttribute(attr);else this._tag.setAttribute(attr, value);
  return this;
};

/** ### `bvg.fill()`
  * Get/set the filling colour.
  *
  *  - `bvg.fill()`: Return `fill` colour as [r, g, b, a], or `''` (empty
  *                  strig) if fill is not specified on the object.
  *  - `bvg.fill(rgb)`: Set `fill` with a greyscale colour with equal
  *    values `(rgb, rgb, rgb)`.
  *  - `bvg.fill(r, g, b, [a])`: Set `fill` with `(r, g, b, a)`. If `a`
  *    is omitted, it defaults to `1`.
  *
  * `r`, `g`, `b` should be in the range of 0-255 inclusive.
  */
BVG.prototype.fill = function () {
  if (arguments.length === 0) {
    var f = this.attr('fill');
    if (f) return BVG.extractNumberArray(f);
    return '';
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'string') return this.attr('fill', arguments[0]);else return this.attr('fill', BVG.rgba(arguments[0]));
  } else if (arguments.length === 3 || arguments.length === 4) {
    return this.attr('fill', BVG.rgba.apply(BVG, arguments));
  } else {
    throw new RangeError(this, 'fill() received more than 1 argument.');
  }
};

/** ### `bvg.noFill()`
  * Remove BVG object's colour filling completely.
  */
BVG.prototype.noFill = function () {
  return this.fill('rgba(0, 0, 0, 0)');
};

/** ### `bvg.stroke()`
  * Get/set the outline colour.
  *
  *  - `bvg.stroke()`: Return `stroke` colour as [r, g, b, a]. If `stroke` is
  *    not specified, return `''` (empty string).
  *  - `bvg.stroke(rgb)`: Set `stroke` with a greyscale colour with equal
  *    values `(rgb, rgb, rgb)`.
  *  - `bvg.stroke(r, g, b, [a])`: Set `stroke` with `(r, g, b, a)`. If `a`
  *    is omitted, it defaults to `1`.
  *
  * `r`, `g`, `b` should be in the range of 0-255 inclusive.
  */
BVG.prototype.stroke = function () {
  if (arguments.length === 0) {
    var s = this.attr('stroke');
    if (s) return BVG.extractNumberArray(s);
    return '';
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'string') return this.attr('stroke', arguments[0]);else return this.attr('stroke', BVG.rgba(arguments[0]));
  } else if (arguments.length === 3 || arguments.length === 4) {
    return this.attr('stroke', BVG.rgba.apply(BVG, arguments));
  } else {
    throw new RangeError(this, 'stroke() received more than 1 argument.');
  }
};

/** ### `bvg.strokeWidth([width])`
  * Get/set the outline thickness.
  *
  * Returns the current outline thickness if `width` is omitted. Otherise,
  * it assigns the outline thickness with a new value, and returns the `bvg`
  * object reference.
  *
  *  - `width`  : Outline thickness in pixels.
  */
BVG.prototype.strokeWidth = function () {
  if (arguments.length === 0) {
    return this.attr('stroke-width');
  } else if (arguments.length === 1) {
    this.attr('stroke-width', arguments[0]);
    return this;
  } else {
    throw new RangeError(this, 'strokeWidth() received more than 1 argument.');
  }
};

/** ### `bvg.noStroke()`
  * Remove BVG object's outline completely.
  */
BVG.prototype.noStroke = function () {
  return this.strokeWidth(0).stroke('rgba(0, 0, 0, 0)');
};

BVG.prototype.content = function () {
  if (arguments.length === 0) {
    return this._tag.innerHTML;
  } else if (arguments.length === 1) {
    this._tag.innerHTML = arguments[0];
    return this;
  } else {
    throw new RangeError(this, 'content() received more than 1 argument.');
  }
};

/** ### `bvg.addClass(c)`
* Add a class name to the element.
*/
BVG.prototype.addClass = function (c) {
  this._tag.classList.add(c);
  return this;
};

/** ### `bvg.removeClass(c)`
  * Remove a class name to the element.
  */
BVG.prototype.removeClass = function (c) {
  this._tag.classList.remove(c);
  return this;
};

/** ### `bvg.hasClass(c)`
  * Return true if the element has class `c`.
  */
BVG.prototype.hasClass = function (c) {
  return this._tag.classList.contains(c);
};

/** ### `bvg.removeClass(c)`
  * Add or remove the class `c` to the element.
  */
BVG.prototype.toggleClass = function (c) {
  this._tag.classList.toggle(c);
  return this;
};

/** ## Affine Transformations */
BVG.prototype.transform = function () {
  if (arguments.length === 0) {
    return this._tag.getAttribute('transform') || '';
  } else if (arguments.length === 1) {
    this._tag.setAttribute('transform', arguments[0]);
    return this;
  } else {
    throw new Error('transform() received more than 1 argument');
  }
};

/** ### `BVG.translate(x, [y])`
  * Apply a moving translation by `x` and `y` units. If `y` is not given, it
  * is assumed to be 0.
  */
BVG.prototype.translate = function (x, y) {
  if (typeof x !== 'number' && typeof y !== 'number') throw new Error('translate() only take numbers as arguments');
  y = y || 0;
  var transform = this.transform();
  this._tag.setAttribute('transform', [transform, ' translate(', x, ' ', y, ')'].join('').trim());
  return this;
};

/** ## Utility Methods */

/** ### `BVG.rgba(r, g, b, [a])`
  * Return a string in the form of `rgba(r, g, b, a)`.
  *
  * If only `r` is given, the value is copied to `g` and `b` to produce a
  * greyscale value.
  */
BVG.rgba = function (r, g, b) {
  var a = arguments.length <= 3 || arguments[3] === undefined ? 1.0 : arguments[3];

  if (typeof r !== 'number') throw new TypeError('rgba() must take numerical values as input');
  g = g || r;
  b = b || r;
  return 'rgba(' + [r, g, b, a].join(',') + ')';
};

/** ### `BVG.hsla(hue, saturation, lightness, [alpha])`
  * Return the CSS representation in `hsla()` as a string.
  *
  *  - `hue`: A value between `0` and `360`, where `0` is red, `120` is green,
  *           and `240` is blue.
  *  - `saturation` : A value between `0` and `100`, where `0` is grey and
  *                 `100` is fully saturate.
  *  - `lightness`: A value between `0` and `100`, where `0` is black and
  *                 `100` is full intensity of the colour.
  */
BVG.hsla = function (hue, saturation, lightness, alpha) {
  alpha = alpha || 1.0;
  return 'hsla(' + [hue, saturation + '%', lightness + '%', alpha].join(',') + ')';
};

/** ### `BVG.extractNumberArray(str)`
  * Return an array `[x, y, z, ...]` from a string containing common-separated
  * numbers.
  */
BVG.extractNumberArray = function (str) {
  return str.match(/\d*\.?\d+/g).map(Number);
};

/** ## Contribute to this library
* [Make a pull request](https://github.com/Spaxe/BVG.js/pulls) or
* [post an issue](https://github.com/Spaxe/BVG.js/issues). Say hello to
* contact@xaiverho.com.
*/

},{}]},{},[1])(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
"use strict";

var _bvg = require("bvg");

var _bvg2 = _interopRequireDefault(_bvg);

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
                                                                                                                                                                                                     * Roguelike Universe
                                                                                                                                                                                                     * Author: Xavier Ho <contact@xavierho.com>
                                                                                                                                                                                                     * https://github.com/Spaxe/roguelike-universe
                                                                                                                                                                                                     */

var server_url = 'http://188.166.209.155/api/v1';
var start_year = 1970,
    end_year = 2020;
var fx = _util.ratio.bind(_util.ratio, start_year, end_year);

document.addEventListener('DOMContentLoaded', function () {

  loadRoguelikeRelationsAll().then(function (relations) {
    roguelikeRelations(relations);
    genreInfluenceMap(relations);
  });
});

var roguelikeRelations = function roguelikeRelations(relations) {

  var bvg = _bvg2.default.create('#roguelike-relations');
  var focus = bvg.group('');
  var tag = bvg.tag();
  var width = tag.clientWidth || tag.parentNode.clientWidth;
  var height = tag.clientHeight || tag.parentNode.clientHeight;
  var GUI_game = document.getElementById('game');
  var selection = 'Dungeon';

  var drawArc = function drawArc(g, yearA, yearB) {
    var invert = arguments.length <= 3 || arguments[3] === undefined ? -1.0 : arguments[3];
    var opacity = arguments.length <= 4 || arguments[4] === undefined ? 1 : arguments[4];
    var strokeWidth = arguments.length <= 5 || arguments[5] === undefined ? 1 : arguments[5];

    var args = arcYeartoYear(yearA, yearB, invert);
    args[0] *= width;args[1] *= height;args[2] *= height;args[3] *= height;
    g.arc.apply(g, _toConsumableArray(args)).stroke(0, 0, 0, opacity).strokeWidth(strokeWidth);
  };

  // Draw timeline
  bvg.text('year', 0.001 * width, height / 2 + 3);
  for (var i = start_year + 2; i < end_year; i++) {
    if (i % 5 === 0) {
      bvg.text(i.toString(), (fx(i) - 0.02) * width, height / 2 + 3).fill(0);
    } else {
      bvg.text('·', (fx(i) - 0.0025) * width, height / 2 + 3).fill(0);
    }
  }
  bvg.text('In-genre', 0.001 * width, 0.1 * height);
  bvg.text('Out-of-genre', 0.001 * width, 0.9 * height);

  // Populate game titles
  relations.forEach(function (game) {
    var option = document.createElement('option');
    option.value = game.title;
    option.setAttribute('data-year', game.year);
    option.innerHTML = game.title + " (" + game.year + ")";
    GUI_game.appendChild(option);
  });

  // Bind selection
  GUI_game.addEventListener('change', function (event) {
    selection = event.target.value;
    drawSelection(selection);
  });

  // Draw influence arcs
  relations.forEach(function (_ref) {
    var title = _ref.title;
    var year = _ref.year;
    var inspiredBy = _ref.inspiredBy;
    var inspirationTo = _ref.inspirationTo;
    var otherInspiredBy = _ref.otherInspiredBy;
    var otherInspirationTo = _ref.otherInspirationTo;

    inspiredBy.forEach(function (r) {
      drawArc(bvg, year, r.year, -1.0, 0.1);
    });
    inspirationTo.forEach(function (r) {
      drawArc(bvg, r.year, year, -1.0, 0.1);
    });
    otherInspiredBy.forEach(function (r) {
      drawArc(bvg, year, r.year, 1.0, 0.05);
    });
    otherInspirationTo.forEach(function (r) {
      drawArc(bvg, r.year, year, 1.0, 0.05);
    });
  });

  var drawSelection = function drawSelection(selection) {
    focus.tag().innerHTML = '';

    var _loop = function _loop(i) {
      var relation = relations[i];
      if (relation.title === selection) {

        focus.text(selection, fx(relation.year) * width, 0.095 * height).fill(0);

        focus.line({
          x1: fx(relation.year) * width,
          y1: height * 0.1,
          x2: fx(relation.year) * width,
          y2: height * 0.9
        }).strokeWidth(2).stroke(0, 0, 0, 0.5);

        relation.inspiredBy.forEach(function (r) {
          drawArc(focus, relation.year, r.year, -1, 1, 3);
        });
        relation.inspirationTo.forEach(function (r) {
          drawArc(focus, r.year, relation.year, -1, 1, 3);
        });
        relation.otherInspiredBy.forEach(function (r) {
          drawArc(focus, relation.year, r.year, 1, 1, 3);
        });
        relation.otherInspirationTo.forEach(function (r) {
          drawArc(focus, r.year, relation.year, 1, 1, 3);
        });

        return {
          v: undefined
        };
      }
    };

    for (var i = 0; i < relations.length; i++) {
      var _ret = _loop(i);

      if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    }
  };

  // Fire event to start
  GUI_game.value = selection;
  drawSelection(selection);
};

var genreInfluenceMap = function genreInfluenceMap(relations) {

  var bvg = _bvg2.default.create('#genre-influence');
  var focus = bvg.group('');
  var tag = bvg.tag();
  var width = tag.clientWidth || tag.parentNode.clientWidth;
  var height = tag.clientHeight || tag.parentNode.clientHeight;
  var radius = 3;

  // Axis
  bvg.line(0.1 * width, 0.01 * height, 0.1 * width, 0.9 * height).stroke(0);
  bvg.line(0.1 * width, 0.9 * height, 0.99 * width, 0.9 * height).stroke(0);
  var verticalLabelIn = bvg.group("translate(" + 0.09 * width + " " + 0.15 * height + ")");
  verticalLabelIn.text('Influences from in-genre', 0, 0).transform('rotate(-90)');
  var verticalLabelOut = bvg.group("translate(" + 0.09 * width + " " + 0.9 * height + ")");
  verticalLabelOut.text('Influences from out-of-genre', 0, 0).transform('rotate(-90)');
  bvg.text('Influenced by the past', 0.11 * width, 0.915 * height);
  bvg.text('Influences the future', 0.87 * width, 0.915 * height);

  var max = 0;
  var games = relations.map(function (_ref2) {
    var title = _ref2.title;
    var year = _ref2.year;
    var inspiredBy = _ref2.inspiredBy;
    var inspirationTo = _ref2.inspirationTo;
    var otherInspiredBy = _ref2.otherInspiredBy;
    var otherInspirationTo = _ref2.otherInspirationTo;

    if (['Dungeon Crawl Stone Soup', 'Pokémon Mystery Dungeon: Explorers of Time and Explorers of Darkness', 'Shiren the Wanderer', 'Mystery Dungeon: Shiren the Wanderer', 'Weird Worlds: Return to Infinite Space', 'Pokémon Mystery Dungeon: Explorers of Sky', 'Izuna 2: The Unemployed Ninja Returns', 'Sword of the Stars: The Pit', "Tao's Adventure: Curse of the Demon Sea", 'Dragon Quest: Shonen Yangus to Fushigi no Dungeon', 'Teleglitch', "Moraff's Revenge", 'Doom, the Roguelike', "Chocobo's Dungeon 2", 'Not the Robots', "Slaves to Armok II: Dwarf Fortress", 'Izuna: Legend of the Unemployed Ninja', 'Deadly Dungeons', "Tao's Adventure: Curse of the Demon Seal", 'Chocobo no Fushigina Dungeon', 'Rogue Legacy'].indexOf(title) >= 0) return { title: title, x: 0, y: 0 };

    var iB = inspiredBy.length;
    var iT = inspirationTo.length;
    var oB = otherInspiredBy.length / 4;
    var oT = otherInspirationTo.length / 4;
    var x = -iB - oB + iT + oT;
    var y = -iB + oB - iT + oT;
    max = Math.max(max, Math.pow(Math.abs(x), 2), Math.pow(Math.abs(y), 2)) + 1;
    return { title: title, x: x, y: y };
  });

  var coordsLUT = {};
  games.forEach(function (c) {
    var sx = c.x && c.x / Math.abs(c.x);
    var sy = c.y && c.y / Math.abs(c.y);
    var cx = Math.abs(c.x) > 0 ? Math.sqrt(Math.abs(c.x)) * 2 : 0;
    var cy = Math.abs(c.y) > 0 ? Math.sqrt(Math.abs(c.y)) * 2 : 0;
    var x = (0.5 + sx * cx / Math.sqrt(max)) * width;
    var y = (0.5 + sy * cy / Math.sqrt(max)) * height;
    coordsLUT[c.title] = { x: x, y: y };
    if (c.x === 0 && c.y === 0) return;
    bvg.circle(x, y, radius).fill(0);
    bvg.text(c.title, x + 5, y + 3).fill(0);
  });

  roguelikeInfluenceTimeline(relations, coordsLUT);
};

var roguelikeInfluenceTimeline = function roguelikeInfluenceTimeline(relations, coordsLUT) {

  var bvg = _bvg2.default.create('#influence-timeline');
  var tag = bvg.tag();
  var width = tag.clientWidth || tag.parentNode.clientWidth;
  var height = tag.clientHeight || tag.parentNode.clientHeight;
  var radius = 3;
  var fy = _util.ratio.bind(_util.ratio, start_year + 7, end_year - 5);

  var verticalLabelIn = bvg.group("translate(" + 0.007 * width + " " + 0.04 * height + ")");
  verticalLabelIn.text('year', 0, 0).transform('rotate(-90)').fill(0);
  for (var i = start_year + 8; i <= end_year - 6; i++) {
    bvg.text(i.toString(), 0.025 * width, fy(i) * height + 3).fill(0);
  }

  bvg.line(0.015 * width, 0.02 * height, 0.015 * width, 0.99 * height).stroke(0);

  var titlesToOffsetHalf = ["Sword of Fargoal", "Torneko no Daiboken: Fushigi no Dungeon", "Chocobo no Fushigina Dungeon", "Super Lotsa Added Stuff Hack - Extended Magic", "Tao's Adventure: Curse of the Demon Seal", "Pokémon Mystery Dungeon: Explorers of Time and Explorers of Darkness", "Shiren the Wanderer", "Sword of the Stars: The Pit", "Risk of Rain", "WazHack", "Infinite Space III: Sea of Stars", "Smart Kobold"];

  var titlesToOffsetOneThird = ["WazHack", "Izuna: Legend of the Unemployed Ninja"];

  var titlesToOffsetTwoThirds = ["Dungeon Crawl Stone Soup", "TowerClimb"];

  var calcOffset = function calcOffset(title) {
    var offset = titlesToOffsetHalf.indexOf(title) < 0 ? 0 : 16;
    offset = titlesToOffsetOneThird.indexOf(title) < 0 ? offset : 10;
    offset = titlesToOffsetTwoThirds.indexOf(title) < 0 ? offset : 21;
    return offset;
  };

  var connected = {};

  relations.forEach(function (_ref3, i) {
    var title = _ref3.title;
    var year = _ref3.year;
    var inspiredBy = _ref3.inspiredBy;
    var inspirationTo = _ref3.inspirationTo;

    if (year > 2014 || inspiredBy.length === 0 && inspirationTo.length === 0) return;

    var offset = calcOffset(title);

    var x = coordsLUT[title].x;
    var y = fy(year) * height + offset;

    inspiredBy.forEach(function (r) {
      if (Math.abs(year - r.year) > 15) return;
      var offset = calcOffset(r.title);
      var x2 = coordsLUT[r.title].x;
      var y2 = fy(r.year) * height + offset;
      bvg.line(x, y, x2, y2);
      connected[r.title] = true;
      connected[title] = true;
    });
    inspirationTo.forEach(function (r) {
      if (Math.abs(year - r.year) > 15) return;
      var offset = calcOffset(r.title);
      var x2 = coordsLUT[r.title].x;
      var y2 = fy(r.year) * height + offset;
      bvg.line(x, y, x2, y2);
      connected[r.title] = true;
      connected[title] = true;
    });
  });

  relations.forEach(function (_ref4) {
    var title = _ref4.title;
    var year = _ref4.year;

    var offset = calcOffset(title);

    if (connected[title]) {
      var x = coordsLUT[title].x;
      var y = fy(year) * height + offset;
      bvg.circle(x, y, radius).fill(0);
      bvg.text(title, x + 5, y + 3).fill(0);
    }
  });
};

var loadRoguelikeRelationsAll = function loadRoguelikeRelationsAll() {

  return (0, _util.getJSON)(server_url + "/roguelike/relations-all");
};

var arcYeartoYear = function arcYeartoYear(a, b) {
  var invert = arguments.length <= 2 || arguments[2] === undefined ? -1.0 : arguments[2];

  var x_a = fx(a);
  var x_b = fx(b);
  var x = (x_a + x_b) / 2;
  var y = 0.5 + 0.01 * invert;
  var rx = Math.abs(x_b - x_a) / 2;
  var ry = rx;
  var startAngle = 0;
  var endAngle = Math.PI * invert;
  return [x, y, rx, ry, startAngle, endAngle];
};

},{"./util":3,"bvg":1}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var promise = exports.promise = function promise(func) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return new Promise(function (resolve, reject) {
    var callback = function callback(error, data) {
      if (error) reject(error);else resolve(data);
    };
    args.push(callback);
    func.apply(func, args);
  });
};

var ratio = exports.ratio = function ratio(min, max, x) {

  return (x - min) / (max - min);
};

var getURL = exports.getURL = function getURL(url) {
  return new Promise(function (resolve, reject) {
    var req = new XMLHttpRequest();
    req.open('GET', url);
    req.onload = function () {
      if (req.status == 200) {
        resolve(req.response);
      } else {
        reject(new Error(req.statusText));
      }
    };
    req.onerror = function () {
      reject(new Error('Network Error'));
    };
    req.send();
  });
};

var getJSON = exports.getJSON = function getJSON(url) {
  return getURL(url).then(JSON.parse).catch(function (err) {
    console.log('getJSON failed to load', url);
    throw err;
  });
};

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnZnL2J2Zy5qcyIsInJvZ3VlbGlrZS1yZWxhdGlvbnMuanMiLCJ1dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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SyxJQUFNLE9BQU8sV0FBUCxPQUFPLEdBQUcsU0FBVixPQUFPLENBQUksR0FBRyxFQUFLO0FBQzlCLFNBQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxFQUFFO0FBQ3ZELFdBQU8sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDM0MsVUFBTSxHQUFHLENBQUM7R0FDWCxDQUFDLENBQUM7Q0FDSixDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLkJWRyA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vXG4vKiogIyBCVkcgLSBCaW5kYWJsZSBWZWN0b3IgR3JhcGhpY3NcbiAgKiAqKlJlYWwtdGltZSBkYXRhLWRyaXZlbiB2aXN1YWxpc2F0aW9uIGZvciB0aGUgd2ViLioqXG4gICpcbiAgKiAhW0V4YW1wbGVdKGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9TcGF4ZS9CVkcuanMvbWFzdGVyL2RlbW8vaW5kZXguZ2lmKVxuICAqXG4gICogTGl2ZSBleGFtcGxlOiBodHRwOi8vc3BheGUuZ2l0aHViLmlvL0JWRy5qcy9cbiAgKlxuICAqICpCaW5kYWJsZSBWZWN0b3IgR3JhcGhpY3MqIHdhcyBib3JuIG91dCBvZiBmcnVzdHJhdGlvbiBmb3IgbGFjayBvZiBhXG4gICogbWlkZGxlIGxldmVsIFNWRyBsaWJyYXJ5LiBbRDMuanNdKGh0dHA6Ly9kM2pzLm9yZy8pIGFic3RyYWN0cyB0b28gbXVjaFxuICAqIGxvZ2ljLCBhbmQgW1NWRy5qc10oaHR0cDovL3N2Z2pzLmNvbS8pIHByb3ZpZGVzIG9ubHkgbG93LWxldmVsIFNWRyBkcmF3aW5nLlxuICAqIEJpbmRhYmxlIFZlY3RvciBHcmFwaGljcyBvZmZlcnMgU1ZHIGVsZW1lbnRzIHRoYXQgY2hhbmdlIGFzIHRoZSBkYXRhIGNoYW5nZSxcbiAgKiBhbmQgZ2l2ZXMgeW91IHRvb2xzIHRvIGNvbnRyb2wgdGhlaXIgbG9vay5cbiAgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqIFRoZSBoZWFydCBvZiB0aGlzIGxpYnJhcnkgaXMgYSB0cmluaXR5OiAqKlNWRyArIERhdGEgKyBCaW5kaW5nKiouIFRoaXNcbiAgKiBjb25uZWN0cyB5b3VyIGRhdGEgdG8gdGhlIFNWRyBlbGVtZW50IHRocm91Z2ggdGhlIGJpbmRpbmcgZnVuY3Rpb24sIHdoaWNoXG4gICogY3JlYXRlcyBhIGxpdmluZyBjb25uZWN0aW9uIHRoYXQgY2FuIHJlYWN0IHRvIGNoYW5nZS4gQlZHIHVzZXNcbiAgKiBbYE9iamVjdC5vYnNlcnZlKClgXShodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9b2JqZWN0LW9ic2VydmUpIHdoaWNoIGlzXG4gICogYXZhaWxhYmxlIG9uIENocm9tZSAzNissIE9wZXJhIDI3KyBhbmQgQW5kcm9pZCBCcm93c2VyIDM3Ky5cbiAgKlxuICAqIElmIHlvdSB3aXNoIHRvIHVzZSB0aGlzIGZvciBvbGRlciBicm93c2VycywgeW91IGNhbiBwb2x5ZmlsbCB3aXRoXG4gICogW2BNYXhBcnQyNTAxL09iamVjdC5vYnNlcnZlYF0oaHR0cHM6Ly9naXRodWIuY29tL01heEFydDI1MDEvb2JqZWN0LW9ic2VydmUpLlxuICAqXG4gICogIyMgSW5zdGFsbGF0aW9uXG4gICpcbiAgKiAqKkluc3RhbGwgdXNpbmcgYG5wbWAqKjpcbiAgKlxuICAqICAxLiBJbnN0YWxsIE5vZGUuanM6IGh0dHBzOi8vZG9jcy5ucG1qcy5jb20vZ2V0dGluZy1zdGFydGVkL2luc3RhbGxpbmctbm9kZVxuICAqICAyLiBJbiB5b3VyIHdvcmtpbmcgZGlyZWN0b3J5OlxuICAqXG4gICogICAgIGBgYFxuICAqICAgICBucG0gaW5zdGFsbCBidmdcbiAgKiAgICAgYGBgXG4gICpcbiAgKiAqKkluc3RhbGwgdmlhIEdpdEh1YioqOlxuICAqXG4gICogIDEuIENsb25lIHRoaXMgcmVwbzpcbiAgKlxuICAqICAgICBgYGBcbiAgKiAgICAgZ2l0IGNsb25lIGh0dHBzOi8vZ2l0aHViLmNvbS9TcGF4ZS9CVkcuanMuZ2l0XG4gICogICAgIGBgYFxuICAqXG4gICogIDIuIENvcHkgYHJlcXVpcmUuanNgIGFuZCBgYnZnLmpzYCBpbnRvIHlvdXIgd29ya2luZyBkaXJlY3RvcnkuXG4gICpcbiAgKiAqKlRvIGluY2x1ZGUgYEJWRy5qc2AgaW4geW91ciB3ZWJwYWdlKio6XG4gICpcbiAgKiAgMS4gSW4geW91ciBIVE1MIGA8aGVhZD5gLCBpbmNsdWRlIHRoaXMgc2NyaXB0IHVzaW5nIGByZXF1aXJlLmpzYDpcbiAgKlxuICAqICAgICBgYGBIVE1MXG4gICogICAgIDxzY3JpcHQgc3JjPVwicGF0aC90by9yZXF1aXJlLmpzXCIgZGF0YS1tYWluPVwieW91ci1zY3JpcHQuanNcIj48L3NjcmlwdD5cbiAgKiAgICAgYGBgXG4gICpcbiAgKiAgMi4gSW4gYHlvdXItc2NyaXB0LmpzYCwgZGVmaW5lIHlvdXIgb3duIGNvZGUgd2l0aFxuICAqXG4gICogICAgIGBgYEphdmFzY3JpcHRcbiAgKiAgICAgcmVxdWlyZShbJ3BhdGgvdG8vYnZnLmpzJ10sIGZ1bmN0aW9uIChCVkcpIHtcbiAgKiAgICAgICAvLyB5b3VyIGNvZGUgZ29lcyBoZXJlIC4uLlxuICAqICAgICB9KTtcbiAgKiAgICAgYGBgXG4gICpcbiAgKiAjIyBRdWlja3N0YXJ0XG4gICpcbiAgKiAhW1F1aWNrc3RhcnQgRXhhbXBsZV0oaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1NwYXhlL0JWRy5qcy9tYXN0ZXIvZGVtby8wMDEtaGVsbG8uZ2lmKVxuICAqXG4gICogSFRNTDpcbiAgKlxuICAqIGBgYEhUTUxcbiAgKiA8ZGl2IGlkPVwiYnZnLWNvbnRhaW5lclwiPjwvZGl2PlxuICAqIGBgYFxuICAqXG4gICogQ1NTIChNYWtlIHRoZSBjb250YWluZXIgbGFyZ2UgZW5vdWdoKTpcbiAgKlxuICAqIGBgYENTU1xuICAqIGh0bWwsIGJvZHksICNidmctY29udGFpbmVyIHtcbiAgKiAgIGhlaWdodDogMTAwJTtcbiAgKiAgIG1hcmdpbjogMDtcbiAgKiB9XG4gICogYGBgXG4gICpcbiAgKiBKYXZhc2NyaXB0OlxuICAqXG4gICogYGBgSmF2YXNjcmlwdFxuICAqIC8vIENyZWF0ZSBhIEJWRyBjb250YWluZXIgYmFzZWQgb24gc2VsZWN0ZWQgSFRNTCBlbGVtZW50XG4gICogdmFyIGJ2ZyA9IEJWRy5jcmVhdGUoJyNidmctY29udGFpbmVyJyk7XG4gICogLy8gQ3JlYXRlIGEgQmluZGFibGUgY2lyY2xlLCBjb2xvdXIgaXQgb3JhbmdlXG4gICogdmFyIGNpcmNsZSA9IGJ2Zy5lbGxpcHNlKDAsIDAsIDE1MCwgMTUwKVxuICAqICAgICAgICAgICAgICAgICAuZmlsbCgyMjAsIDY0LCAxMik7XG4gICogLy8gQ2hhbmdlIGl0cyBzaXplIGJhc2VkIG9uIG1vdXNlIG1vdmVtZW50XG4gICogYnZnLnRhZygpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAqICAgY2lyY2xlLmRhdGEoe1xuICAqICAgICByeDogZXZlbnQuY2xpZW50WCxcbiAgKiAgICAgcnk6IGV2ZW50LmNsaWVudFlcbiAgKiAgIH0pO1xuICAqIH0pO1xuICAqIGBgYFxuICAqL1xuXG4vKi0gRGVlcCBPYmplY3Qub2JzZXJ2ZSgpICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCVkc7XG5mdW5jdGlvbiBvYnNlcnZlKG9iaiwgY2FsbGJhY2spIHtcblxuICAvLyBJbmNsdWRlIGh0dHBzOi8vZ2l0aHViLmNvbS9NYXhBcnQyNTAxL29iamVjdC1vYnNlcnZlIGlmIHlvdSB3aXNoIHRvIHdvcmtcbiAgLy8gd2l0aCBwb2x5ZmlsbCBvbiBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgT2JqZWN0Lm9ic2VydmUoKVxuICBPYmplY3Qub2JzZXJ2ZShvYmosIGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgY2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcblxuICAgICAgLy8gQmluZCBjaGlsZCBwcm9wZXJ0eSBpZiBpdCBpcyBhbiBvYmplY3QgZm9yIGRlZXAgb2JzZXJ2aW5nXG4gICAgICBpZiAob2JqW2NoYW5nZS5uYW1lXSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBvYnNlcnZlKG9ialtjaGFuZ2UubmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRyaWdnZXIgdXNlciBjYWxsYmFja1xuICAgIGNhbGxiYWNrLmNhbGwodGhpcywgY2hhbmdlcyk7XG4gIH0pO1xuXG4gIC8vIEltbWVkaWF0ZWx5IGZpcmUgb2JzZXJ2ZSB0byBpbml0aWF0ZSBkZWVwIG9ic2VydmluZ1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChvYmpba2V5XSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgb2JzZXJ2ZShvYmpba2V5XSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qLSBgQlZHKHRhZywgZGF0YSwgYmluZGluZylgXG4gICogVGhlIHRyaW5pdHkgb2YgdGhpcyBsaWJyYXJ5OiBTVkcgKyBEYXRhICsgQmluZGluZyBGdW5jdGlvbi5cbiAgKlxuICAqIFJldHVybiB0aGUgQlZHIG9iamVjdCBjcmVhdGVkLlxuICAqXG4gICogIC0gYHRhZ2AgICAgOiBFaXRoZXIgYSBgU3RyaW5nYCBmb3IgdGhlIFNWRyBgdGFnTmFtZWAgb3IgYW55IFtgU1ZHRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50KVxuICAqICAtIGBkYXRhYCAgIDogT2JqZWN0IHdpdGggYXJiaXRyYXJ5IGRhdGEgdG8geW91ciBkZXNpcmVcbiAgKiAgLSBgYmluZGluZ2A6IChvcHRpb25hbCkgQmluZGluZyBmdW5jdGlvbiB0aGF0IHNldHMgdGhlIHRhZyBhdHRyaWJ1dGVzXG4gICovXG5mdW5jdGlvbiBCVkcodGFnLCBkYXRhLCBiaW5kaW5nKSB7XG4gIHZhciBidmcgPSB0aGlzO1xuICB0YWcgPSB0YWcgaW5zdGFuY2VvZiBTVkdFbGVtZW50ID8gdGFnIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIHRhZyk7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBiaW5kaW5nID0gYmluZGluZyB8fCBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB0YWcuc2V0QXR0cmlidXRlKHByb3AsIGRhdGFbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBPYnNlcnZlIGRhdGEgb2JqZWN0IGFuZCBhcHBseSBiaW5kaW5nIHJpZ2h0IGF3YXlcbiAgb2JzZXJ2ZShkYXRhLCBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgIGJpbmRpbmcodGFnLCBkYXRhKTtcbiAgfSk7XG4gIGJpbmRpbmcodGFnLCBkYXRhKTtcblxuICAvLyBJRCBmdW5jdGlvbiBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dvcmRvbmJyYW5kZXIvMjIzMDMxN1xuICB0YWcuc2V0QXR0cmlidXRlKCdpZCcsICdCVkdfJyArIHRhZy50YWdOYW1lICsgJ18nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDcpKTtcbiAgdGhpcy5fdGFnID0gdGFnO1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgdGhpcy5fYmluZGluZyA9IGJpbmRpbmc7XG5cbiAgLy8gRnVuY3Rpb25hbCBjaXJjdWxhciByZWZlcmVuY2VcbiAgdGhpcy5fdGFnLl9nZXRCVkcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJ2ZztcbiAgfTtcblxuICBpZiAoWydzdmcnLCAnZycsICdhJ10uaW5kZXhPZih0YWcudGFnTmFtZSkgPCAwKSB7XG4gICAgaWYgKCFkYXRhLnN0cm9rZSkgdGhpcy5zdHJva2UoMTc1KTtcbiAgICBpZiAoIWRhdGEuc3Ryb2tlV2lkdGgpIHRoaXMuc3Ryb2tlV2lkdGgoMC41KTtcbiAgICBpZiAoIWRhdGEuZmlsbCkgdGhpcy5ub0ZpbGwoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqICMjIFRoZSBCVkcgQ29udGFpbmVyXG4gICogVGhlIHJlc3Qgb2YgdGhlIGRvY3VtZW50YXRpb24gd2lsbCBhc3N1bWUgYGJ2Z2AgYXMgb3VyIEJWRyBjb250YWluZXJcbiAgKiBjcmVhdGVkIGJ5IHRoZSBleGFtcGxlIGJlbG93LlxuICAqL1xuXG4vKiogIyMjIGBCVkcuY3JlYXRlKGh0bWxFbGVtZW50KWBcbiAgKiBDcmVhdGUgYSBCVkcgY29udGFpbmVyIGluc2lkZSBgaHRtbEVsZW1lbnRgLlxuICAqXG4gICogUmV0dXJuIHRoZSBCVkcgY29udGFpbmVyIG9iamVjdC5cbiAgKlxuICAqICAtIGBodG1sRWxlbWVudGAgIDogRWl0aGVyIGEgW0NTUyBTZWxlY3Rvcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQ1NTL0dldHRpbmdfU3RhcnRlZC9TZWxlY3RvcnMpXG4gICogICAgICAgICAgICAgICAgICAgICBvciBhbnkgW0hUTUxFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQpLlxuICAqXG4gICogYGBgSmF2YXNjcmlwdFxuICAqIC8vIENyZWF0ZSBhIG5ldyBCVkcgY29udGFpbmVyIGFuZCBhcHBlbmQgaXQgdG8gYW4gZXhpc3RpbmcgSFRNTCBlbGVtZW50LlxuICAqIHZhciBidmcgPSBCVkcuY3JlYXRlKCcjYnZnLWNvbnRhaW5lcicpO1xuICAqIGBgYFxuICAqL1xudmFyIGNyZWF0ZSA9IGV4cG9ydHMuY3JlYXRlID0gQlZHLmNyZWF0ZSA9IGZ1bmN0aW9uIChodG1sRWxlbWVudCwgeERpbWVuc2lvbiwgeURpbWVuc2lvbikge1xuICBpZiAodHlwZW9mIGh0bWxFbGVtZW50ID09PSAnc3RyaW5nJykgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGh0bWxFbGVtZW50KTtcbiAgaWYgKCEoaHRtbEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2h0bWxFbGVtZW50ICgnICsgaHRtbEVsZW1lbnQgKyAnKSB3YXMgbm90IGZvdW5kLicpO1xuXG4gIHZhciBkYXRhID0ge1xuICAgICd4bWxuczp4bGluayc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICB2ZXJzaW9uOiAxLjEsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJ1xuICB9O1xuICB5RGltZW5zaW9uID0geURpbWVuc2lvbiB8fCB4RGltZW5zaW9uO1xuICBpZiAoeERpbWVuc2lvbikge1xuICAgIGRhdGEudmlld0JveCA9IFswLCAwLCB4RGltZW5zaW9uLCB5RGltZW5zaW9uXS5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgYnZnID0gbmV3IEJWRygnc3ZnJywgZGF0YSk7XG4gIGh0bWxFbGVtZW50LmFwcGVuZENoaWxkKGJ2Zy50YWcoKSk7XG4gIHJldHVybiBidmc7XG59O1xuXG4vKiogIyMgQlZHIEVsZW1lbnRzXG4gICogQWxsIEJWRyBvYmplY3RzLCBpbmNsdWRpbmcgdGhlIGNvbnRhaW5lciwgaGF2ZSBhY2Nlc3MgdG8gZHJhd2luZyBmdW5jdGlvbnNcbiAgKiBhbmQgcmV0dXJuIHJlZmVyZW5jZSB0byB0aGUgbmV3IHNoYXBlLCB3aGljaCBpcyBhbHNvIGEgQlZHLlxuICAqXG4gICogYGBgSmF2YXNjcmlwdFxuICAqIC8vIENyZWF0ZSBhIHJlY3RhbmdsZSBhdCAoMCwgMCkgd2l0aCBkaW1lbnNpb25zIDEwMHgxMDAgcHggYW5kIGFkZCBpdCB0byBidmdcbiAgKiB2YXIgcmVjdCA9IGJ2Zy5yZWN0KDAsIDAsIDEwMCwgMTAwKTtcbiAgKiBgYGBcbiAgKlxuICAqIFRoZSBCVkcgbW9kdWxlIGFsc28gaGFzIGRyYXdpbmcgZnVuY3Rpb25zLCB3aGljaCByZXR1cm4gdGhlIEJWRyBvYmplY3Q6XG4gICpcbiAgKiBgYGBKYXZhc2NyaXB0XG4gICogLy8gQ3JlYXRlIGEgcmVjdGFuZ2xlIGF0ICgwLCAwKSB3aXRoIGRpbWVuc2lvbnMgMTAweDEwMCBweFxuICAqIC8vIE5vdGUgaXQgdXNlcyB0aGUgQlZHIG1vZHVsZSBkaXJlY3RseSB0byBjcmVhdGUgdGhlIHJlY3RhbmdsZS5cbiAgKiB2YXIgcmVjdCA9IEJWRy5yZWN0KDAsIDAsIDEwMCwgMTAwKTtcbiAgKiAvLyBBZGQgdGhlIHJlY3RhbmdsZSB0byBhbiBleGlzdGluZyBCVkcgY29udGFpbmVyXG4gICogYnZnLmFwcGVuZChyZWN0KTtcbiAgKiBgYGBcbiAgKlxuICAqIERyYXdpbmcgZnVuY3Rpb25zIGNhbiBiZSBjYWxsZWQgaW4gYSBudW1iZXIgb2Ygd2F5cy4gVGFrZSBgYnZnLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodClgXG4gICogYXMgYW4gZXhhbXBsZSBiZWxvdy4gU29tZXRpbWVzIGl0IGlzIGVhc2llciB0byB1c2Ugb25lIG92ZXIgYW5vdGhlciBzdHlsZS5cbiAgKlxuICAqIGBgYEphdmFzY3JpcHRcbiAgKiBidmcucmVjdCgwLCAxMCwgMzAsIDcwKTsgICAgICAvLyBBcmd1bWVudHMgc3R5bGVcbiAgKiBidmcucmVjdCh7ICAgICAgICAgICAgICAgICAgICAvLyBPYmplY3Qgc3R5bGVcbiAgKiAgIHg6IDAsXG4gICogICB5OiAxMCwgICAgICAgICAgICAgICAgICAgICAgLy8gTmFtZSBvZiB0aGUgb2JqZWN0IHByb3BlcnRpZXMgbXVzdCBtYXRjaFxuICAqICAgd2lkdGg6IDMwLCAgICAgICAgICAgICAgICAgIC8vIG5hbWVzIG9mIHRoZSBhcmd1bWVudHMgaW4gdGhlIGZ1bmN0aW9ucyxcbiAgKiAgIGhlaWdodDogNzAgICAgICAgICAgICAgICAgICAvLyBidXQgdGhlIG9yZGVyIGNhbiBiZSBhbnkuXG4gICogfSk7XG4gICogYGBgXG4gICovXG52YXIgY3JlYXRpb25GdW5jdGlvbnMgPSB7XG4gIHN2ZzogZnVuY3Rpb24gc3ZnKHhsaW5rLCB2ZXJzaW9uLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ3N2ZycsIHhsaW5rLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8geGxpbmsgOiB7XG4gICAgICAneG1sbnM6eGxpbmsnOiB4bGluayxcbiAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKiAjIyMgYGJ2Zy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpYFxuICAgICogQ3JlYXRlIGEgcmVjdGFuZ2xlIGF0IHBvc2l0aW9uIGAoeCwgeSlgIGF0IGB3aWR0aGAgeCBgaGVpZ2h0YCBpbiBzaXplLlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIHZhciByZWN0ID0gYnZnLnJlY3QoMTAwLCAxMDAsIDMwMCwgMTUwKTtcbiAgICAqIGBgYFxuICAgICovXG4gIHJlY3Q6IGZ1bmN0aW9uIHJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiBuZXcgQlZHKCdyZWN0JywgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHggOiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqICMjIyBgYnZnLmNpcmNsZShjeCwgY3ksIHIpYFxuICAgICogQ3JlYXRlIGEgY2lyY2xlIGNlbnRyZWQgb24gYChjeCwgY3kpYCB3aXRoIHJhZGl1cyBgcmAuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogdmFyIGNpcmNsZSA9IGJ2Zy5lbGxpcHNlKDEwMCwgMTAwLCA1MCk7XG4gICAgKiBgYGBcbiAgICAqL1xuICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZSh4LCB5LCByKSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ2NpcmNsZScsIHguY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyB4IDoge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICByOiByXG4gICAgfSwgZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgnY3gnLCBkYXRhLngpO1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgnY3knLCBkYXRhLnkpO1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgncicsIGRhdGEucik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqICMjIyBgYnZnLmVsbGlwc2UoY3gsIGN5LCByeCwgcnkpYFxuICAgICogQ3JlYXRlIGEgZWxsaXBzZSBjZW50cmVkIG9uIGAoY3gsIGN5KWAgd2l0aCByYWRpaSBgcnhgIGFuZCBgcnlgLlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIHZhciBlbGxpcHNlID0gYnZnLmVsbGlwc2UoMTAwLCAxMDAsIDIwMCwgMTgwKTtcbiAgICAqIGBgYFxuICAgICovXG4gIGVsbGlwc2U6IGZ1bmN0aW9uIGVsbGlwc2UoeCwgeSwgcngsIHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ2VsbGlwc2UnLCB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8geCA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgcng6IHJ4LFxuICAgICAgcnk6IHJ5XG4gICAgfSwgZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgnY3gnLCBkYXRhLngpO1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgnY3knLCBkYXRhLnkpO1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgncngnLCBkYXRhLnJ4KTtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3J5JywgZGF0YS5yeSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqICMjIyBgYnZnLmxpbmUoeDEsIHkxLCB4MiwgeTIpYFxuICAgICogQ3JlYXRlIGEgbGluZSBmcm9tIGAoeDEsIHkxKWAgdG8gYCh4MiwgeTIpYC5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiB2YXIgbGluZSA9IGJ2Zy5saW5lKDEwMCwgMTAwLCAyMDAsIDMwMCk7XG4gICAgKiBgYGBcbiAgICAqL1xuICBsaW5lOiBmdW5jdGlvbiBsaW5lKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ2xpbmUnLCB4MS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHgxIDoge1xuICAgICAgeDE6IHgxLFxuICAgICAgeTE6IHkxLFxuICAgICAgeDI6IHgyLFxuICAgICAgeTI6IHkyXG4gICAgfSk7XG4gIH0sXG4gIC8qKiAjIyMgYGJ2Zy5wb2x5bGluZShbW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi5dKWBcbiAgICAqIENyZWF0ZSBhIHNlcmllcyBvZiBsaW5lcyBmcm9tIHBvaW50IHRvIHBvaW50LlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIHZhciBwb2x5bGluZSA9IGJ2Zy5wb2x5bGluZShbWzEwMCwgMjAwXSwgWzIwMCwgMzAwXSwgWzQwMCwgODAwXV0pO1xuICAgICogYGBgXG4gICAgKi9cbiAgcG9seWxpbmU6IGZ1bmN0aW9uIHBvbHlsaW5lKHBvaW50cykge1xuICAgIHJldHVybiBuZXcgQlZHKCdwb2x5bGluZScsIHBvaW50cy5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHBvaW50cyA6IHtcbiAgICAgIHBvaW50czogcG9pbnRzXG4gICAgfSwgZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgncG9pbnRzJywgZGF0YS5wb2ludHMuam9pbignICcpKTtcbiAgICB9KTtcbiAgfSxcbiAgLyoqICMjIyBgYnZnLnBvbHlnb24oW1t4MSwgeTFdLCBbeDIsIHkyXSwgLi4uXSlgXG4gICAgKiBDcmVhdGUgYSBjbG9zZWQgcG9seWdvbiBmcm9tIHBvaW50IHRvIHBvaW50LiBUaGUgbGFzdCBwb2ludCB3aWxsIGJlXG4gICAgKiBjb25uZWN0ZWQgYmFjayB0byB0aGUgZmlyc3QgcG9pbnQuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogdmFyIHBvbHlnb24gPSBidmcucG9seWdvbihbWzEwMCwgMjAwXSwgWzIwMCwgMzAwXSwgWzQwMCwgODAwXV0pO1xuICAgICogYGBgXG4gICAgKi9cbiAgcG9seWdvbjogZnVuY3Rpb24gcG9seWdvbihwb2ludHMpIHtcbiAgICByZXR1cm4gbmV3IEJWRygncG9seWdvbicsIHBvaW50cy5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyA/IHBvaW50cyA6IHtcbiAgICAgIHBvaW50czogcG9pbnRzXG4gICAgfSwgZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgncG9pbnRzJywgZGF0YS5wb2ludHMuam9pbignICcpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKiogIyMgR3JvdXBpbmcgRWxlbWVudHNcbiAgICAqICMjIyBgYnZnLmdyb3VwKFt0cmFuc2Zvcm1dKWBcbiAgICAqXG4gICAgKiBDcmVhdGUgYSBncm91cCB0byBjb250YWluIEJWRyBvYmplY3RzLiBJdCBhY3RzIGxpa2UgYSBCVkcgY29udGFpbmVyIHdpdGhcbiAgICAqIGFuIG9wdGlvbmFsIGB0cmFuc2Zvcm1gIGF0dHJpYnV0ZS5cbiAgICAqXG4gICAgKiBgYGBKYXZhc2NyaXB0XG4gICAgKiAvLyBDcmVhdGUgYSBuZXcgZ3JvdXAgYW5kIGZpbGwgaXQgd2l0aCBkYXNoZXMuXG4gICAgKiB2YXIgZGFzaGVzID0gYnZnLmdyb3VwKCk7XG4gICAgKiBmb3IgKGludCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICogICBkYWhzZXMucmVjdCgxMCwgMTAgKyBpICogMzAsIDUwLCAyMCk7XG4gICAgKiB9XG4gICAgKiBgYGBcbiAgICAqL1xuICBncm91cDogZnVuY3Rpb24gZ3JvdXAodHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ2cnLCB0cmFuc2Zvcm0uY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyB0cmFuc2Zvcm0gOiB7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKiAjIyBIeXBlcmxpbmtzXG4gICAgKiAjIyMgYGJ2Zy5oeXBlcmxpbmsodXJsKWBcbiAgICAqXG4gICAgKiBDcmVhdGUgYSBoeXBlcmxpbmsgQlZHIHRvIHRhcmdldCBVUkwgYHVybGAuIEl0IGRvZXMgbm90IGhhdmUgYW55IGRpc3BsYXlcbiAgICAqIGVsZW1lbnRzLiBNYWtlIHN1cmUgdG8gYXBwZW5kIGVsZW1lbnRzIHRvIGl0LlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIC8vIENsaWNraW5nIG9uIHRoaXMgZWxlbWVudCB3aWxsIGJyaW5nIHRoZW0gdG8gdGhlIEdpdGh1YiBwYWdlXG4gICAgKiB2YXIgZ2l0aHViTGluayA9IGJ2Zy5oeXBlcmxpbmsoJ2h0dHBzOi8vZ2l0aHViLmNvbS9zcGF4ZS9CVkcuanMnKTtcbiAgICAqIC8vIE1ha2UgYSBidXR0b24gYW5kIGF0dGFjayBpdCB0byB0aGUgbGlua1xuICAgICogZ2l0aHViTGluay5lbGxpcHNlKDIwMCwgMjAwLCA1MCwgNTApO1xuICAgICogYGBgXG4gICAgKi9cbiAgaHlwZXJsaW5rOiBmdW5jdGlvbiBoeXBlcmxpbmsodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ2EnLCB1cmwuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyB1cmwgOiB7XG4gICAgICAneG1sbnM6aHJlZic6IHVybFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKiAjIyBPdGhlciBHZW9tZXRyeVxuICAgICogIyMjIGBidmcudHJpYW5nbGUoY3gsIGN5LCByKWBcbiAgICAqIENyZWF0ZSBhIHJlZ3VsYXIgdHJpYW5nbGUgY2VudHJlZCBvbiBgKGN4LCBjeSlgIHdpdGggdmVydGljZXMgYHJgIGRpc3RhbmNlXG4gICAgKiBhd2F5LlxuICAgICpcbiAgICAqIGBgYEphdmFzY3JpcHRcbiAgICAqIHZhciB0cmlhbmdsZSA9IGJ2Zy50cmlhbmdsZSg1MCwgNTAsIDEwKTtcbiAgICAqIGBgYFxuICAgICovXG4gIHRyaWFuZ2xlOiBmdW5jdGlvbiB0cmlhbmdsZSh4LCB5LCByKSB7XG4gICAgcmV0dXJuIG5ldyBCVkcoJ3BvbHlnb24nLCB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8geCA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgcjogclxuICAgIH0sIGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbW2RhdGEueCwgZGF0YS55IC0gZGF0YS5yXSwgW2RhdGEueCAtIGRhdGEuciAvIDIgKiBNYXRoLnNxcnQoMyksIGRhdGEueSArIGRhdGEuciAvIDJdLCBbZGF0YS54ICsgZGF0YS5yIC8gMiAqIE1hdGguc3FydCgzKSwgZGF0YS55ICsgZGF0YS5yIC8gMl1dO1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgncG9pbnRzJywgcG9pbnRzLmpvaW4oJyAnKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqICMjIyBgYnZnLmFyYyhjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpYFxuICAgICogQ3JlYXRlIGFuIGFyYyBjZW50cmVkIG9uIGAoY3gsIGN5KWAgd2l0aCByYWRpdXMgYHJ4YCBhbmQgYHJ5YCwgc3RhcnRpbmdcbiAgICAqIGZyb20gYHN0YXJ0QW5nbGVgIGFudGktY2xvY2t3aXNlIHRvIGBlbmRBbmdsZWAsIHdoZXJlIDAgaXMgdGhlIHBvc2l0aXZlXG4gICAgKiB4LWF4aXMuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogdmFyIGFyYyA9IGJ2Zy5hcmMoNTAsIDUwLCA1MCwgMTAwLCAwLCBNYXRoLlBJKTtcbiAgICAqIGBgYFxuICAgICovXG4gIGFyYzogZnVuY3Rpb24gYXJjKHgsIHksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gbmV3IEJWRygncGF0aCcsIHguY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyB4IDoge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICByeDogcngsXG4gICAgICByeTogcnksXG4gICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlXG4gICAgfSwgZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgICAgdmFyIHAxID0gZ2V0UG9pbnRPbkVsbGlwc2UoZGF0YS54LCBkYXRhLnksIGRhdGEucngsIGRhdGEucnksIGRhdGEuc3RhcnRBbmdsZSk7XG4gICAgICB2YXIgcDIgPSBnZXRQb2ludE9uRWxsaXBzZShkYXRhLngsIGRhdGEueSwgZGF0YS5yeCwgZGF0YS5yeSwgZGF0YS5lbmRBbmdsZSk7XG4gICAgICB2YXIgbGFyZ2VBcmMgPSBkYXRhLmVuZEFuZ2xlIC0gZGF0YS5zdGFydEFuZ2xlID4gTWF0aC5QSSA/IDEgOiAwO1xuICAgICAgdmFyIHN3ZWVwQXJjID0gZGF0YS5lbmRBbmdsZSA+IGRhdGEuc3RhcnRBbmdsZSA/IDEgOiAwO1xuICAgICAgdmFyIGQgPSBbWydNJywgcDEueCwgcDEueV0sIFsnQScsIGRhdGEucngsIGRhdGEucnksIDAsIGxhcmdlQXJjLCBzd2VlcEFyYywgcDIueCwgcDIueV1dO1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgnZCcsIGQubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LmpvaW4oJyAnKTtcbiAgICAgIH0pLmpvaW4oJyAnKSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBvaW50T25FbGxpcHNlKHgsIHksIHJ4LCByeSwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiByeCAqIE1hdGguY29zKGFuZ2xlKSArIHgsXG4gICAgICAgICAgeTogcnkgKiBNYXRoLnNpbihhbmdsZSkgKyB5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqICMjIyBgYnZnLnRleHQodGV4dCwgeCwgeSlgXG4gICAgKiBDcmVhdGUgYSBzdHJpbmcgb2YgYHRleHRgIHRleHQgYXQgbG9jYXRpb24gYCh4LCB5KWAuXG4gICAgKlxuICAgICogYGBgSmF2YXNjcmlwdFxuICAgICogdmFyIHRleHQgPSBidmcudGV4dCgnTXJyYWEhJywgMjAsIDEwKTtcbiAgICAqIGBgYFxuICAgICovXG4gIHRleHQ6IGZ1bmN0aW9uIHRleHQoX3RleHQsIHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IEJWRygndGV4dCcsIF90ZXh0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8gX3RleHQgOiB7XG4gICAgICB0ZXh0OiBfdGV4dCxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSwgZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgICAgdGFnLmlubmVySFRNTCA9IGRhdGEudGV4dDtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3gnLCBkYXRhLngpO1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgneScsIGRhdGEueSk7XG4gICAgfSkuZmlsbCgncmdiYSgxNzUsIDE3NSwgMTc1LCAxKScpLnN0cm9rZSgncmdiYSgwLCAwLCAwLCAwKScpO1xuICB9XG59O1xuXG5PYmplY3Qua2V5cyhjcmVhdGlvbkZ1bmN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBCVkdbZl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0aW9uRnVuY3Rpb25zW2ZdLmFwcGx5KEJWRywgYXJndW1lbnRzKTtcbiAgfTtcbiAgQlZHLnByb3RvdHlwZVtmXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnZnID0gY3JlYXRpb25GdW5jdGlvbnNbZl0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmFwcGVuZChidmcpO1xuICAgIHJldHVybiBidmc7XG4gIH07XG59KTtcblxuLyoqICMjIFRoZSBCVkcgT2JqZWN0XG4gICogQlZHcyBhcmUgU1ZHcyB3aXRoIGV4dHJhIHN1cGVycG93ZXJzLlxuICAqL1xuXG4vKiogIyMjIGBidmcuZmluZChzZWxlY3RvcilgXG4gICogUmV0dXJuIGFuIGFycmF5IG9mIEJWR3MgbWF0Y2hpbmcgYHNlbGVjdG9yYCBpbnNpZGUgQlZHLiBgc2VsZWN0b3JgIGlzXG4gICogZGVmaW5lZCBhcyBbQ1NTIFNlbGVjdG9yc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQ1NTL0dldHRpbmdfc3RhcnRlZC9TZWxlY3RvcnMpLlxuICAqL1xuQlZHLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl90YWcucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB2YXIgYnZncyA9IFtdO1xuICAgIFtdLnNsaWNlLmNhbGwocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBidmdzLnB1c2goci5fZ2V0QlZHKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBidmdzO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5cbi8qKiAjIyMgYGJ2Zy5hcHBlbmQoYnZnKWBcbiAgKiBJbnNlcnQgYGNoaWxkX2J2Z2AgaW5zaWRlIGBidmdgLiBUaGlzIGlzIHVzZWZ1bCB0byBhZGQgZWxlbWVudHMgaW5zaWRlIGFcbiAgKiBgQlZHLmdyb3VwKClgLlxuICAqL1xuQlZHLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoY2hpbGRfYnZnKSB7XG4gIHRoaXMuX3RhZy5hcHBlbmRDaGlsZChjaGlsZF9idmcuX3RhZyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqICMjIyBgYnZnLnJlbW92ZSgpYFxuICAqIFJlbW92ZSBpdHNlbGYgZnJvbSBpdHMgcGFyZW50LiBSZXR1cm4gc2VsZiByZWZlcmVuY2UuXG4gICovXG5CVkcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQuX3RhZy5yZW1vdmVDaGlsZCh0aGlzLl90YWcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqICMjIyBgYnZnLnBhcmVudCgpYFxuICAqIFJldHVybiB0aGUgcGFyZW50IEJWRy4gSWYgdGhlcmUgaXMgbm8gcGFyZW50IChzdWNoIGlzIHRoZSBjYXNlIGZvciB0aGUgQlZHXG4gICogY29udGFpbmVyIGl0c2VsZiksIHJldHVybiBudWxsLlxuICAqL1xuQlZHLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl90YWcucGFyZW50Tm9kZSAmJiB0eXBlb2YgdGhpcy5fdGFnLnBhcmVudE5vZGUuX2dldEJWRyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuX3RhZy5wYXJlbnROb2RlLl9nZXRCVkcoKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKiogIyMjIGBidmcuY2hpbGRyZW4oKWBcbiAgKiBSZXR1cm4gYSBsaXN0IG9mIEJWRyBlbGVtZW50cyBpbnNpZGUgYGJ2Z2AuXG4gICovXG5CVkcucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGFnLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3RhZy5jaGlsZE5vZGVzW2ldLl9nZXRCVkcgPT09ICdmdW5jdGlvbicpIG91dHB1dC5wdXNoKHRoaXMuX3RhZy5jaGlsZE5vZGVzW2ldLl9nZXRCVkcoKSk7XG4gIH1yZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqICMjIyBgYnZnLnRhZygpYFxuICAqIFJldHVybiB0aHcgQlZHIGdyYXBoaWNhbCBjb250ZW50LCBhIFNWRy5cbiAgKi9cbkJWRy5wcm90b3R5cGUudGFnID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdGFnO1xufTtcblxuLyoqICMjIyBgYnZnLmRhdGEoKWBcbiAqIEdldC9zZXQgdGhlIGBkYXRhYCBvYmplY3QgaW4gYSBCVkcuIFRoZXJlIGFyZSBmb3VyIHdheXMgdG8gdXNlIHRoaXNcbiAqIGZ1bmN0aW9uLlxuICpcbiAqICAtIGBidmcuZGF0YSgpYDogUmV0dXJuIGBkYXRhYCBib3VuZCB0byB0aGUgQlZHLlxuICogIC0gYGJ2Zy5kYXRhKG5ld0RhdGEpYDogVXBkYXRlIGBkYXRhYCB3aXRoIGBuZXdEYXRhYCBvYmplY3QuXG4gKiAgLSBgYnZnLmRhdGEocHJvcGVydHkpYDogUmV0dXJuIGBkYXRhW3Byb3BlcnR5XWAgZnJvbSB0aGUgQlZHLlxuICogIC0gYGJ2Zy5kYXRhKHByb3BlcnR5LCBuZXdWYWx1ZSlgOiBVcGRhdGUgYHByb3BlcnR5YCB3aXRoIGBuZXdWYWx1ZWAuXG4gKlxuICogUmV0dXJuIGBidmdgIG9iamVjdCByZWZlcmVuY2UuXG4gKi9cbkJWRy5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIHRoaXMuZGF0YShrLCBhcmd1bWVudHNbMF1ba10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbYXJndW1lbnRzWzBdXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMuX2RhdGFbYXJndW1lbnRzWzBdXSA9IGFyZ3VtZW50c1sxXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcih0aGlzLCAnZGF0YSgpIHJlY2VpdmVkIG1vcmUgdGhhbiAyIGFyZ3VtZW50cy4nKTtcbiAgfVxufTtcblxuLyoqICMjIyBgYnZnLmF0dHIoKWBcbiAgKiBHZXQvc2V0IGF0dHJpYnV0ZXMgb24gYSBCVkcuXG4gICpcbiAgKiAgLSBgYnZnLmF0dHIoYXR0cilgOiBSZXR1cm4gYXR0cmlidXRlIHZhbHVlLlxuICAqICAtIGBidmcuYXR0cihhdHRyLCB2YWx1ZSlgOiBVcGRhdGUgYGF0dHJgIHdpdGggYHZhbHVlYC5cbiAgKi9cbkJWRy5wcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xuICBpZiAoIWF0dHIpIHRocm93IG5ldyBFcnJvcignYXR0ciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIHRoaXMuX3RhZy5nZXRBdHRyaWJ1dGUoYXR0cik7ZWxzZSB0aGlzLl90YWcuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogIyMjIGBidmcuZmlsbCgpYFxuICAqIEdldC9zZXQgdGhlIGZpbGxpbmcgY29sb3VyLlxuICAqXG4gICogIC0gYGJ2Zy5maWxsKClgOiBSZXR1cm4gYGZpbGxgIGNvbG91ciBhcyBbciwgZywgYiwgYV0sIG9yIGAnJ2AgKGVtcHR5XG4gICogICAgICAgICAgICAgICAgICBzdHJpZykgaWYgZmlsbCBpcyBub3Qgc3BlY2lmaWVkIG9uIHRoZSBvYmplY3QuXG4gICogIC0gYGJ2Zy5maWxsKHJnYilgOiBTZXQgYGZpbGxgIHdpdGggYSBncmV5c2NhbGUgY29sb3VyIHdpdGggZXF1YWxcbiAgKiAgICB2YWx1ZXMgYChyZ2IsIHJnYiwgcmdiKWAuXG4gICogIC0gYGJ2Zy5maWxsKHIsIGcsIGIsIFthXSlgOiBTZXQgYGZpbGxgIHdpdGggYChyLCBnLCBiLCBhKWAuIElmIGBhYFxuICAqICAgIGlzIG9taXR0ZWQsIGl0IGRlZmF1bHRzIHRvIGAxYC5cbiAgKlxuICAqIGByYCwgYGdgLCBgYmAgc2hvdWxkIGJlIGluIHRoZSByYW5nZSBvZiAwLTI1NSBpbmNsdXNpdmUuXG4gICovXG5CVkcucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIGYgPSB0aGlzLmF0dHIoJ2ZpbGwnKTtcbiAgICBpZiAoZikgcmV0dXJuIEJWRy5leHRyYWN0TnVtYmVyQXJyYXkoZik7XG4gICAgcmV0dXJuICcnO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycpIHJldHVybiB0aGlzLmF0dHIoJ2ZpbGwnLCBhcmd1bWVudHNbMF0pO2Vsc2UgcmV0dXJuIHRoaXMuYXR0cignZmlsbCcsIEJWRy5yZ2JhKGFyZ3VtZW50c1swXSkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ2ZpbGwnLCBCVkcucmdiYS5hcHBseShCVkcsIGFyZ3VtZW50cykpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHRoaXMsICdmaWxsKCkgcmVjZWl2ZWQgbW9yZSB0aGFuIDEgYXJndW1lbnQuJyk7XG4gIH1cbn07XG5cbi8qKiAjIyMgYGJ2Zy5ub0ZpbGwoKWBcbiAgKiBSZW1vdmUgQlZHIG9iamVjdCdzIGNvbG91ciBmaWxsaW5nIGNvbXBsZXRlbHkuXG4gICovXG5CVkcucHJvdG90eXBlLm5vRmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZmlsbCgncmdiYSgwLCAwLCAwLCAwKScpO1xufTtcblxuLyoqICMjIyBgYnZnLnN0cm9rZSgpYFxuICAqIEdldC9zZXQgdGhlIG91dGxpbmUgY29sb3VyLlxuICAqXG4gICogIC0gYGJ2Zy5zdHJva2UoKWA6IFJldHVybiBgc3Ryb2tlYCBjb2xvdXIgYXMgW3IsIGcsIGIsIGFdLiBJZiBgc3Ryb2tlYCBpc1xuICAqICAgIG5vdCBzcGVjaWZpZWQsIHJldHVybiBgJydgIChlbXB0eSBzdHJpbmcpLlxuICAqICAtIGBidmcuc3Ryb2tlKHJnYilgOiBTZXQgYHN0cm9rZWAgd2l0aCBhIGdyZXlzY2FsZSBjb2xvdXIgd2l0aCBlcXVhbFxuICAqICAgIHZhbHVlcyBgKHJnYiwgcmdiLCByZ2IpYC5cbiAgKiAgLSBgYnZnLnN0cm9rZShyLCBnLCBiLCBbYV0pYDogU2V0IGBzdHJva2VgIHdpdGggYChyLCBnLCBiLCBhKWAuIElmIGBhYFxuICAqICAgIGlzIG9taXR0ZWQsIGl0IGRlZmF1bHRzIHRvIGAxYC5cbiAgKlxuICAqIGByYCwgYGdgLCBgYmAgc2hvdWxkIGJlIGluIHRoZSByYW5nZSBvZiAwLTI1NSBpbmNsdXNpdmUuXG4gICovXG5CVkcucHJvdG90eXBlLnN0cm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgcyA9IHRoaXMuYXR0cignc3Ryb2tlJyk7XG4gICAgaWYgKHMpIHJldHVybiBCVkcuZXh0cmFjdE51bWJlckFycmF5KHMpO1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSByZXR1cm4gdGhpcy5hdHRyKCdzdHJva2UnLCBhcmd1bWVudHNbMF0pO2Vsc2UgcmV0dXJuIHRoaXMuYXR0cignc3Ryb2tlJywgQlZHLnJnYmEoYXJndW1lbnRzWzBdKSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignc3Ryb2tlJywgQlZHLnJnYmEuYXBwbHkoQlZHLCBhcmd1bWVudHMpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcih0aGlzLCAnc3Ryb2tlKCkgcmVjZWl2ZWQgbW9yZSB0aGFuIDEgYXJndW1lbnQuJyk7XG4gIH1cbn07XG5cbi8qKiAjIyMgYGJ2Zy5zdHJva2VXaWR0aChbd2lkdGhdKWBcbiAgKiBHZXQvc2V0IHRoZSBvdXRsaW5lIHRoaWNrbmVzcy5cbiAgKlxuICAqIFJldHVybnMgdGhlIGN1cnJlbnQgb3V0bGluZSB0aGlja25lc3MgaWYgYHdpZHRoYCBpcyBvbWl0dGVkLiBPdGhlcmlzZSxcbiAgKiBpdCBhc3NpZ25zIHRoZSBvdXRsaW5lIHRoaWNrbmVzcyB3aXRoIGEgbmV3IHZhbHVlLCBhbmQgcmV0dXJucyB0aGUgYGJ2Z2BcbiAgKiBvYmplY3QgcmVmZXJlbmNlLlxuICAqXG4gICogIC0gYHdpZHRoYCAgOiBPdXRsaW5lIHRoaWNrbmVzcyBpbiBwaXhlbHMuXG4gICovXG5CVkcucHJvdG90eXBlLnN0cm9rZVdpZHRoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3N0cm9rZS13aWR0aCcpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGFyZ3VtZW50c1swXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IodGhpcywgJ3N0cm9rZVdpZHRoKCkgcmVjZWl2ZWQgbW9yZSB0aGFuIDEgYXJndW1lbnQuJyk7XG4gIH1cbn07XG5cbi8qKiAjIyMgYGJ2Zy5ub1N0cm9rZSgpYFxuICAqIFJlbW92ZSBCVkcgb2JqZWN0J3Mgb3V0bGluZSBjb21wbGV0ZWx5LlxuICAqL1xuQlZHLnByb3RvdHlwZS5ub1N0cm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc3Ryb2tlV2lkdGgoMCkuc3Ryb2tlKCdyZ2JhKDAsIDAsIDAsIDApJyk7XG59O1xuXG5CVkcucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhZy5pbm5lckhUTUw7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuX3RhZy5pbm5lckhUTUwgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IodGhpcywgJ2NvbnRlbnQoKSByZWNlaXZlZCBtb3JlIHRoYW4gMSBhcmd1bWVudC4nKTtcbiAgfVxufTtcblxuLyoqICMjIyBgYnZnLmFkZENsYXNzKGMpYFxuKiBBZGQgYSBjbGFzcyBuYW1lIHRvIHRoZSBlbGVtZW50LlxuKi9cbkJWRy5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoYykge1xuICB0aGlzLl90YWcuY2xhc3NMaXN0LmFkZChjKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogIyMjIGBidmcucmVtb3ZlQ2xhc3MoYylgXG4gICogUmVtb3ZlIGEgY2xhc3MgbmFtZSB0byB0aGUgZWxlbWVudC5cbiAgKi9cbkJWRy5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoYykge1xuICB0aGlzLl90YWcuY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogIyMjIGBidmcuaGFzQ2xhc3MoYylgXG4gICogUmV0dXJuIHRydWUgaWYgdGhlIGVsZW1lbnQgaGFzIGNsYXNzIGBjYC5cbiAgKi9cbkJWRy5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoYykge1xuICByZXR1cm4gdGhpcy5fdGFnLmNsYXNzTGlzdC5jb250YWlucyhjKTtcbn07XG5cbi8qKiAjIyMgYGJ2Zy5yZW1vdmVDbGFzcyhjKWBcbiAgKiBBZGQgb3IgcmVtb3ZlIHRoZSBjbGFzcyBgY2AgdG8gdGhlIGVsZW1lbnQuXG4gICovXG5CVkcucHJvdG90eXBlLnRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGMpIHtcbiAgdGhpcy5fdGFnLmNsYXNzTGlzdC50b2dnbGUoYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqICMjIEFmZmluZSBUcmFuc2Zvcm1hdGlvbnMgKi9cbkJWRy5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl90YWcuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5fdGFnLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgYXJndW1lbnRzWzBdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zZm9ybSgpIHJlY2VpdmVkIG1vcmUgdGhhbiAxIGFyZ3VtZW50Jyk7XG4gIH1cbn07XG5cbi8qKiAjIyMgYEJWRy50cmFuc2xhdGUoeCwgW3ldKWBcbiAgKiBBcHBseSBhIG1vdmluZyB0cmFuc2xhdGlvbiBieSBgeGAgYW5kIGB5YCB1bml0cy4gSWYgYHlgIGlzIG5vdCBnaXZlbiwgaXRcbiAgKiBpcyBhc3N1bWVkIHRvIGJlIDAuXG4gICovXG5CVkcucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIGlmICh0eXBlb2YgeCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHkgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zbGF0ZSgpIG9ubHkgdGFrZSBudW1iZXJzIGFzIGFyZ3VtZW50cycpO1xuICB5ID0geSB8fCAwO1xuICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0oKTtcbiAgdGhpcy5fdGFnLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgW3RyYW5zZm9ybSwgJyB0cmFuc2xhdGUoJywgeCwgJyAnLCB5LCAnKSddLmpvaW4oJycpLnRyaW0oKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqICMjIFV0aWxpdHkgTWV0aG9kcyAqL1xuXG4vKiogIyMjIGBCVkcucmdiYShyLCBnLCBiLCBbYV0pYFxuICAqIFJldHVybiBhIHN0cmluZyBpbiB0aGUgZm9ybSBvZiBgcmdiYShyLCBnLCBiLCBhKWAuXG4gICpcbiAgKiBJZiBvbmx5IGByYCBpcyBnaXZlbiwgdGhlIHZhbHVlIGlzIGNvcGllZCB0byBgZ2AgYW5kIGBiYCB0byBwcm9kdWNlIGFcbiAgKiBncmV5c2NhbGUgdmFsdWUuXG4gICovXG5CVkcucmdiYSA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gMS4wIDogYXJndW1lbnRzWzNdO1xuXG4gIGlmICh0eXBlb2YgciAhPT0gJ251bWJlcicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JnYmEoKSBtdXN0IHRha2UgbnVtZXJpY2FsIHZhbHVlcyBhcyBpbnB1dCcpO1xuICBnID0gZyB8fCByO1xuICBiID0gYiB8fCByO1xuICByZXR1cm4gJ3JnYmEoJyArIFtyLCBnLCBiLCBhXS5qb2luKCcsJykgKyAnKSc7XG59O1xuXG4vKiogIyMjIGBCVkcuaHNsYShodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgW2FscGhhXSlgXG4gICogUmV0dXJuIHRoZSBDU1MgcmVwcmVzZW50YXRpb24gaW4gYGhzbGEoKWAgYXMgYSBzdHJpbmcuXG4gICpcbiAgKiAgLSBgaHVlYDogQSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmQgYDM2MGAsIHdoZXJlIGAwYCBpcyByZWQsIGAxMjBgIGlzIGdyZWVuLFxuICAqICAgICAgICAgICBhbmQgYDI0MGAgaXMgYmx1ZS5cbiAgKiAgLSBgc2F0dXJhdGlvbmAgOiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMTAwYCwgd2hlcmUgYDBgIGlzIGdyZXkgYW5kXG4gICogICAgICAgICAgICAgICAgIGAxMDBgIGlzIGZ1bGx5IHNhdHVyYXRlLlxuICAqICAtIGBsaWdodG5lc3NgOiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMTAwYCwgd2hlcmUgYDBgIGlzIGJsYWNrIGFuZFxuICAqICAgICAgICAgICAgICAgICBgMTAwYCBpcyBmdWxsIGludGVuc2l0eSBvZiB0aGUgY29sb3VyLlxuICAqL1xuQlZHLmhzbGEgPSBmdW5jdGlvbiAoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhKSB7XG4gIGFscGhhID0gYWxwaGEgfHwgMS4wO1xuICByZXR1cm4gJ2hzbGEoJyArIFtodWUsIHNhdHVyYXRpb24gKyAnJScsIGxpZ2h0bmVzcyArICclJywgYWxwaGFdLmpvaW4oJywnKSArICcpJztcbn07XG5cbi8qKiAjIyMgYEJWRy5leHRyYWN0TnVtYmVyQXJyYXkoc3RyKWBcbiAgKiBSZXR1cm4gYW4gYXJyYXkgYFt4LCB5LCB6LCAuLi5dYCBmcm9tIGEgc3RyaW5nIGNvbnRhaW5pbmcgY29tbW9uLXNlcGFyYXRlZFxuICAqIG51bWJlcnMuXG4gICovXG5CVkcuZXh0cmFjdE51bWJlckFycmF5ID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLm1hdGNoKC9cXGQqXFwuP1xcZCsvZykubWFwKE51bWJlcik7XG59O1xuXG4vKiogIyMgQ29udHJpYnV0ZSB0byB0aGlzIGxpYnJhcnlcbiogW01ha2UgYSBwdWxsIHJlcXVlc3RdKGh0dHBzOi8vZ2l0aHViLmNvbS9TcGF4ZS9CVkcuanMvcHVsbHMpIG9yXG4qIFtwb3N0IGFuIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vU3BheGUvQlZHLmpzL2lzc3VlcykuIFNheSBoZWxsbyB0b1xuKiBjb250YWN0QHhhaXZlcmhvLmNvbS5cbiovXG5cbn0se31dfSx7fSxbMV0pKDEpXG59KTsiLCIvKipcbiAqIFJvZ3VlbGlrZSBVbml2ZXJzZVxuICogQXV0aG9yOiBYYXZpZXIgSG8gPGNvbnRhY3RAeGF2aWVyaG8uY29tPlxuICogaHR0cHM6Ly9naXRodWIuY29tL1NwYXhlL3JvZ3VlbGlrZS11bml2ZXJzZVxuICovXG5pbXBvcnQgQlZHIGZyb20gXCJidmdcIjtcbmltcG9ydCB7IHByb21pc2UsIHJhdGlvLCBnZXRKU09OIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5jb25zdCBzZXJ2ZXJfdXJsID0gJ2h0dHA6Ly8xODguMTY2LjIwOS4xNTUvYXBpL3YxJztcbmNvbnN0IHN0YXJ0X3llYXIgPSAxOTcwLCBlbmRfeWVhciA9IDIwMjA7XG5jb25zdCBmeCA9IHJhdGlvLmJpbmQocmF0aW8sIHN0YXJ0X3llYXIsIGVuZF95ZWFyKTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcblxuICBsb2FkUm9ndWVsaWtlUmVsYXRpb25zQWxsKCkudGhlbiggcmVsYXRpb25zID0+IHtcbiAgICByb2d1ZWxpa2VSZWxhdGlvbnMocmVsYXRpb25zKTtcbiAgICBnZW5yZUluZmx1ZW5jZU1hcChyZWxhdGlvbnMpO1xuICB9KTtcblxufSk7XG5cbmNvbnN0IHJvZ3VlbGlrZVJlbGF0aW9ucyA9IChyZWxhdGlvbnMpID0+IHtcblxuICBsZXQgYnZnID0gQlZHLmNyZWF0ZSgnI3JvZ3VlbGlrZS1yZWxhdGlvbnMnKTtcbiAgbGV0IGZvY3VzID0gYnZnLmdyb3VwKCcnKTtcbiAgbGV0IHRhZyA9IGJ2Zy50YWcoKTtcbiAgbGV0IHdpZHRoID0gdGFnLmNsaWVudFdpZHRoIHx8IHRhZy5wYXJlbnROb2RlLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gdGFnLmNsaWVudEhlaWdodCB8fCB0YWcucGFyZW50Tm9kZS5jbGllbnRIZWlnaHQ7XG4gIGxldCBHVUlfZ2FtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYW1lJyk7XG4gIGxldCBzZWxlY3Rpb24gPSAnRHVuZ2Vvbic7XG5cbiAgbGV0IGRyYXdBcmMgPSAoZywgeWVhckEsIHllYXJCLCBpbnZlcnQ9LTEuMCwgb3BhY2l0eT0xLCBzdHJva2VXaWR0aD0xKSA9PiB7XG4gICAgbGV0IGFyZ3MgPSBhcmNZZWFydG9ZZWFyKHllYXJBLCB5ZWFyQiwgaW52ZXJ0KTtcbiAgICBhcmdzWzBdICo9IHdpZHRoOyBhcmdzWzFdICo9IGhlaWdodDsgYXJnc1syXSAqPSBoZWlnaHQ7IGFyZ3NbM10gKj0gaGVpZ2h0O1xuICAgIGcuYXJjKC4uLmFyZ3MpLnN0cm9rZSgwLCAwLCAwLCBvcGFjaXR5KS5zdHJva2VXaWR0aChzdHJva2VXaWR0aCk7XG4gIH07XG5cbiAgLy8gRHJhdyB0aW1lbGluZVxuICBidmcudGV4dCgneWVhcicsXG4gICAgICAgICAgIDAuMDAxICogd2lkdGgsXG4gICAgICAgICAgIGhlaWdodCAvIDIgKyAzKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0X3llYXIgKyAyOyBpIDwgZW5kX3llYXI7IGkrKykge1xuICAgIGlmIChpICUgNSA9PT0gMCkge1xuICAgICAgYnZnLnRleHQoaS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgKGZ4KGkpIC0gMC4wMikgKiB3aWR0aCxcbiAgICAgICAgICAgICAgIGhlaWdodCAvIDIgKyAzXG4gICAgICApLmZpbGwoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ2Zy50ZXh0KCfCtycsXG4gICAgICAgICAgICAgICAoZngoaSkgLSAwLjAwMjUpICogd2lkdGgsXG4gICAgICAgICAgICAgICBoZWlnaHQgLyAyICsgM1xuICAgICAgKS5maWxsKDApO1xuICAgIH1cbiAgfVxuICBidmcudGV4dCgnSW4tZ2VucmUnLFxuICAgICAgICAgICAwLjAwMSAqIHdpZHRoLFxuICAgICAgICAgICAwLjEgKiBoZWlnaHQpO1xuICBidmcudGV4dCgnT3V0LW9mLWdlbnJlJyxcbiAgICAgICAgICAgMC4wMDEgKiB3aWR0aCxcbiAgICAgICAgICAgMC45ICogaGVpZ2h0KTtcblxuXG4gIC8vIFBvcHVsYXRlIGdhbWUgdGl0bGVzXG4gIHJlbGF0aW9ucy5mb3JFYWNoKCBnYW1lID0+IHtcbiAgICBsZXQgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0aW9uLnZhbHVlID0gZ2FtZS50aXRsZTtcbiAgICBvcHRpb24uc2V0QXR0cmlidXRlKCdkYXRhLXllYXInLCBnYW1lLnllYXIpO1xuICAgIG9wdGlvbi5pbm5lckhUTUwgPSBgJHtnYW1lLnRpdGxlfSAoJHtnYW1lLnllYXJ9KWA7XG4gICAgR1VJX2dhbWUuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgfSk7XG5cbiAgLy8gQmluZCBzZWxlY3Rpb25cbiAgR1VJX2dhbWUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXZlbnQgPT4ge1xuICAgIHNlbGVjdGlvbiA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICBkcmF3U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gIH0pO1xuXG4gIC8vIERyYXcgaW5mbHVlbmNlIGFyY3NcbiAgcmVsYXRpb25zLmZvckVhY2goICh7dGl0bGUsIHllYXIsIGluc3BpcmVkQnksIGluc3BpcmF0aW9uVG8sIG90aGVySW5zcGlyZWRCeSwgb3RoZXJJbnNwaXJhdGlvblRvfSkgPT4ge1xuXG4gICAgaW5zcGlyZWRCeS5mb3JFYWNoKCByID0+IHtcbiAgICAgIGRyYXdBcmMoYnZnLCB5ZWFyLCByLnllYXIsIC0xLjAsIDAuMSk7XG4gICAgfSk7XG4gICAgaW5zcGlyYXRpb25Uby5mb3JFYWNoKCByID0+IHtcbiAgICAgIGRyYXdBcmMoYnZnLCByLnllYXIsIHllYXIsIC0xLjAsIDAuMSk7XG4gICAgfSk7XG4gICAgb3RoZXJJbnNwaXJlZEJ5LmZvckVhY2goIHIgPT4ge1xuICAgICAgZHJhd0FyYyhidmcsIHllYXIsIHIueWVhciwgMS4wLCAwLjA1KTtcbiAgICB9KTtcbiAgICBvdGhlckluc3BpcmF0aW9uVG8uZm9yRWFjaCggciA9PiB7XG4gICAgICBkcmF3QXJjKGJ2Zywgci55ZWFyLCB5ZWFyLCAxLjAsIDAuMDUpO1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIGxldCBkcmF3U2VsZWN0aW9uID0gKHNlbGVjdGlvbikgPT4ge1xuICAgIGZvY3VzLnRhZygpLmlubmVySFRNTCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlbGF0aW9uID0gcmVsYXRpb25zW2ldO1xuICAgICAgaWYgKHJlbGF0aW9uLnRpdGxlID09PSBzZWxlY3Rpb24pIHtcblxuICAgICAgICBmb2N1cy50ZXh0KHNlbGVjdGlvbiwgZngocmVsYXRpb24ueWVhcikgKiB3aWR0aCwgMC4wOTUgKiBoZWlnaHQpXG4gICAgICAgICAgLmZpbGwoMCk7XG5cbiAgICAgICAgZm9jdXMubGluZSh7XG4gICAgICAgICAgeDE6IGZ4KHJlbGF0aW9uLnllYXIpICogd2lkdGgsXG4gICAgICAgICAgeTE6IGhlaWdodCAqIDAuMSxcbiAgICAgICAgICB4MjogZngocmVsYXRpb24ueWVhcikgKiB3aWR0aCxcbiAgICAgICAgICB5MjogaGVpZ2h0ICogMC45XG4gICAgICAgIH0pLnN0cm9rZVdpZHRoKDIpLnN0cm9rZSgwLCAwLCAwLCAwLjUpO1xuXG4gICAgICAgIHJlbGF0aW9uLmluc3BpcmVkQnkuZm9yRWFjaCggciA9PiB7XG4gICAgICAgICAgZHJhd0FyYyhmb2N1cywgcmVsYXRpb24ueWVhciwgci55ZWFyLCAtMSwgMSwgMyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWxhdGlvbi5pbnNwaXJhdGlvblRvLmZvckVhY2goIHIgPT4ge1xuICAgICAgICAgIGRyYXdBcmMoZm9jdXMsIHIueWVhciwgcmVsYXRpb24ueWVhciwgLTEsIDEsIDMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVsYXRpb24ub3RoZXJJbnNwaXJlZEJ5LmZvckVhY2goIHIgPT4ge1xuICAgICAgICAgIGRyYXdBcmMoZm9jdXMsIHJlbGF0aW9uLnllYXIsIHIueWVhciwgMSwgMSwgMyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWxhdGlvbi5vdGhlckluc3BpcmF0aW9uVG8uZm9yRWFjaCggciA9PiB7XG4gICAgICAgICAgZHJhd0FyYyhmb2N1cywgci55ZWFyLCByZWxhdGlvbi55ZWFyLCAxLCAxLCAzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBGaXJlIGV2ZW50IHRvIHN0YXJ0XG4gIEdVSV9nYW1lLnZhbHVlID0gc2VsZWN0aW9uO1xuICBkcmF3U2VsZWN0aW9uKHNlbGVjdGlvbik7XG59O1xuXG5jb25zdCBnZW5yZUluZmx1ZW5jZU1hcCA9IChyZWxhdGlvbnMpID0+IHtcblxuICBsZXQgYnZnID0gQlZHLmNyZWF0ZSgnI2dlbnJlLWluZmx1ZW5jZScpO1xuICBsZXQgZm9jdXMgPSBidmcuZ3JvdXAoJycpO1xuICBsZXQgdGFnID0gYnZnLnRhZygpO1xuICBsZXQgd2lkdGggPSB0YWcuY2xpZW50V2lkdGggfHwgdGFnLnBhcmVudE5vZGUuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSB0YWcuY2xpZW50SGVpZ2h0IHx8IHRhZy5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcbiAgbGV0IHJhZGl1cyA9IDM7XG5cbiAgLy8gQXhpc1xuICBidmcubGluZSgwLjEgKiB3aWR0aCwgMC4wMSAqIGhlaWdodCwgMC4xICogd2lkdGgsIDAuOSAqIGhlaWdodCkuc3Ryb2tlKDApO1xuICBidmcubGluZSgwLjEgKiB3aWR0aCwgMC45ICogaGVpZ2h0LCAwLjk5ICogd2lkdGgsIDAuOSAqIGhlaWdodCkuc3Ryb2tlKDApO1xuICBsZXQgdmVydGljYWxMYWJlbEluID0gYnZnLmdyb3VwKGB0cmFuc2xhdGUoJHswLjA5ICogd2lkdGh9ICR7MC4xNSAqIGhlaWdodH0pYCk7XG4gIHZlcnRpY2FsTGFiZWxJbi50ZXh0KCdJbmZsdWVuY2VzIGZyb20gaW4tZ2VucmUnLCAwLCAwKS50cmFuc2Zvcm0oJ3JvdGF0ZSgtOTApJyk7XG4gIGxldCB2ZXJ0aWNhbExhYmVsT3V0ID0gYnZnLmdyb3VwKGB0cmFuc2xhdGUoJHswLjA5ICogd2lkdGh9ICR7MC45ICogaGVpZ2h0fSlgKTtcbiAgdmVydGljYWxMYWJlbE91dC50ZXh0KCdJbmZsdWVuY2VzIGZyb20gb3V0LW9mLWdlbnJlJywgMCwgMCkudHJhbnNmb3JtKCdyb3RhdGUoLTkwKScpO1xuICBidmcudGV4dCgnSW5mbHVlbmNlZCBieSB0aGUgcGFzdCcsIDAuMTEgKiB3aWR0aCwgMC45MTUgKiBoZWlnaHQpO1xuICBidmcudGV4dCgnSW5mbHVlbmNlcyB0aGUgZnV0dXJlJywgMC44NyAqIHdpZHRoLCAwLjkxNSAqIGhlaWdodCk7XG5cbiAgbGV0IG1heCA9IDA7XG4gIGxldCBnYW1lcyA9IHJlbGF0aW9ucy5tYXAoICh7dGl0bGUsIHllYXIsIGluc3BpcmVkQnksIGluc3BpcmF0aW9uVG8sIG90aGVySW5zcGlyZWRCeSwgb3RoZXJJbnNwaXJhdGlvblRvfSkgPT4ge1xuXG4gICAgaWYgKFtcbiAgICAgICdEdW5nZW9uIENyYXdsIFN0b25lIFNvdXAnLFxuICAgICAgJ1Bva8OpbW9uIE15c3RlcnkgRHVuZ2VvbjogRXhwbG9yZXJzIG9mIFRpbWUgYW5kIEV4cGxvcmVycyBvZiBEYXJrbmVzcycsXG4gICAgICAnU2hpcmVuIHRoZSBXYW5kZXJlcicsXG4gICAgICAnTXlzdGVyeSBEdW5nZW9uOiBTaGlyZW4gdGhlIFdhbmRlcmVyJyxcbiAgICAgICdXZWlyZCBXb3JsZHM6IFJldHVybiB0byBJbmZpbml0ZSBTcGFjZScsXG4gICAgICAnUG9rw6ltb24gTXlzdGVyeSBEdW5nZW9uOiBFeHBsb3JlcnMgb2YgU2t5JyxcbiAgICAgICdJenVuYSAyOiBUaGUgVW5lbXBsb3llZCBOaW5qYSBSZXR1cm5zJyxcbiAgICAgICdTd29yZCBvZiB0aGUgU3RhcnM6IFRoZSBQaXQnLFxuICAgICAgXCJUYW8ncyBBZHZlbnR1cmU6IEN1cnNlIG9mIHRoZSBEZW1vbiBTZWFcIixcbiAgICAgICdEcmFnb24gUXVlc3Q6IFNob25lbiBZYW5ndXMgdG8gRnVzaGlnaSBubyBEdW5nZW9uJyxcbiAgICAgICdUZWxlZ2xpdGNoJyxcbiAgICAgIFwiTW9yYWZmJ3MgUmV2ZW5nZVwiLFxuICAgICAgJ0Rvb20sIHRoZSBSb2d1ZWxpa2UnLFxuICAgICAgXCJDaG9jb2JvJ3MgRHVuZ2VvbiAyXCIsXG4gICAgICAnTm90IHRoZSBSb2JvdHMnLFxuICAgICAgXCJTbGF2ZXMgdG8gQXJtb2sgSUk6IER3YXJmIEZvcnRyZXNzXCIsXG4gICAgICAnSXp1bmE6IExlZ2VuZCBvZiB0aGUgVW5lbXBsb3llZCBOaW5qYScsXG4gICAgICAnRGVhZGx5IER1bmdlb25zJyxcbiAgICAgIFwiVGFvJ3MgQWR2ZW50dXJlOiBDdXJzZSBvZiB0aGUgRGVtb24gU2VhbFwiLFxuICAgICAgJ0Nob2NvYm8gbm8gRnVzaGlnaW5hIER1bmdlb24nLFxuICAgICAgJ1JvZ3VlIExlZ2FjeSdcbiAgICBdLmluZGV4T2YodGl0bGUpID49IDApIHJldHVybiB7dGl0bGUsIHg6IDAsIHk6IDB9O1xuXG4gICAgbGV0IGlCID0gaW5zcGlyZWRCeS5sZW5ndGg7XG4gICAgbGV0IGlUID0gaW5zcGlyYXRpb25Uby5sZW5ndGg7XG4gICAgbGV0IG9CID0gb3RoZXJJbnNwaXJlZEJ5Lmxlbmd0aCAvIDQ7XG4gICAgbGV0IG9UID0gb3RoZXJJbnNwaXJhdGlvblRvLmxlbmd0aCAvIDQ7XG4gICAgbGV0IHggPSAtaUIgLSBvQiArIGlUICsgb1Q7XG4gICAgbGV0IHkgPSAtaUIgKyBvQiAtIGlUICsgb1Q7XG4gICAgbWF4ID0gTWF0aC5tYXgobWF4LCBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMiksIE1hdGgucG93KE1hdGguYWJzKHkpLCAyKSkgKyAxO1xuICAgIHJldHVybiB7IHRpdGxlLCB4LCB5IH07XG5cbiAgfSk7XG5cbiAgbGV0IGNvb3Jkc0xVVCA9IHt9O1xuICBnYW1lcy5mb3JFYWNoKCBjID0+IHtcbiAgICBsZXQgc3ggPSBjLnggJiYgYy54IC8gTWF0aC5hYnMoYy54KTtcbiAgICBsZXQgc3kgPSBjLnkgJiYgYy55IC8gTWF0aC5hYnMoYy55KTtcbiAgICBsZXQgY3ggPSBNYXRoLmFicyhjLngpID4gMCA/IE1hdGguc3FydChNYXRoLmFicyhjLngpKSAqIDIgOiAwO1xuICAgIGxldCBjeSA9IE1hdGguYWJzKGMueSkgPiAwID8gTWF0aC5zcXJ0KE1hdGguYWJzKGMueSkpICogMiA6IDA7XG4gICAgbGV0IHggPSAoMC41ICsgc3ggKiBjeCAvIE1hdGguc3FydChtYXgpKSAqIHdpZHRoO1xuICAgIGxldCB5ID0gKDAuNSArIHN5ICogY3kgLyBNYXRoLnNxcnQobWF4KSkgKiBoZWlnaHQ7XG4gICAgY29vcmRzTFVUW2MudGl0bGVdID0ge3gsIHl9O1xuICAgIGlmIChjLnggPT09IDAgJiYgYy55ID09PSAwKSByZXR1cm47XG4gICAgYnZnLmNpcmNsZSh4LCB5LCByYWRpdXMpLmZpbGwoMCk7XG4gICAgYnZnLnRleHQoYy50aXRsZSwgeCArIDUsIHkgKyAzKS5maWxsKDApO1xuICB9KTtcblxuICByb2d1ZWxpa2VJbmZsdWVuY2VUaW1lbGluZShyZWxhdGlvbnMsIGNvb3Jkc0xVVCk7XG5cbn07XG5cbmNvbnN0IHJvZ3VlbGlrZUluZmx1ZW5jZVRpbWVsaW5lID0gKHJlbGF0aW9ucywgY29vcmRzTFVUKSA9PiB7XG5cbiAgbGV0IGJ2ZyA9IEJWRy5jcmVhdGUoJyNpbmZsdWVuY2UtdGltZWxpbmUnKTtcbiAgbGV0IHRhZyA9IGJ2Zy50YWcoKTtcbiAgbGV0IHdpZHRoID0gdGFnLmNsaWVudFdpZHRoIHx8IHRhZy5wYXJlbnROb2RlLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gdGFnLmNsaWVudEhlaWdodCB8fCB0YWcucGFyZW50Tm9kZS5jbGllbnRIZWlnaHQ7XG4gIGxldCByYWRpdXMgPSAzO1xuICBsZXQgZnkgPSByYXRpby5iaW5kKHJhdGlvLCBzdGFydF95ZWFyICsgNywgZW5kX3llYXIgLSA1KSA7XG5cbiAgbGV0IHZlcnRpY2FsTGFiZWxJbiA9IGJ2Zy5ncm91cChgdHJhbnNsYXRlKCR7MC4wMDcgKiB3aWR0aH0gJHswLjA0ICogaGVpZ2h0fSlgKTtcbiAgdmVydGljYWxMYWJlbEluLnRleHQoJ3llYXInLCAwLCAwKS50cmFuc2Zvcm0oJ3JvdGF0ZSgtOTApJykuZmlsbCgwKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0X3llYXIgKyA4OyBpIDw9IGVuZF95ZWFyIC0gNjsgaSsrKSB7XG4gICAgYnZnLnRleHQoaS50b1N0cmluZygpLCAwLjAyNSAqIHdpZHRoLCBmeShpKSAqIGhlaWdodCArIDMpLmZpbGwoMCk7XG4gIH1cblxuICBidmcubGluZSgwLjAxNSAqIHdpZHRoLCAwLjAyICogaGVpZ2h0LCAwLjAxNSAqIHdpZHRoLCAwLjk5ICogaGVpZ2h0KS5zdHJva2UoMCk7XG5cbiAgbGV0IHRpdGxlc1RvT2Zmc2V0SGFsZiA9IFtcbiAgICBcIlN3b3JkIG9mIEZhcmdvYWxcIixcbiAgICBcIlRvcm5la28gbm8gRGFpYm9rZW46IEZ1c2hpZ2kgbm8gRHVuZ2VvblwiLFxuICAgIFwiQ2hvY29ibyBubyBGdXNoaWdpbmEgRHVuZ2VvblwiLFxuICAgIFwiU3VwZXIgTG90c2EgQWRkZWQgU3R1ZmYgSGFjayAtIEV4dGVuZGVkIE1hZ2ljXCIsXG4gICAgXCJUYW8ncyBBZHZlbnR1cmU6IEN1cnNlIG9mIHRoZSBEZW1vbiBTZWFsXCIsXG4gICAgXCJQb2vDqW1vbiBNeXN0ZXJ5IER1bmdlb246IEV4cGxvcmVycyBvZiBUaW1lIGFuZCBFeHBsb3JlcnMgb2YgRGFya25lc3NcIixcbiAgICBcIlNoaXJlbiB0aGUgV2FuZGVyZXJcIixcbiAgICBcIlN3b3JkIG9mIHRoZSBTdGFyczogVGhlIFBpdFwiLFxuICAgIFwiUmlzayBvZiBSYWluXCIsXG4gICAgXCJXYXpIYWNrXCIsXG4gICAgXCJJbmZpbml0ZSBTcGFjZSBJSUk6IFNlYSBvZiBTdGFyc1wiLFxuICAgIFwiU21hcnQgS29ib2xkXCIsXG4gIF07XG5cbiAgbGV0IHRpdGxlc1RvT2Zmc2V0T25lVGhpcmQgPSBbXG4gICAgXCJXYXpIYWNrXCIsXG4gICAgXCJJenVuYTogTGVnZW5kIG9mIHRoZSBVbmVtcGxveWVkIE5pbmphXCIsXG4gIF07XG5cbiAgbGV0IHRpdGxlc1RvT2Zmc2V0VHdvVGhpcmRzID0gW1xuICAgIFwiRHVuZ2VvbiBDcmF3bCBTdG9uZSBTb3VwXCIsXG4gICAgXCJUb3dlckNsaW1iXCIsXG4gIF07XG5cbiAgY29uc3QgY2FsY09mZnNldCA9ICh0aXRsZSkgPT4ge1xuICAgIGxldCBvZmZzZXQgPSB0aXRsZXNUb09mZnNldEhhbGYuaW5kZXhPZih0aXRsZSkgPCAwID8gMCA6IDE2O1xuICAgICAgICBvZmZzZXQgPSB0aXRsZXNUb09mZnNldE9uZVRoaXJkLmluZGV4T2YodGl0bGUpIDwgMCA/IG9mZnNldCA6IDEwO1xuICAgICAgICBvZmZzZXQgPSB0aXRsZXNUb09mZnNldFR3b1RoaXJkcy5pbmRleE9mKHRpdGxlKSA8IDAgPyBvZmZzZXQgOiAyMTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgbGV0IGNvbm5lY3RlZCA9IHt9O1xuXG4gIHJlbGF0aW9ucy5mb3JFYWNoKCAoe3RpdGxlLCB5ZWFyLCBpbnNwaXJlZEJ5LCBpbnNwaXJhdGlvblRvfSwgaSkgPT4ge1xuXG4gICAgaWYgKHllYXIgPiAyMDE0IHx8XG4gICAgICAgIChpbnNwaXJlZEJ5Lmxlbmd0aCA9PT0gMCAmJiBpbnNwaXJhdGlvblRvLmxlbmd0aCA9PT0gMCkpXG4gICAgICByZXR1cm47XG5cbiAgICBsZXQgb2Zmc2V0ID0gY2FsY09mZnNldCh0aXRsZSk7XG5cbiAgICBsZXQgeCA9IGNvb3Jkc0xVVFt0aXRsZV0ueDtcbiAgICBsZXQgeSA9IGZ5KHllYXIpICogaGVpZ2h0ICsgb2Zmc2V0O1xuXG4gICAgaW5zcGlyZWRCeS5mb3JFYWNoKCByID0+IHtcbiAgICAgIGlmIChNYXRoLmFicyh5ZWFyIC0gci55ZWFyKSA+IDE1KSByZXR1cm47XG4gICAgICBsZXQgb2Zmc2V0ID0gY2FsY09mZnNldChyLnRpdGxlKTtcbiAgICAgIGxldCB4MiA9IGNvb3Jkc0xVVFtyLnRpdGxlXS54O1xuICAgICAgbGV0IHkyID0gZnkoci55ZWFyKSAqIGhlaWdodCArIG9mZnNldDtcbiAgICAgIGJ2Zy5saW5lKHgsIHksIHgyLCB5Mik7XG4gICAgICBjb25uZWN0ZWRbci50aXRsZV0gPSB0cnVlO1xuICAgICAgY29ubmVjdGVkW3RpdGxlXSA9IHRydWU7XG4gICAgfSk7XG4gICAgaW5zcGlyYXRpb25Uby5mb3JFYWNoKCByID0+IHtcbiAgICAgIGlmIChNYXRoLmFicyh5ZWFyIC0gci55ZWFyKSA+IDE1KSByZXR1cm47XG4gICAgICBsZXQgb2Zmc2V0ID0gY2FsY09mZnNldChyLnRpdGxlKTtcbiAgICAgIGxldCB4MiA9IGNvb3Jkc0xVVFtyLnRpdGxlXS54O1xuICAgICAgbGV0IHkyID0gZnkoci55ZWFyKSAqIGhlaWdodCArIG9mZnNldDtcbiAgICAgIGJ2Zy5saW5lKHgsIHksIHgyLCB5Mik7XG4gICAgICBjb25uZWN0ZWRbci50aXRsZV0gPSB0cnVlO1xuICAgICAgY29ubmVjdGVkW3RpdGxlXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgcmVsYXRpb25zLmZvckVhY2goICh7dGl0bGUsIHllYXJ9KSA9PiB7XG5cbiAgICBsZXQgb2Zmc2V0ID0gY2FsY09mZnNldCh0aXRsZSk7XG5cbiAgICBpZiAoY29ubmVjdGVkW3RpdGxlXSkge1xuICAgICAgbGV0IHggPSBjb29yZHNMVVRbdGl0bGVdLng7XG4gICAgICBsZXQgeSA9IGZ5KHllYXIpICogaGVpZ2h0ICsgb2Zmc2V0O1xuICAgICAgYnZnLmNpcmNsZSh4LCB5LCByYWRpdXMpLmZpbGwoMCk7XG4gICAgICBidmcudGV4dCh0aXRsZSwgeCArIDUsIHkgKyAzKS5maWxsKDApO1xuICAgIH1cblxuICB9KTtcblxufTtcblxuY29uc3QgbG9hZFJvZ3VlbGlrZVJlbGF0aW9uc0FsbCA9ICgpID0+IHtcblxuICByZXR1cm4gZ2V0SlNPTihgJHtzZXJ2ZXJfdXJsfS9yb2d1ZWxpa2UvcmVsYXRpb25zLWFsbGApO1xuXG59O1xuXG5sZXQgYXJjWWVhcnRvWWVhciA9IChhLCBiLCBpbnZlcnQ9LTEuMCkgPT4ge1xuXG4gIGxldCB4X2EgPSBmeChhKTtcbiAgbGV0IHhfYiA9IGZ4KGIpO1xuICBsZXQgeCA9ICh4X2EgKyB4X2IpIC8gMjtcbiAgbGV0IHkgPSAwLjUgKyAwLjAxICogaW52ZXJ0O1xuICBsZXQgcnggPSBNYXRoLmFicyh4X2IgLSB4X2EpIC8gMjtcbiAgbGV0IHJ5ID0gcng7XG4gIGxldCBzdGFydEFuZ2xlID0gMDtcbiAgbGV0IGVuZEFuZ2xlID0gTWF0aC5QSSAqIGludmVydDtcbiAgcmV0dXJuIFt4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlXTtcblxufTtcblxuIiwiZXhwb3J0IGNvbnN0IHByb21pc2UgPSAoIGZ1bmMsIC4uLmFyZ3MgKSA9PiB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+IHtcbiAgICBjb25zdCBjYWxsYmFjayA9ICggZXJyb3IsIGRhdGEgKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHJlamVjdChlcnJvcik7XG4gICAgICBlbHNlIHJlc29sdmUoZGF0YSk7XG4gICAgfTtcbiAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgIGZ1bmMuYXBwbHkoZnVuYywgYXJncyk7XG4gIH0pO1xuXG59O1xuXG5leHBvcnQgY29uc3QgcmF0aW8gPSAobWluLCBtYXgsIHgpID0+IHtcblxuICByZXR1cm4gKHggLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRVUkwgPSAodXJsKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwpO1xuICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVxLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgcmVzb2x2ZShyZXEucmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXEuc3RhdHVzVGV4dCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05ldHdvcmsgRXJyb3InKSk7XG4gICAgfTtcbiAgICByZXEuc2VuZCgpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRKU09OID0gKHVybCkgPT4ge1xuICByZXR1cm4gZ2V0VVJMKHVybCkudGhlbihKU09OLnBhcnNlKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgY29uc29sZS5sb2coJ2dldEpTT04gZmFpbGVkIHRvIGxvYWQnLCB1cmwpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59OyJdfQ==
